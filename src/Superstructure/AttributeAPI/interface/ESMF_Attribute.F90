/* Copyright (C) 1991-2018 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
/* This header is separate from features.h so that the compiler can
   include it implicitly at the start of every compilation.  It must
   not itself include <features.h> or any other header that includes
   <features.h> because the implicit include comes before any feature
   test macros that may be defined in a source file before it first
   explicitly includes a system header.  GCC knows the name of this
   header in order to preinclude it.  */
/* glibc's intent is to support the IEC 559 math functionality, real
   and complex.  If the GCC (4.9 and later) predefined macros
   specifying compiler intent are available, use them to determine
   whether the overall intent is to support these features; otherwise,
   presume an older compiler has intent to support these features and
   define these macros by default.  */
/* wchar_t uses Unicode 10.0.0.  Version 10.0 of the Unicode Standard is
   synchronized with ISO/IEC 10646:2017, fifth edition, plus
   the following additions from Amendment 1 to the fifth edition:
   - 56 emoji characters
   - 285 hentaigana
   - 3 additional Zanabazar Square characters */
/* We do not support C11 <threads.h>.  */
! $Id$
!
! Earth System Modeling Framework
! Copyright 2002-2018, University Corporation for Atmospheric Research,
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics
! Laboratory, University of Michigan, National Centers for Environmental
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
#define ESMF_FILENAME "ESMF_Attribute.F90"
!==============================================================================
!
! ESMF Attribute Module
!
! (all lines between the !BOP and !EOP markers will be included in the
! automated document processing.)
!------------------------------------------------------------------------------
! one blank line for protex processing - in case all routines here are
! marked internal (BOPI/EOPI), the output file will still have contents.
!BOP
!EOP
!------------------------------------------------------------------------------
! module definition
module ESMF_AttributeMod
!
!------------------------------------------------------------------------------
! INCLUDES
#include "ESMF.h"
#ifndef ESMF_NO_INTEGER_1_BYTE
#define ESMF_NO_INTEGER_1_BYTE
#endif
#ifndef ESMF_NO_INTEGER_2_BYTE
#define ESMF_NO_INTEGER_2_BYTE
#endif
!==============================================================================
!BOPI
! !MODULE: ESMF_AttributeMod - Attribute API
!
! !DESCRIPTION:
!
! The code in this file implements the Attribute defined type
! and functions. This is an
! interface to the actual C++ Attribute class implementation
! in the ../../Infrastructure/Attribute dir.
!
! See the ESMF Developers Guide document for more details.
!
!------------------------------------------------------------------------------
! !USES:
  use ESMF_BaseMod
  use ESMF_UtilTypesMod ! ESMF utility types
  use ESMF_InitMacrosMod ! ESMF initializer macros
  use ESMF_LogErrMod ! ESMF error handling
  use ESMF_ArrayMod
  use ESMF_ArrayBundleMod
  use ESMF_CompMod
  use ESMF_CplCompMod
  use ESMF_GridCompMod
  use ESMF_SciCompMod
  use ESMF_DistGridMod
  use ESMF_FieldMod
  use ESMF_FieldBundleMod
  use ESMF_GridMod
  use ESMF_LocStreamMod
  use ESMF_StateTypesMod
  use ESMF_StateVaMod
  use ESMF_StateMod
  use ESMF_UtilStringMod
  use ESMF_VMMod
  use ESMF_AttributeInternalsMod
  use ESMF_AttPackTypeMod
  implicit none
!------------------------------------------------------------------------------
! !PRIVATE TYPES:
  private
!------------------------------------------------------------------------------
! !PUBLIC MEMBER FUNCTIONS:
!
! Attribute methods
      public ESMF_AttributeGetInit
      public ESMF_AttPackStreamJSON
      public ESMF_AttributeAdd
      public ESMF_AttributeCopy
      public ESMF_AttributeGet
      public ESMF_AttributeGetAttPack
      public ESMF_AttributeLink
      public ESMF_AttributeLinkRemove
      public ESMF_AttributeSet
      public ESMF_AttributeRead
      public ESMF_AttributeRemove
      public ESMF_AttributeUpdate
      public ESMF_AttributeWrite
!------------------------------------------------------------------------------
! !PUBLIC TYPES:
!
      public ESMF_AttPack
!EOPI
!------------------------------------------------------------------------------
! leave the following line as-is; it will insert the cvs ident string
! into the object file for tracking purposes.
      character(*), parameter, private :: version = &
               '$Id$'
!------------------------------------------------------------------------------
!==============================================================================
!
! INTERFACE BLOCKS
!
!==============================================================================
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeAdd - Create Attribute packages
!
! !INTERFACE:
      interface ESMF_AttributeAdd
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttAddPackCst
        module procedure ESMF_ArrayAttAddPackCstN
        module procedure ESMF_ArrayAttAddPackCstN1
        module procedure ESMF_ArrayAttAddPackStd
        module procedure ESMF_ArrayAttAddPackCstSL
        module procedure ESMF_ArrayAttAddPackStdSL
        module procedure ESMF_ArrayBundleAttAddPackCst
        module procedure ESMF_ArrayBundleAttAddPackCstN
        module procedure ESMF_ArrayBundleAttAddPackCstN1
        module procedure ESMF_ArrayBundleAttAddPackCstSL
        module procedure ESMF_CplCompAttAddPackStd
        module procedure ESMF_CplCompAttAddPackStdN
        module procedure ESMF_CplCompAttAddPackCst
        module procedure ESMF_CplCompAttAddPackCstN
        module procedure ESMF_CplCompAttAddPackCstN1
        module procedure ESMF_CplCompAttAddPackStdSL
        !module procedure ESMF_CplCompAttAddPackStdNSL
        module procedure ESMF_CplCompAttAddPackCstSL
        module procedure ESMF_GridCompAttAddPackStd
        module procedure ESMF_GridCompAttAddPackStdN
        module procedure ESMF_GridCompAttAddPackCst
        module procedure ESMF_GridCompAttAddPackCstN
        module procedure ESMF_GridCompAttAddPackCstN1
        module procedure ESMF_GridCompAttAddPackStdSL
        !module procedure ESMF_GridCompAttAddPackStdNSL
        module procedure ESMF_GridCompAttAddPackCstSL
        module procedure ESMF_SciCompAttAddPackStd
        module procedure ESMF_SciCompAttAddPackStdN
        module procedure ESMF_SciCompAttAddPackCst
        module procedure ESMF_SciCompAttAddPackCstN
        module procedure ESMF_SciCompAttAddPackCstN1
        module procedure ESMF_SciCompAttAddPackStdSL
        !module procedure ESMF_SciCompAttAddPackStdNSL
        module procedure ESMF_SciCompAttAddPackCstSL
        module procedure ESMF_DistGridAttAddPackCst
        module procedure ESMF_DistGridAttAddPackCstN
        module procedure ESMF_DistGridAttAddPackCstN1
        module procedure ESMF_DistGridAttAddPackCstSL
        module procedure ESMF_FieldAttAddPackStd
        module procedure ESMF_FieldAttAddPackCst
        module procedure ESMF_FieldAttAddPackCstN
        module procedure ESMF_FieldAttAddPackCstN1
        module procedure ESMF_FieldAttAddPackStdSL
        module procedure ESMF_FieldAttAddPackCstSL
        module procedure ESMF_FieldBundleAttAddPackCst
        module procedure ESMF_FieldBundleAttAddPackCstN
        module procedure ESMF_FieldBundleAttAddPackCstN1
        module procedure ESMF_FieldBundleAttAddPackCstSL
        module procedure ESMF_GridAttAddPackStd
        module procedure ESMF_GridAttAddPackCst
        module procedure ESMF_GridAttAddPackCstN
        module procedure ESMF_GridAttAddPackCstN1
        module procedure ESMF_GridAttAddPackStdSL
        module procedure ESMF_GridAttAddPackCstSL
        module procedure ESMF_LocStreamAttAddPackStd
        module procedure ESMF_LocStreamAttAddPackCst
        module procedure ESMF_LocStreamAttAddPackCstN
        module procedure ESMF_LocStreamAttAddPackCstN1
        module procedure ESMF_LocStreamAttAddPackStdSL
        module procedure ESMF_LocStreamAttAddPackCstSL
        module procedure ESMF_StateAttAddPackStd
        module procedure ESMF_StateAttAddPackCst
        module procedure ESMF_StateAttAddPackCstN
        module procedure ESMF_StateAttAddPackCstN1
        module procedure ESMF_StateAttAddPackStdSL
        module procedure ESMF_StateAttAddPackCstSL
! !DESCRIPTION:
! This interface provides a single entry point for methods that create
! an Attribute package.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute or hierarchy
!
! !INTERFACE:
      interface ESMF_AttributeCopy
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_CplCompAttCopy
        module procedure ESMF_GridCompAttCopy
        module procedure ESMF_SciCompAttCopy
        module procedure ESMF_StateAttCopy
        module procedure ESMF_FieldAttCopy
        module procedure ESMF_FieldBundleAttCopy
        module procedure ESMF_GridAttCopy
! !DESCRIPTION:
! This interface provides a single entry point for methods that copy
! an Attribute or Attribute hierarchy.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeRemove
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttRemove
        module procedure ESMF_ArrayAttRemoveAP
        module procedure ESMF_ArrayBundleAttRemove
        module procedure ESMF_ArrayBundleAttRemoveAP
        module procedure ESMF_CplCompAttRemove
        module procedure ESMF_CplCompAttRemoveAP
        module procedure ESMF_GridCompAttRemove
        module procedure ESMF_GridCompAttRemoveAP
        module procedure ESMF_SciCompAttRemove
        module procedure ESMF_SciCompAttRemoveAP
        module procedure ESMF_DistGridAttRemove
        module procedure ESMF_DistGridAttRemoveAP
        module procedure ESMF_FieldAttRemove
        module procedure ESMF_FieldAttRemoveAP
        module procedure ESMF_FieldBundleAttRemove
        module procedure ESMF_FieldBundleAttRemoveAP
        module procedure ESMF_GridAttRemove
        module procedure ESMF_GridAttRemoveAP
        module procedure ESMF_LocStreamAttRemove
        module procedure ESMF_LocStreamAttRemoveAP
        module procedure ESMF_StateAttRemove
        module procedure ESMF_StateAttRemoveAP
! !DESCRIPTION:
! This interface provides a single entry point for methods that destroy
! an Attribute or Attribute package.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeGet - Get Attributes, Attribute packages, count,
! info, and type
!
! !INTERFACE:
      interface ESMF_AttributeGet
! !PRIVATE MEMBER FUNCTIONS:
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayAttGetI2 
#endif 
 module procedure ESMF_ArrayAttGetI4 
 module procedure ESMF_ArrayAttGetI8 
 module procedure ESMF_ArrayAttGetR4 
 module procedure ESMF_ArrayAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayAttGet1DI2 
#endif 
 module procedure ESMF_ArrayAttGet1DI4 
 module procedure ESMF_ArrayAttGet1DI8 
 module procedure ESMF_ArrayAttGet1DR4 
 module procedure ESMF_ArrayAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_ArrayAttGetLgcl
        module procedure ESMF_ArrayAttGetLgclList
        module procedure ESMF_ArrayAttGetChar
        module procedure ESMF_ArrayAttGetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayAttGetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayAttGetAPI2 
#endif 
 module procedure ESMF_ArrayAttGetAPI4 
 module procedure ESMF_ArrayAttGetAPI8 
 module procedure ESMF_ArrayAttGetAPR4 
 module procedure ESMF_ArrayAttGetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayAttGet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayAttGet1DAPI2 
#endif 
 module procedure ESMF_ArrayAttGet1DAPI4 
 module procedure ESMF_ArrayAttGet1DAPI8 
 module procedure ESMF_ArrayAttGet1DAPR4 
 module procedure ESMF_ArrayAttGet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_ArrayAttGetLgclAP
        module procedure ESMF_ArrayAttGetLgclListAP
        module procedure ESMF_ArrayAttGetCharAP
        module procedure ESMF_ArrayAttGetCharListAP
        module procedure ESMF_ArrayAttGetInfoByNam
        module procedure ESMF_ArrayAttGetInfoByNamAP
        module procedure ESMF_ArrayAttGetInfoByNum
        module procedure ESMF_ArrayAttGetInfoByNumAP
        module procedure ESMF_ArrayAttGetCount
        module procedure ESMF_ArrayAttGetCountAttPack
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayBundleAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayBundleAttGetI2 
#endif 
 module procedure ESMF_ArrayBundleAttGetI4 
 module procedure ESMF_ArrayBundleAttGetI8 
 module procedure ESMF_ArrayBundleAttGetR4 
 module procedure ESMF_ArrayBundleAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayBundleAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayBundleAttGet1DI2 
#endif 
 module procedure ESMF_ArrayBundleAttGet1DI4 
 module procedure ESMF_ArrayBundleAttGet1DI8 
 module procedure ESMF_ArrayBundleAttGet1DR4 
 module procedure ESMF_ArrayBundleAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_ArrayBundleAttGetLgcl
        module procedure ESMF_ArrayBundleAttGetLgclList
        module procedure ESMF_ArrayBundleAttGetChar
        module procedure ESMF_ArrayBundleAttGetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayBundleAttGetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayBundleAttGetAPI2 
#endif 
 module procedure ESMF_ArrayBundleAttGetAPI4 
 module procedure ESMF_ArrayBundleAttGetAPI8 
 module procedure ESMF_ArrayBundleAttGetAPR4 
 module procedure ESMF_ArrayBundleAttGetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayBundleAttGet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayBundleAttGet1DAPI2 
#endif 
 module procedure ESMF_ArrayBundleAttGet1DAPI4 
 module procedure ESMF_ArrayBundleAttGet1DAPI8 
 module procedure ESMF_ArrayBundleAttGet1DAPR4 
 module procedure ESMF_ArrayBundleAttGet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_ArrayBundleAttGetLgclAP
        module procedure ESMF_ArrayBundleAttGetLgclListAP
        module procedure ESMF_ArrayBundleAttGetCharAP
        module procedure ESMF_ArrayBundleAttGetCharListAP
        module procedure ESMF_ArrayBundleAttGetInfoByNam
        module procedure ESMF_ArrayBundleAttGetInfoByNamAP
        module procedure ESMF_ArrayBundleAttGetInfoByNum
        module procedure ESMF_ArrayBundleAttGetInfoByNumAP
        module procedure ESMF_ArrayBundleAttGetCount
        module procedure ESMF_ArrayBundleAttGetCountAttPack
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_CplCompAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_CplCompAttGetI2 
#endif 
 module procedure ESMF_CplCompAttGetI4 
 module procedure ESMF_CplCompAttGetI8 
 module procedure ESMF_CplCompAttGetR4 
 module procedure ESMF_CplCompAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_CplCompAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_CplCompAttGet1DI2 
#endif 
 module procedure ESMF_CplCompAttGet1DI4 
 module procedure ESMF_CplCompAttGet1DI8 
 module procedure ESMF_CplCompAttGet1DR4 
 module procedure ESMF_CplCompAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_CplCompAttGetLgcl
        module procedure ESMF_CplCompAttGetLgclList
        module procedure ESMF_CplCompAttGetChar
        module procedure ESMF_CplCompAttGetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_CplCompAttGetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_CplCompAttGetAPI2 
#endif 
 module procedure ESMF_CplCompAttGetAPI4 
 module procedure ESMF_CplCompAttGetAPI8 
 module procedure ESMF_CplCompAttGetAPR4 
 module procedure ESMF_CplCompAttGetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_CplCompAttGet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_CplCompAttGet1DAPI2 
#endif 
 module procedure ESMF_CplCompAttGet1DAPI4 
 module procedure ESMF_CplCompAttGet1DAPI8 
 module procedure ESMF_CplCompAttGet1DAPR4 
 module procedure ESMF_CplCompAttGet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_CplCompAttGetLgclAP
        module procedure ESMF_CplCompAttGetLgclListAP
        module procedure ESMF_CplCompAttGetCharAP
        module procedure ESMF_CplCompAttGetCharListAP
        module procedure ESMF_CplCompAttGetInfoByNam
        module procedure ESMF_CplCompAttGetInfoByNamAP
        module procedure ESMF_CplCompAttGetInfoByNum
        module procedure ESMF_CplCompAttGetInfoByNumAP
        module procedure ESMF_CplCompAttGetCount
        module procedure ESMF_CplCompAttGetCountAttPack
        module procedure ESMF_CplCompAttGetAPinstNames
        module procedure ESMF_CplCompAttGetAPinstNamesAP
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridCompAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridCompAttGetI2 
#endif 
 module procedure ESMF_GridCompAttGetI4 
 module procedure ESMF_GridCompAttGetI8 
 module procedure ESMF_GridCompAttGetR4 
 module procedure ESMF_GridCompAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridCompAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridCompAttGet1DI2 
#endif 
 module procedure ESMF_GridCompAttGet1DI4 
 module procedure ESMF_GridCompAttGet1DI8 
 module procedure ESMF_GridCompAttGet1DR4 
 module procedure ESMF_GridCompAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_GridCompAttGetLgcl
        module procedure ESMF_GridCompAttGetLgclList
        module procedure ESMF_GridCompAttGetChar
        module procedure ESMF_GridCompAttGetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridCompAttGetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridCompAttGetAPI2 
#endif 
 module procedure ESMF_GridCompAttGetAPI4 
 module procedure ESMF_GridCompAttGetAPI8 
 module procedure ESMF_GridCompAttGetAPR4 
 module procedure ESMF_GridCompAttGetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridCompAttGet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridCompAttGet1DAPI2 
#endif 
 module procedure ESMF_GridCompAttGet1DAPI4 
 module procedure ESMF_GridCompAttGet1DAPI8 
 module procedure ESMF_GridCompAttGet1DAPR4 
 module procedure ESMF_GridCompAttGet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_GridCompAttGetLgclAP
        module procedure ESMF_GridCompAttGetLgclListAP
        module procedure ESMF_GridCompAttGetCharAP
        module procedure ESMF_GridCompAttGetCharListAP
        module procedure ESMF_GridCompAttGetInfoByNam
        module procedure ESMF_GridCompAttGetInfoByNamAP
        module procedure ESMF_GridCompAttGetInfoByNum
        module procedure ESMF_GridCompAttGetInfoByNumAP
        module procedure ESMF_GridCompAttGetCount
        module procedure ESMF_GridCompAttGetCountAttPack
        module procedure ESMF_GridCompAttGetAPinstNames
        module procedure ESMF_GridCompAttGetAPinstNamesAP
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_SciCompAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_SciCompAttGetI2 
#endif 
 module procedure ESMF_SciCompAttGetI4 
 module procedure ESMF_SciCompAttGetI8 
 module procedure ESMF_SciCompAttGetR4 
 module procedure ESMF_SciCompAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_SciCompAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_SciCompAttGet1DI2 
#endif 
 module procedure ESMF_SciCompAttGet1DI4 
 module procedure ESMF_SciCompAttGet1DI8 
 module procedure ESMF_SciCompAttGet1DR4 
 module procedure ESMF_SciCompAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_SciCompAttGetLgcl
        module procedure ESMF_SciCompAttGetLgclList
        module procedure ESMF_SciCompAttGetChar
        module procedure ESMF_SciCompAttGetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_SciCompAttGetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_SciCompAttGetAPI2 
#endif 
 module procedure ESMF_SciCompAttGetAPI4 
 module procedure ESMF_SciCompAttGetAPI8 
 module procedure ESMF_SciCompAttGetAPR4 
 module procedure ESMF_SciCompAttGetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_SciCompAttGet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_SciCompAttGet1DAPI2 
#endif 
 module procedure ESMF_SciCompAttGet1DAPI4 
 module procedure ESMF_SciCompAttGet1DAPI8 
 module procedure ESMF_SciCompAttGet1DAPR4 
 module procedure ESMF_SciCompAttGet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_SciCompAttGetLgclAP
        module procedure ESMF_SciCompAttGetLgclListAP
        module procedure ESMF_SciCompAttGetCharAP
        module procedure ESMF_SciCompAttGetCharListAP
        module procedure ESMF_SciCompAttGetInfoByNam
        module procedure ESMF_SciCompAttGetInfoByNamAP
        module procedure ESMF_SciCompAttGetInfoByNum
        module procedure ESMF_SciCompAttGetInfoByNumAP
        module procedure ESMF_SciCompAttGetCount
        module procedure ESMF_SciCompAttGetCountAttPack
        module procedure ESMF_SciCompAttGetAPinstNames
        module procedure ESMF_SciCompAttGetAPinstNamesAP
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_DistGridAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_DistGridAttGetI2 
#endif 
 module procedure ESMF_DistGridAttGetI4 
 module procedure ESMF_DistGridAttGetI8 
 module procedure ESMF_DistGridAttGetR4 
 module procedure ESMF_DistGridAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_DistGridAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_DistGridAttGet1DI2 
#endif 
 module procedure ESMF_DistGridAttGet1DI4 
 module procedure ESMF_DistGridAttGet1DI8 
 module procedure ESMF_DistGridAttGet1DR4 
 module procedure ESMF_DistGridAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_DistGridAttGetLgcl
        module procedure ESMF_DistGridAttGetLgclList
        module procedure ESMF_DistGridAttGetChar
        module procedure ESMF_DistGridAttGetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_DistGridAttGetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_DistGridAttGetAPI2 
#endif 
 module procedure ESMF_DistGridAttGetAPI4 
 module procedure ESMF_DistGridAttGetAPI8 
 module procedure ESMF_DistGridAttGetAPR4 
 module procedure ESMF_DistGridAttGetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_DistGridAttGet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_DistGridAttGet1DAPI2 
#endif 
 module procedure ESMF_DistGridAttGet1DAPI4 
 module procedure ESMF_DistGridAttGet1DAPI8 
 module procedure ESMF_DistGridAttGet1DAPR4 
 module procedure ESMF_DistGridAttGet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_DistGridAttGetLgclAP
        module procedure ESMF_DistGridAttGetLgclListAP
        module procedure ESMF_DistGridAttGetCharAP
        module procedure ESMF_DistGridAttGetCharListAP
        module procedure ESMF_DistGridAttGetInfoByNam
        module procedure ESMF_DistGridAttGetInfoByNamAP
        module procedure ESMF_DistGridAttGetInfoByNum
        module procedure ESMF_DistGridAttGetInfoByNumAP
        module procedure ESMF_DistGridAttGetCount
        module procedure ESMF_DistGridAttGetCountAttPack
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldAttGetI2 
#endif 
 module procedure ESMF_FieldAttGetI4 
 module procedure ESMF_FieldAttGetI8 
 module procedure ESMF_FieldAttGetR4 
 module procedure ESMF_FieldAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldAttGet1DI2 
#endif 
 module procedure ESMF_FieldAttGet1DI4 
 module procedure ESMF_FieldAttGet1DI8 
 module procedure ESMF_FieldAttGet1DR4 
 module procedure ESMF_FieldAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_FieldAttGetLgcl
        module procedure ESMF_FieldAttGetLgclList
        module procedure ESMF_FieldAttGetChar
        module procedure ESMF_FieldAttGetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldAttGetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldAttGetAPI2 
#endif 
 module procedure ESMF_FieldAttGetAPI4 
 module procedure ESMF_FieldAttGetAPI8 
 module procedure ESMF_FieldAttGetAPR4 
 module procedure ESMF_FieldAttGetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldAttGet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldAttGet1DAPI2 
#endif 
 module procedure ESMF_FieldAttGet1DAPI4 
 module procedure ESMF_FieldAttGet1DAPI8 
 module procedure ESMF_FieldAttGet1DAPR4 
 module procedure ESMF_FieldAttGet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_FieldAttGetLgclAP
        module procedure ESMF_FieldAttGetLgclListAP
        module procedure ESMF_FieldAttGetCharAP
        module procedure ESMF_FieldAttGetCharListAP
        module procedure ESMF_FieldAttGetInfoByNam
        module procedure ESMF_FieldAttGetInfoByNamAP
        module procedure ESMF_FieldAttGetInfoByNum
        module procedure ESMF_FieldAttGetInfoByNumAP
        module procedure ESMF_FieldAttGetCount
        module procedure ESMF_FieldAttGetCountAttPack
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldBundleAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldBundleAttGetI2 
#endif 
 module procedure ESMF_FieldBundleAttGetI4 
 module procedure ESMF_FieldBundleAttGetI8 
 module procedure ESMF_FieldBundleAttGetR4 
 module procedure ESMF_FieldBundleAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldBundleAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldBundleAttGet1DI2 
#endif 
 module procedure ESMF_FieldBundleAttGet1DI4 
 module procedure ESMF_FieldBundleAttGet1DI8 
 module procedure ESMF_FieldBundleAttGet1DR4 
 module procedure ESMF_FieldBundleAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_FieldBundleAttGetLgcl
        module procedure ESMF_FieldBundleAttGetLgclList
        module procedure ESMF_FieldBundleAttGetChar
        module procedure ESMF_FieldBundleAttGetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldBundleAttGetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldBundleAttGetAPI2 
#endif 
 module procedure ESMF_FieldBundleAttGetAPI4 
 module procedure ESMF_FieldBundleAttGetAPI8 
 module procedure ESMF_FieldBundleAttGetAPR4 
 module procedure ESMF_FieldBundleAttGetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldBundleAttGet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldBundleAttGet1DAPI2 
#endif 
 module procedure ESMF_FieldBundleAttGet1DAPI4 
 module procedure ESMF_FieldBundleAttGet1DAPI8 
 module procedure ESMF_FieldBundleAttGet1DAPR4 
 module procedure ESMF_FieldBundleAttGet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_FieldBundleAttGetLgclAP
        module procedure ESMF_FieldBundleAttGetLgclListAP
        module procedure ESMF_FieldBundleAttGetCharAP
        module procedure ESMF_FieldBundleAttGetCharListAP
        module procedure ESMF_FieldBundleAttGetInfoByNam
        module procedure ESMF_FieldBundleAttGetInfoByNamAP
        module procedure ESMF_FieldBundleAttGetInfoByNum
        module procedure ESMF_FieldBundleAttGetInfoByNumAP
        module procedure ESMF_FieldBundleAttGetCount
        module procedure ESMF_FieldBundleAttGetCountAttPack
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridAttGetI2 
#endif 
 module procedure ESMF_GridAttGetI4 
 module procedure ESMF_GridAttGetI8 
 module procedure ESMF_GridAttGetR4 
 module procedure ESMF_GridAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridAttGet1DI2 
#endif 
 module procedure ESMF_GridAttGet1DI4 
 module procedure ESMF_GridAttGet1DI8 
 module procedure ESMF_GridAttGet1DR4 
 module procedure ESMF_GridAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_GridAttGetLgcl
        module procedure ESMF_GridAttGetLgclList
        module procedure ESMF_GridAttGetChar
        module procedure ESMF_GridAttGetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridAttGetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridAttGetAPI2 
#endif 
 module procedure ESMF_GridAttGetAPI4 
 module procedure ESMF_GridAttGetAPI8 
 module procedure ESMF_GridAttGetAPR4 
 module procedure ESMF_GridAttGetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridAttGet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridAttGet1DAPI2 
#endif 
 module procedure ESMF_GridAttGet1DAPI4 
 module procedure ESMF_GridAttGet1DAPI8 
 module procedure ESMF_GridAttGet1DAPR4 
 module procedure ESMF_GridAttGet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_GridAttGetLgclAP
        module procedure ESMF_GridAttGetLgclListAP
        module procedure ESMF_GridAttGetCharAP
        module procedure ESMF_GridAttGetCharListAP
        module procedure ESMF_GridAttGetInfoByNam
        module procedure ESMF_GridAttGetInfoByNamAP
        module procedure ESMF_GridAttGetInfoByNum
        module procedure ESMF_GridAttGetInfoByNumAP
        module procedure ESMF_GridAttGetCount
        module procedure ESMF_GridAttGetCountAttPack
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_LocStreamAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_LocStreamAttGetI2 
#endif 
 module procedure ESMF_LocStreamAttGetI4 
 module procedure ESMF_LocStreamAttGetI8 
 module procedure ESMF_LocStreamAttGetR4 
 module procedure ESMF_LocStreamAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_LocStreamAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_LocStreamAttGet1DI2 
#endif 
 module procedure ESMF_LocStreamAttGet1DI4 
 module procedure ESMF_LocStreamAttGet1DI8 
 module procedure ESMF_LocStreamAttGet1DR4 
 module procedure ESMF_LocStreamAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_LocStreamAttGetLgcl
        module procedure ESMF_LocStreamAttGetLgclList
        module procedure ESMF_LocStreamAttGetChar
        module procedure ESMF_LocStreamAttGetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_LocStreamAttGetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_LocStreamAttGetAPI2 
#endif 
 module procedure ESMF_LocStreamAttGetAPI4 
 module procedure ESMF_LocStreamAttGetAPI8 
 module procedure ESMF_LocStreamAttGetAPR4 
 module procedure ESMF_LocStreamAttGetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_LocStreamAttGet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_LocStreamAttGet1DAPI2 
#endif 
 module procedure ESMF_LocStreamAttGet1DAPI4 
 module procedure ESMF_LocStreamAttGet1DAPI8 
 module procedure ESMF_LocStreamAttGet1DAPR4 
 module procedure ESMF_LocStreamAttGet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_LocStreamAttGetLgclAP
        module procedure ESMF_LocStreamAttGetLgclListAP
        module procedure ESMF_LocStreamAttGetCharAP
        module procedure ESMF_LocStreamAttGetCharListAP
        module procedure ESMF_LocStreamAttGetInfoByNam
        module procedure ESMF_LocStreamAttGetInfoByNamAP
        module procedure ESMF_LocStreamAttGetInfoByNum
        module procedure ESMF_LocStreamAttGetInfoByNumAP
        module procedure ESMF_LocStreamAttGetCount
        module procedure ESMF_LocStreamAttGetCountAttPack
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_StateAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_StateAttGetI2 
#endif 
 module procedure ESMF_StateAttGetI4 
 module procedure ESMF_StateAttGetI8 
 module procedure ESMF_StateAttGetR4 
 module procedure ESMF_StateAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_StateAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_StateAttGet1DI2 
#endif 
 module procedure ESMF_StateAttGet1DI4 
 module procedure ESMF_StateAttGet1DI8 
 module procedure ESMF_StateAttGet1DR4 
 module procedure ESMF_StateAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_StateAttGetLgcl
        module procedure ESMF_StateAttGetLgclList
        module procedure ESMF_StateAttGetChar
        module procedure ESMF_StateAttGetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_StateAttGetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_StateAttGetAPI2 
#endif 
 module procedure ESMF_StateAttGetAPI4 
 module procedure ESMF_StateAttGetAPI8 
 module procedure ESMF_StateAttGetAPR4 
 module procedure ESMF_StateAttGetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_StateAttGet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_StateAttGet1DAPI2 
#endif 
 module procedure ESMF_StateAttGet1DAPI4 
 module procedure ESMF_StateAttGet1DAPI8 
 module procedure ESMF_StateAttGet1DAPR4 
 module procedure ESMF_StateAttGet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_StateAttGetLgclAP
        module procedure ESMF_StateAttGetLgclListAP
        module procedure ESMF_StateAttGetCharAP
        module procedure ESMF_StateAttGetCharListAP
        module procedure ESMF_StateAttGetInfoByNam
        module procedure ESMF_StateAttGetInfoByNamAP
        module procedure ESMF_StateAttGetInfoByNum
        module procedure ESMF_StateAttGetInfoByNumAP
        module procedure ESMF_StateAttGetCount
        module procedure ESMF_StateAttGetCountAttPack
! !DESCRIPTION:
! This interface provides a single entry point for methods that retrieve
! Attributes.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeGet - Get Attributes, Attribute packages, count,
! info, and type
!
! !INTERFACE:
      interface ESMF_AttributeGetAttPack
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttGetAttPack
        module procedure ESMF_ArrayBundleAttGetAttPack
        module procedure ESMF_CplCompAttGetAttPack
        module procedure ESMF_GridCompAttGetAttPack
        module procedure ESMF_SciCompAttGetAttPack
        module procedure ESMF_DistGridAttGetAttPack
        module procedure ESMF_FieldAttGetAttPack
        module procedure ESMF_FieldBundleAttGetAttPack
        module procedure ESMF_GridAttGetAttPack
        module procedure ESMF_LocStreamAttGetAttPack
        module procedure ESMF_StateAttGetAttPack
        module procedure ESMF_ArrayAttGetAttPackSL
        module procedure ESMF_ArrayBundleAttGetAttPackSL
        module procedure ESMF_CplCompAttGetAttPackSL
        module procedure ESMF_GridCompAttGetAttPackSL
        module procedure ESMF_SciCompAttGetAttPackSL
        module procedure ESMF_DistGridAttGetAttPackSL
        module procedure ESMF_FieldAttGetAttPackSL
        module procedure ESMF_FieldBundleAttGetAttPackSL
        module procedure ESMF_GridAttGetAttPackSL
        module procedure ESMF_LocStreamAttGetAttPackSL
        module procedure ESMF_StateAttGetAttPackSL
! !DESCRIPTION:
! This interface provides a single entry point for methods that retrieve
! AttPacks from Attribute bearing objects.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeLink - Link Attribute hierarchies
!
! !INTERFACE:
      interface ESMF_AttributeLink
! !PRIVATE MEMBER FUNCTIONS:
! TODO
        module procedure ESMF_ArrayBundleAttLinkArray
        module procedure ESMF_CplCompAttLinkCplComp
        module procedure ESMF_CplCompAttLinkGridComp
        module procedure ESMF_CplCompAttLinkSciComp
        module procedure ESMF_CplCompAttLinkState
        module procedure ESMF_CplCompAttLinkGrid
        module procedure ESMF_CplCompAttLinkLocStream
        module procedure ESMF_FieldBundleAttLinkField
        module procedure ESMF_FieldBundleAttLinkGrid
        module procedure ESMF_FieldBundleAttLinkLocStream
        module procedure ESMF_FieldAttLinkGrid
        module procedure ESMF_FieldAttLinkLocStream
        module procedure ESMF_GridCompAttLinkCplComp
        module procedure ESMF_GridCompAttLinkGridComp
        module procedure ESMF_GridCompAttLinkSciComp
        module procedure ESMF_GridCompAttLinkState
        module procedure ESMF_GridCompAttLinkGrid
        module procedure ESMF_GridCompAttLinkLocStream
        module procedure ESMF_SciCompAttLinkCplComp
        module procedure ESMF_SciCompAttLinkGridComp
        module procedure ESMF_SciCompAttLinkSciComp
        module procedure ESMF_SciCompAttLinkState
        module procedure ESMF_SciCompAttLinkGrid
        module procedure ESMF_SciCompAttLinkLocStream
        module procedure ESMF_StateAttLinkArrayBundle
        module procedure ESMF_StateAttLinkArray
        module procedure ESMF_StateAttLinkFieldBundle
        module procedure ESMF_StateAttLinkField
        module procedure ESMF_StateAttLinkState
! !DESCRIPTION:
! This interface provides a single entry point for methods that link
! Attribute hierarchies.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink Attribute hierarchies
!
! !INTERFACE:
      interface ESMF_AttributeLinkRemove
! !PRIVATE MEMBER FUNCTIONS:
! TODO
        module procedure ESMF_ArrayBundleAttLinkRmArray
        module procedure ESMF_CplCompAttLinkRmCplComp
        module procedure ESMF_CplCompAttLinkRmGridComp
        module procedure ESMF_CplCompAttLinkRmSciComp
        module procedure ESMF_CplCompAttLinkRmState
        module procedure ESMF_CplCompAttLinkRmGrid
        module procedure ESMF_CplCompAttLinkRmLocStream
        module procedure ESMF_FieldBundleAttLinkRmField
        module procedure ESMF_FieldBundleAttLinkRmGrid
        module procedure ESMF_FieldBundleAttLinkRmLocStream
        module procedure ESMF_FieldAttLinkRmGrid
        module procedure ESMF_FieldAttLinkRmLocStream
        module procedure ESMF_GridCompAttLinkRmCplComp
        module procedure ESMF_GridCompAttLinkRmGridComp
        module procedure ESMF_GridCompAttLinkRmSciComp
        module procedure ESMF_GridCompAttLinkRmState
        module procedure ESMF_GridCompAttLinkRmGrid
        module procedure ESMF_GridCompAttLinkRmLocStream
        module procedure ESMF_SciCompAttLinkRmCplComp
        module procedure ESMF_SciCompAttLinkRmGridComp
        module procedure ESMF_SciCompAttLinkRmSciComp
        module procedure ESMF_SciCompAttLinkRmState
        module procedure ESMF_SciCompAttLinkRmGrid
        module procedure ESMF_SciCompAttLinkRmLocStream
        module procedure ESMF_StateAttLinkRmArrayBundle
        module procedure ESMF_StateAttLinkRmArray
        module procedure ESMF_StateAttLinkRmFieldBundle
        module procedure ESMF_StateAttLinkRmField
        module procedure ESMF_StateAttLinkRmState
! !DESCRIPTION:
! This interface provides a single entry point for methods that unlink
! Attribute hierarchies.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeRead - Read an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeRead
! !PRIVATE MEMBER FUNCTIONS:
! TODO
! module procedure ESMF_ArrayAttRead
! module procedure ESMF_ArrayBundleAttRead
        module procedure ESMF_CplCompAttRead
        module procedure ESMF_GridCompAttRead
        module procedure ESMF_SciCompAttRead
! module procedure ESMF_DistGridAttRead
        module procedure ESMF_FieldAttRead
        module procedure ESMF_FieldBundleAttRead
        module procedure ESMF_GridAttRead
        module procedure ESMF_LocStreamAttRead
        module procedure ESMF_StateAttRead
! !DESCRIPTION:
! This interface provides a single entry point for methods that read
! an Attribute or Attribute package.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeSet - Set Attributes and Attribute packages
!
! !INTERFACE:
      interface ESMF_AttributeSet
! !PRIVATE MEMBER FUNCTIONS:
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayAttSetI2 
#endif 
 module procedure ESMF_ArrayAttSetI4 
 module procedure ESMF_ArrayAttSetI8 
 module procedure ESMF_ArrayAttSetR4 
 module procedure ESMF_ArrayAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayAttSet1DI2 
#endif 
 module procedure ESMF_ArrayAttSet1DI4 
 module procedure ESMF_ArrayAttSet1DI8 
 module procedure ESMF_ArrayAttSet1DR4 
 module procedure ESMF_ArrayAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_ArrayAttSetLgcl
        module procedure ESMF_ArrayAttSetLgclList
        module procedure ESMF_ArrayAttSetChar
        module procedure ESMF_ArrayAttSetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayAttSetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayAttSetAPI2 
#endif 
 module procedure ESMF_ArrayAttSetAPI4 
 module procedure ESMF_ArrayAttSetAPI8 
 module procedure ESMF_ArrayAttSetAPR4 
 module procedure ESMF_ArrayAttSetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayAttSet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayAttSet1DAPI2 
#endif 
 module procedure ESMF_ArrayAttSet1DAPI4 
 module procedure ESMF_ArrayAttSet1DAPI8 
 module procedure ESMF_ArrayAttSet1DAPR4 
 module procedure ESMF_ArrayAttSet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_ArrayAttSetLgclAP
        module procedure ESMF_ArrayAttSetLgclListAP
        module procedure ESMF_ArrayAttSetCharAP
        module procedure ESMF_ArrayAttSetCharListAP
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayBundleAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayBundleAttSetI2 
#endif 
 module procedure ESMF_ArrayBundleAttSetI4 
 module procedure ESMF_ArrayBundleAttSetI8 
 module procedure ESMF_ArrayBundleAttSetR4 
 module procedure ESMF_ArrayBundleAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayBundleAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayBundleAttSet1DI2 
#endif 
 module procedure ESMF_ArrayBundleAttSet1DI4 
 module procedure ESMF_ArrayBundleAttSet1DI8 
 module procedure ESMF_ArrayBundleAttSet1DR4 
 module procedure ESMF_ArrayBundleAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_ArrayBundleAttSetLgcl
        module procedure ESMF_ArrayBundleAttSetLgclList
        module procedure ESMF_ArrayBundleAttSetChar
        module procedure ESMF_ArrayBundleAttSetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayBundleAttSetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayBundleAttSetAPI2 
#endif 
 module procedure ESMF_ArrayBundleAttSetAPI4 
 module procedure ESMF_ArrayBundleAttSetAPI8 
 module procedure ESMF_ArrayBundleAttSetAPR4 
 module procedure ESMF_ArrayBundleAttSetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayBundleAttSet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayBundleAttSet1DAPI2 
#endif 
 module procedure ESMF_ArrayBundleAttSet1DAPI4 
 module procedure ESMF_ArrayBundleAttSet1DAPI8 
 module procedure ESMF_ArrayBundleAttSet1DAPR4 
 module procedure ESMF_ArrayBundleAttSet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_ArrayBundleAttSetLgclAP
        module procedure ESMF_ArrayBundleAttSetLgclListAP
        module procedure ESMF_ArrayBundleAttSetCharAP
        module procedure ESMF_ArrayBundleAttSetCharListAP
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_CplCompAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_CplCompAttSetI2 
#endif 
 module procedure ESMF_CplCompAttSetI4 
 module procedure ESMF_CplCompAttSetI8 
 module procedure ESMF_CplCompAttSetR4 
 module procedure ESMF_CplCompAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_CplCompAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_CplCompAttSet1DI2 
#endif 
 module procedure ESMF_CplCompAttSet1DI4 
 module procedure ESMF_CplCompAttSet1DI8 
 module procedure ESMF_CplCompAttSet1DR4 
 module procedure ESMF_CplCompAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_CplCompAttSetLgcl
        module procedure ESMF_CplCompAttSetLgclList
        module procedure ESMF_CplCompAttSetChar
        module procedure ESMF_CplCompAttSetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_CplCompAttSetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_CplCompAttSetAPI2 
#endif 
 module procedure ESMF_CplCompAttSetAPI4 
 module procedure ESMF_CplCompAttSetAPI8 
 module procedure ESMF_CplCompAttSetAPR4 
 module procedure ESMF_CplCompAttSetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_CplCompAttSet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_CplCompAttSet1DAPI2 
#endif 
 module procedure ESMF_CplCompAttSet1DAPI4 
 module procedure ESMF_CplCompAttSet1DAPI8 
 module procedure ESMF_CplCompAttSet1DAPR4 
 module procedure ESMF_CplCompAttSet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_CplCompAttSetLgclAP
        module procedure ESMF_CplCompAttSetLgclListAP
        module procedure ESMF_CplCompAttSetCharAP
        module procedure ESMF_CplCompAttSetCharListAP
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridCompAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridCompAttSetI2 
#endif 
 module procedure ESMF_GridCompAttSetI4 
 module procedure ESMF_GridCompAttSetI8 
 module procedure ESMF_GridCompAttSetR4 
 module procedure ESMF_GridCompAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridCompAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridCompAttSet1DI2 
#endif 
 module procedure ESMF_GridCompAttSet1DI4 
 module procedure ESMF_GridCompAttSet1DI8 
 module procedure ESMF_GridCompAttSet1DR4 
 module procedure ESMF_GridCompAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_GridCompAttSetLgcl
        module procedure ESMF_GridCompAttSetLgclList
        module procedure ESMF_GridCompAttSetChar
        module procedure ESMF_GridCompAttSetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridCompAttSetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridCompAttSetAPI2 
#endif 
 module procedure ESMF_GridCompAttSetAPI4 
 module procedure ESMF_GridCompAttSetAPI8 
 module procedure ESMF_GridCompAttSetAPR4 
 module procedure ESMF_GridCompAttSetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridCompAttSet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridCompAttSet1DAPI2 
#endif 
 module procedure ESMF_GridCompAttSet1DAPI4 
 module procedure ESMF_GridCompAttSet1DAPI8 
 module procedure ESMF_GridCompAttSet1DAPR4 
 module procedure ESMF_GridCompAttSet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_GridCompAttSetLgclAP
        module procedure ESMF_GridCompAttSetLgclListAP
        module procedure ESMF_GridCompAttSetCharAP
        module procedure ESMF_GridCompAttSetCharListAP
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_SciCompAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_SciCompAttSetI2 
#endif 
 module procedure ESMF_SciCompAttSetI4 
 module procedure ESMF_SciCompAttSetI8 
 module procedure ESMF_SciCompAttSetR4 
 module procedure ESMF_SciCompAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_SciCompAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_SciCompAttSet1DI2 
#endif 
 module procedure ESMF_SciCompAttSet1DI4 
 module procedure ESMF_SciCompAttSet1DI8 
 module procedure ESMF_SciCompAttSet1DR4 
 module procedure ESMF_SciCompAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_SciCompAttSetLgcl
        module procedure ESMF_SciCompAttSetLgclList
        module procedure ESMF_SciCompAttSetChar
        module procedure ESMF_SciCompAttSetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_SciCompAttSetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_SciCompAttSetAPI2 
#endif 
 module procedure ESMF_SciCompAttSetAPI4 
 module procedure ESMF_SciCompAttSetAPI8 
 module procedure ESMF_SciCompAttSetAPR4 
 module procedure ESMF_SciCompAttSetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_SciCompAttSet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_SciCompAttSet1DAPI2 
#endif 
 module procedure ESMF_SciCompAttSet1DAPI4 
 module procedure ESMF_SciCompAttSet1DAPI8 
 module procedure ESMF_SciCompAttSet1DAPR4 
 module procedure ESMF_SciCompAttSet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_SciCompAttSetLgclAP
        module procedure ESMF_SciCompAttSetLgclListAP
        module procedure ESMF_SciCompAttSetCharAP
        module procedure ESMF_SciCompAttSetCharListAP
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_DistGridAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_DistGridAttSetI2 
#endif 
 module procedure ESMF_DistGridAttSetI4 
 module procedure ESMF_DistGridAttSetI8 
 module procedure ESMF_DistGridAttSetR4 
 module procedure ESMF_DistGridAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_DistGridAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_DistGridAttSet1DI2 
#endif 
 module procedure ESMF_DistGridAttSet1DI4 
 module procedure ESMF_DistGridAttSet1DI8 
 module procedure ESMF_DistGridAttSet1DR4 
 module procedure ESMF_DistGridAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_DistGridAttSetLgcl
        module procedure ESMF_DistGridAttSetLgclList
        module procedure ESMF_DistGridAttSetChar
        module procedure ESMF_DistGridAttSetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_DistGridAttSetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_DistGridAttSetAPI2 
#endif 
 module procedure ESMF_DistGridAttSetAPI4 
 module procedure ESMF_DistGridAttSetAPI8 
 module procedure ESMF_DistGridAttSetAPR4 
 module procedure ESMF_DistGridAttSetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_DistGridAttSet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_DistGridAttSet1DAPI2 
#endif 
 module procedure ESMF_DistGridAttSet1DAPI4 
 module procedure ESMF_DistGridAttSet1DAPI8 
 module procedure ESMF_DistGridAttSet1DAPR4 
 module procedure ESMF_DistGridAttSet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_DistGridAttSetLgclAP
        module procedure ESMF_DistGridAttSetLgclListAP
        module procedure ESMF_DistGridAttSetCharAP
        module procedure ESMF_DistGridAttSetCharListAP
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldAttSetI2 
#endif 
 module procedure ESMF_FieldAttSetI4 
 module procedure ESMF_FieldAttSetI8 
 module procedure ESMF_FieldAttSetR4 
 module procedure ESMF_FieldAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldAttSet1DI2 
#endif 
 module procedure ESMF_FieldAttSet1DI4 
 module procedure ESMF_FieldAttSet1DI8 
 module procedure ESMF_FieldAttSet1DR4 
 module procedure ESMF_FieldAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_FieldAttSetLgcl
        module procedure ESMF_FieldAttSetLgclList
        module procedure ESMF_FieldAttSetChar
        module procedure ESMF_FieldAttSetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldAttSetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldAttSetAPI2 
#endif 
 module procedure ESMF_FieldAttSetAPI4 
 module procedure ESMF_FieldAttSetAPI8 
 module procedure ESMF_FieldAttSetAPR4 
 module procedure ESMF_FieldAttSetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldAttSet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldAttSet1DAPI2 
#endif 
 module procedure ESMF_FieldAttSet1DAPI4 
 module procedure ESMF_FieldAttSet1DAPI8 
 module procedure ESMF_FieldAttSet1DAPR4 
 module procedure ESMF_FieldAttSet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_FieldAttSetLgclAP
        module procedure ESMF_FieldAttSetLgclListAP
        module procedure ESMF_FieldAttSetCharAP
        module procedure ESMF_FieldAttSetCharListAP
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldBundleAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldBundleAttSetI2 
#endif 
 module procedure ESMF_FieldBundleAttSetI4 
 module procedure ESMF_FieldBundleAttSetI8 
 module procedure ESMF_FieldBundleAttSetR4 
 module procedure ESMF_FieldBundleAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldBundleAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldBundleAttSet1DI2 
#endif 
 module procedure ESMF_FieldBundleAttSet1DI4 
 module procedure ESMF_FieldBundleAttSet1DI8 
 module procedure ESMF_FieldBundleAttSet1DR4 
 module procedure ESMF_FieldBundleAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_FieldBundleAttSetLgcl
        module procedure ESMF_FieldBundleAttSetLgclList
        module procedure ESMF_FieldBundleAttSetChar
        module procedure ESMF_FieldBundleAttSetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldBundleAttSetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldBundleAttSetAPI2 
#endif 
 module procedure ESMF_FieldBundleAttSetAPI4 
 module procedure ESMF_FieldBundleAttSetAPI8 
 module procedure ESMF_FieldBundleAttSetAPR4 
 module procedure ESMF_FieldBundleAttSetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldBundleAttSet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldBundleAttSet1DAPI2 
#endif 
 module procedure ESMF_FieldBundleAttSet1DAPI4 
 module procedure ESMF_FieldBundleAttSet1DAPI8 
 module procedure ESMF_FieldBundleAttSet1DAPR4 
 module procedure ESMF_FieldBundleAttSet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_FieldBundleAttSetLgclAP
        module procedure ESMF_FieldBundleAttSetLgclListAP
        module procedure ESMF_FieldBundleAttSetCharAP
        module procedure ESMF_FieldBundleAttSetCharListAP
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridAttSetI2 
#endif 
 module procedure ESMF_GridAttSetI4 
 module procedure ESMF_GridAttSetI8 
 module procedure ESMF_GridAttSetR4 
 module procedure ESMF_GridAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridAttSet1DI2 
#endif 
 module procedure ESMF_GridAttSet1DI4 
 module procedure ESMF_GridAttSet1DI8 
 module procedure ESMF_GridAttSet1DR4 
 module procedure ESMF_GridAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_GridAttSetLgcl
        module procedure ESMF_GridAttSetLgclList
        module procedure ESMF_GridAttSetChar
        module procedure ESMF_GridAttSetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridAttSetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridAttSetAPI2 
#endif 
 module procedure ESMF_GridAttSetAPI4 
 module procedure ESMF_GridAttSetAPI8 
 module procedure ESMF_GridAttSetAPR4 
 module procedure ESMF_GridAttSetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridAttSet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridAttSet1DAPI2 
#endif 
 module procedure ESMF_GridAttSet1DAPI4 
 module procedure ESMF_GridAttSet1DAPI8 
 module procedure ESMF_GridAttSet1DAPR4 
 module procedure ESMF_GridAttSet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_GridAttSetLgclAP
        module procedure ESMF_GridAttSetLgclListAP
        module procedure ESMF_GridAttSetCharAP
        module procedure ESMF_GridAttSetCharListAP
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_LocStreamAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_LocStreamAttSetI2 
#endif 
 module procedure ESMF_LocStreamAttSetI4 
 module procedure ESMF_LocStreamAttSetI8 
 module procedure ESMF_LocStreamAttSetR4 
 module procedure ESMF_LocStreamAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_LocStreamAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_LocStreamAttSet1DI2 
#endif 
 module procedure ESMF_LocStreamAttSet1DI4 
 module procedure ESMF_LocStreamAttSet1DI8 
 module procedure ESMF_LocStreamAttSet1DR4 
 module procedure ESMF_LocStreamAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_LocStreamAttSetLgcl
        module procedure ESMF_LocStreamAttSetLgclList
        module procedure ESMF_LocStreamAttSetChar
        module procedure ESMF_LocStreamAttSetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_LocStreamAttSetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_LocStreamAttSetAPI2 
#endif 
 module procedure ESMF_LocStreamAttSetAPI4 
 module procedure ESMF_LocStreamAttSetAPI8 
 module procedure ESMF_LocStreamAttSetAPR4 
 module procedure ESMF_LocStreamAttSetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_LocStreamAttSet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_LocStreamAttSet1DAPI2 
#endif 
 module procedure ESMF_LocStreamAttSet1DAPI4 
 module procedure ESMF_LocStreamAttSet1DAPI8 
 module procedure ESMF_LocStreamAttSet1DAPR4 
 module procedure ESMF_LocStreamAttSet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_LocStreamAttSetLgclAP
        module procedure ESMF_LocStreamAttSetLgclListAP
        module procedure ESMF_LocStreamAttSetCharAP
        module procedure ESMF_LocStreamAttSetCharListAP
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_StateAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_StateAttSetI2 
#endif 
 module procedure ESMF_StateAttSetI4 
 module procedure ESMF_StateAttSetI8 
 module procedure ESMF_StateAttSetR4 
 module procedure ESMF_StateAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_StateAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_StateAttSet1DI2 
#endif 
 module procedure ESMF_StateAttSet1DI4 
 module procedure ESMF_StateAttSet1DI8 
 module procedure ESMF_StateAttSet1DR4 
 module procedure ESMF_StateAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_StateAttSetLgcl
        module procedure ESMF_StateAttSetLgclList
        module procedure ESMF_StateAttSetChar
        module procedure ESMF_StateAttSetCharList
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_StateAttSetAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_StateAttSetAPI2 
#endif 
 module procedure ESMF_StateAttSetAPI4 
 module procedure ESMF_StateAttSetAPI8 
 module procedure ESMF_StateAttSetAPR4 
 module procedure ESMF_StateAttSetAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_StateAttSet1DAPI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_StateAttSet1DAPI2 
#endif 
 module procedure ESMF_StateAttSet1DAPI4 
 module procedure ESMF_StateAttSet1DAPI8 
 module procedure ESMF_StateAttSet1DAPR4 
 module procedure ESMF_StateAttSet1DAPR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_StateAttSetLgclAP
        module procedure ESMF_StateAttSetLgclListAP
        module procedure ESMF_StateAttSetCharAP
        module procedure ESMF_StateAttSetCharListAP
! !DESCRIPTION:
! This interface provides a single entry point for methods that attach
! Attributes and Attribute packages, and link Attribute hierarchies.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeWrite
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttWrite
        module procedure ESMF_ArrayBundleAttWrite
        module procedure ESMF_CplCompAttWrite
        module procedure ESMF_GridCompAttWrite
        module procedure ESMF_SciCompAttWrite
        module procedure ESMF_DistGridAttWrite
        module procedure ESMF_FieldAttWrite
        module procedure ESMF_FieldBundleAttWrite
        module procedure ESMF_GridAttWrite
        module procedure ESMF_LocStreamAttWrite
        module procedure ESMF_StateAttWrite
! !DESCRIPTION:
! This interface provides a single entry point for methods that write
! an Attribute or Attribute package.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy
!
! !INTERFACE:
      interface ESMF_AttributeUpdate
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_CplCompAttUpdate
        module procedure ESMF_GridCompAttUpdate
        module procedure ESMF_SciCompAttUpdate
        module procedure ESMF_FieldAttUpdate
        module procedure ESMF_FieldBundleAttUpdate
        module procedure ESMF_StateAttUpdate
! !DESCRIPTION:
! This interface provides a single entry point for methods that update
! an Attribute hierarchy.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
contains
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeAdd - Add an ESMF standard Attribute package using a specification list
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeAdd()
! subroutine ESMF_AttAddPackStdSL(<object>, specList, keywordEnforcer, &
! attpack, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: specList(:)
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
! type(ESMF_AttPack), intent(inout), optional :: attpack
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Add an ESMF standard Attribute package. See Section~\ref{sec:AttPacks}
! for a description of Attribute packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_SciComp), intent(inout) :: comp
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [specList]
! A character list of values which identify the Attribute package, such as
! convention, purpose, and instancename.
! \item [{[attpack]}]
! An optional handle to the Attribute package that is to be created.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOPI
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeAdd - Add a custom Attribute package or modify an existing Attribute package using a specification list
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeAdd()
! subroutine ESMF_AttAddPackCstSL(<object>, specList, &
! attrList, keywordEnforcer, count, redundant, attpack, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: specList(:)
! character (len = *), intent(in) :: attrList(:)
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
! integer, intent(in), optional :: count
! logical, intent(in), optional :: redundant
! type(ESMF_AttPack), intent(inout), optional :: attpack
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Add a custom Attribute package to <object>, or add
! Attributes to an existing Attribute package. The {\tt redundant} flag can
! be set to {\tt .true.} to create redundant Attribute packages. Otherwise,
! Attributes will be added to an existing package. The {\tt attpack} will be
! used instead of {\tt specList} if both are present.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_SciComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [specList]
! A character list of values which identify the Attribute package,
! such as convention, purpose, and instancename.
! \item [attrList]
! The list of Attribute names to specify the custom Attribute package.
! \item [{[count]}]
! The number of Attributes to add to the custom Attribute package.
! \item [{[redundant]}]
! A flag to determine whether or not to create redundant Attribute
! packages. If an Attribute package already exists with the specified
! {\tt specList} and {\tt redundant} is set to
! {\tt .true.} then a redundant Attribute package will be created.
! The default value is {\tt .false.}.
! \item [{[attpack]}]
! The handle to the Attribute package that was created.
! This can also be used as an input parameter to indicate the
! Attribute package to which additional Attributes should be added.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOPI
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd - Add an ESMF standard Attribute package
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeAdd()
! subroutine ESMF_AttAddPackStd(<object>, convention, purpose, attpack, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: convention
! character (len = *), intent(in) :: purpose
! type(ESMF_AttPack), intent(inout), optional :: attpack
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Add an ESMF standard Attribute package. See Section~\ref{sec:AttPacks}
! for a description of Attribute packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_SciComp), intent(inout) :: comp
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [convention]
! The convention of the new Attribute package.
! \item [purpose]
! The purpose of the new Attribute package.
! \item [{[attpack]}]
! An optional handle to the Attribute package that is to be created.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd - Add an ESMF standard Attribute package containing nested standard Attribute packages
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeAdd()
! subroutine ESMF_AttAddPackStdN(<object>, convention, purpose, &
! nestConvention, nestPurpose, nestAttPackInstanceCountList, &
! nestAttPackInstanceNameList, nestCount, &
! nestAttPackInstanceNameCount, attpack, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: convention
! character (len = *), intent(in) :: purpose
! character (len = *), intent(in) :: nestConvention(:)
! character (len = *), intent(in) :: nestPurpose(:)
! integer, intent(in) :: nestAttPackInstanceCountList(:)
! character (len = *), intent(out) :: nestAttPackInstanceNameList(:)
! integer, intent(in), optional :: nestCount
! integer, intent(out), optional :: nestAttPackInstanceNameCount
! type(ESMF_AttPack), intent(inout), optional :: attpack
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Add an ESMF standard Attribute package which contains a user-specified
! number of nested standard Attribute packages. ESMF generates and returns
! default instance names for the nested Attribute packages. These names
! can be used later to distinguish among multiple nested Attribute
! packages of the same type in calls to {\tt ESMF\_AttributeGet()},
! {\tt ESMF\_AttributeSet()}, and {\tt ESMF\_AttributeRemove()}.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_SciComp), intent(inout) :: comp
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [convention]
! The convention of the new Attribute package.
! \item [purpose]
! The purpose of the new Attribute package.
! \item [nestConvention]
! The convention(s) of the standard Attribute package(s) around
! which to nest the new Attribute package.
! \item [nestPurpose]
! The purpose(s) of the standard Attribute package(s) around
! which to nest the new Attribute package.
! \item [nestAttPackInstanceCountList]
! The desired number of nested Attribute package instances for each
! nested (nestConvention, nestPurpose) package type. Note: if only one
! of each nested package type is desired, then the
! {\tt ESMF\_AttributeAdd()} overloaded method
! {\tt ESMF\_AttAddPackStd()} should be used.
! \item [nestAttPackInstanceNameList]
! The name(s) of the nested Attribute package instances, generated
! by ESMF, used to distinguish between multiple instances of the
! same convention and purpose.
! \item [{[nestCount]}]
! The count of the number of nested Attribute package types to add to
! the new Attribute package.
! \item [{[nestAttPackInstanceNameCount]}]
! The number of nested Attribute package instance names.
! \item [{[attpack]}]
! An optional handle to the Attribute package that is to be created.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd - Add a custom Attribute package or modify an existing Attribute package
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeAdd()
! subroutine ESMF_AttAddPackCst(<object>, convention, purpose, &
! attrList, count, redundant, attpack, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: convention
! character (len = *), intent(in) :: purpose
! character (len = *), intent(in) :: attrList(:)
! integer, intent(in), optional :: count
! logical, intent(in), optional :: redundant
! type(ESMF_AttPack), intent(inout), optional :: attpack
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Add a custom Attribute package to <object>, or add
! Attributes to an existing Attribute package. The {\tt redundant} flag can
! be set to {\tt .true.} to create redundant Attribute packages. Otherwise,
! Attributes will be added to an existing package. The {\tt attpack} will be
! used instead of {\tt convention} and {\tt purpose} if both are present.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_SciComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [convention]
! The convention of the Attribute package.
! \item [purpose]
! The purpose of the Attribute package.
! \item [attrList]
! The list of Attribute names to specify the custom Attribute package.
! \item [{[count]}]
! The number of Attributes to add to the custom Attribute package.
! \item [{[redundant]}]
! A flag to determine whether or not to create redundant Attribute
! packages. If an Attribute package already exists with the specified
! {\tt convention} and {\tt purpose} and {\tt redundant} is set to
! {\tt .true.} then a redundant Attribute package will be created.
! The default value is {\tt .false.}.
! \item [{[attpack]}]
! The handle to the Attribute package that was created.
! This can also be used as an input parameter to indicate the
! Attribute package to which additional Attributes should be added.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd - Add a custom Attribute package with nested Attribute packages
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeAdd()
! subroutine ESMF_AttAddPackCstN(<object>, convention, purpose, &
! attrList, count, nestConvention, nestPurpose, nestCount, attpack, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: convention
! character (len = *), intent(in) :: purpose
! character (len = *), intent(in), optional :: attrList(:)
! integer, intent(in), optional :: count
! character (len = *), intent(in) :: nestConvention(:)
! character (len = *), intent(in) :: nestPurpose(:)
! integer, intent(in), optional :: nestCount
! type(ESMF_AttPack), intent(inout), optional :: attpack
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Add a custom Attribute package, with one or more nested Attribute
! packages, to <object>. Allows for building full multiple-child Attribute
! hierarchies (multi-child trees).
! See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_SciComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [convention]
! The convention of the Attribute package.
! \item [purpose]
! The purpose of the Attribute package.
! \item [{[attrList]}]
! The list of Attribute names to specify the custom Attribute package.
! \item [{[count]}]
! The number of Attributes to add to the custom Attribute package.
! \item [nestConvention]
! The convention(s) of the Attribute package(s) around which to nest
! the new Attribute package.
! \item [nestPurpose]
! The purpose(s) of the Attribute package(s) around which to nest the
! new Attribute package.
! \item [{[nestCount]}]
! The number of nested Attribute packages to add to the custom
! Attribute package.
! \item [{[attpack]}]
! An optional handle to the Attribute package that is to be created.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd - Add a custom Attribute package with a single nested Attribute package
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeAdd()
! subroutine ESMF_AttAddPackCstN1(<object>, convention, purpose, &
! attrList, count, nestConvention, nestPurpose, attpack, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: convention
! character (len = *), intent(in) :: purpose
! character (len = *), intent(in), optional :: attrList(:)
! integer, intent(in), optional :: count
! character (len = *), intent(in) :: nestConvention
! character (len = *), intent(in) :: nestPurpose
! type(ESMF_AttPack), intent(inout), optional :: attpack
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Add a custom Attribute package, with a single nested Attribute
! package, to <object>. Allows for building single-child Attribute
! hierarchies (single-child trees).
! See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_SciComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [convention]
! The convention of the Attribute package.
! \item [purpose]
! The purpose of the Attribute package.
! \item [{[attrList]}]
! The list of Attribute names to specify the custom Attribute package.
! \item [{[count]}]
! The number of Attributes to add to the custom Attribute package.
! \item [nestConvention]
! The convention of the Attribute package around which to nest
! the new Attribute package.
! \item [nestPurpose]
! The purpose of the Attribute package around which to nest the
! new Attribute package.
! \item [{[attpack]}]
! An optional handle to the Attribute package that is to be created.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeCopy()
! subroutine ESMF_AttributeCopy(<object1>, <object2>, attcopy, rc)
!
! !ARGUMENTS:
! <object1>, see below for supported values
! <object2>, see below for supported values
! type(ESMF_AttCopy_Flag),intent(in) optional :: attcopy
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Copy an Attribute hierarchy from <object1> to <object2>. The
! default behavior is to ignore (instead of replace) values on
! pre-existing Attributes.
!
! Supported values for <object1> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(in) :: comp1
! \item type(ESMF\_GridComp), intent(in) :: comp1
! \item type(ESMF\_SciComp), intent(in) :: comp1
! \item type(ESMF\_Field), intent(inout) :: field1
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle1
! \item type(ESMF\_Grid), intent(inout) :: grid1
! \item type(ESMF\_State), intent(in) :: state
! \end{description}
!
! Supported values for <object2> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(inout) :: comp2
! \item type(ESMF\_GridComp), intent(inout) :: comp2
! \item type(ESMF\_SciComp), intent(inout) :: comp2
! \item type(ESMF\_Field), intent(inout) :: field2
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle2
! \item type(ESMF\_Grid), intent(inout) :: grid2
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! NOTE: Copies between different ESMF object types are not possible at this time.
!
! The arguments are:
! \begin{description}
! \item [<object1>]
! An {\tt Attribute}-bearing ESMF object.
! \item [<object2>]
! An {\tt Attribute}-bearing ESMF object.
! \item [{[attcopy]}]
! A flag to determine if the copy is to be by reference, value,
! or hybrid. This flag is documented in section \ref{const:attcopy}.
! The default is to copy by value.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get an Attribute from an ESMF_AttPack
!
! !INTERFACE:
! subroutine ESMF_AttributeGet(<object>, name, attpack, <value> &
! keywordEnforcer, <defaultvalue>, attnestflag, isPresent, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! type(ESMF_AttPack), intent(inout) :: attpack
! <value>, see below for supported values
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
! <defaultvalue>, see below for supported values
! type(ESMF_AttNest_Flag),intent(in), optional :: attnestflag
! logical, intent(out), optional :: isPresent
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return an Attribute {\tt value} from the <object>, or from an Attribute
! package on the <object>, specified by {\tt attpack}. Internal information can also
! be retrieved from Grid objects by prepending 'ESMF:' to the name of the
! piece of information that is requested. See
! Section~\ref{sec:InternalInfo} for more information
! on which pieces of Grid data can be retrieved through this interface.
! A {\tt defaultvalue} argument
! may be given if a return code is not desired when the Attribute is not
! found. See Section~\ref{sec:AttPacks} for a description of Attribute
! packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(in) :: array
! \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
! \item type(ESMF\_CplComp), intent(in) :: comp
! \item type(ESMF\_GridComp), intent(in) :: comp
! \item type(ESMF\_SciComp), intent(in) :: comp
! \item type(ESMF\_DistGrid), intent(in) :: distgrid
! \item type(ESMF\_Field), intent(in) :: field
! \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
! \item type(ESMF\_Grid), intent(in) :: grid
! \item type(ESMF\_State), intent(in) :: state
! \end{description}
!
! Supported values for <value> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(out) :: value
! \item integer(ESMF\_KIND\_I8), intent(out) :: value
! \item real (ESMF\_KIND\_R4), intent(out) :: value
! \item real (ESMF\_KIND\_R8), intent(out) :: value
! \item logical, intent(out) :: value
! \item character (len = *), intent(out) :: value
! \end{description}
!
! Supported values for <defaultvalue> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(in), optional :: defaultvalue
! \item integer(ESMF\_KIND\_I8), intent(in), optional :: defaultvalue
! \item real (ESMF\_KIND\_R4), intent(in), optional :: defaultvalue
! \item real (ESMF\_KIND\_R8), intent(in), optional :: defaultvalue
! \item logical, intent(in), optional :: defaultvalue
! \item character (len = *), intent(in), optional :: defaultvalue
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [name]
! The name of the Attribute to retrieve.
! \item [attpack]
! A handle to the Attribute package.
! \item [<value>]
! The value of the named Attribute.
! \item [{[<defaultvalue>]}]
! The default value of the named Attribute.
! \item [{[attnestflag]}]
! A flag to determine whether to descend the
! Attribute hierarchy when looking for this Attribute, the default
! is {\tt ESMF\_ATTNEST\_ON}. This flag is documented in section
! \ref{const:attnest}.
! \item [{[isPresent]}]
! A logical flag to tell if this Attribute is present or not.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get an Attribute pointing to internal class information from an ESMF_AttPack
!
! !INTERFACE:
! subroutine ESMF_AttributeGet(<object>, name, attpack, <value>, &
! keywordEnforcer, <defaultvalue>, inputList, attnestflag, isPresent, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! type(ESMF_AttPack), intent(inout) :: attpack
! <value>, see below for supported values
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
! <defaultvalue>, see below for supported values
! character (len = *), intent(in), optional :: inputList(:)
! type(ESMF_AttNest_Flag),intent(in), optional :: attnestflag
! logical, intent(out), optional :: isPresent
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return an Attribute {\tt value} from the <object>, or from an Attribute
! package on the <object>, specified by {\tt attpack}. Internal class information can
! be retrieved by prepending 'ESMF:' to the name of the
! piece of information that is requested. See
! Section~\ref{sec:InternalInfo} for more information
! on this capability.
! A {\tt defaultvalue} argument
! may be given if a return code is not desired when the Attribute is not
! found. See Section~\ref{sec:AttPacks} for a description of Attribute
! packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Grid), intent(in) :: grid
! \end{description}
!
! Supported values for <value> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(out) :: value
! \item character (len = *), intent(out) :: value
! \end{description}
!
! Supported values for <defaultvalue> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(in), optional :: defaultvalue
! \item character (len = *), intent(in), optional :: defaultvalue
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [name]
! The name of the Attribute to retrieve.
! \item [attpack]
! A handle to the Attribute package.
! \item [<value argument>]
! The value of the named Attribute.
! \item [{[<defaultvalue argument>]}]
! The default value of the named Attribute.
! \item [{[inputList]}]
! A list of the input parameters required to retrieve internal info.
! \item [{[attnestflag]}]
! A flag to determine whether to descend the
! Attribute hierarchy when looking for this Attribute, the default
! is {\tt ESMF\_ATTNEST\_ON}. This flag is documented in section
! \ref{const:attnest}.
! \item [{[isPresent]}]
! A logical flag to tell if this Attribute is present or not.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get an Attribute from an ESMF_AttPack
!
! !INTERFACE:
! subroutine ESMF_AttributeGet(<object>, name, attpack, <valueList>, &
! keywordEnforcer, <defaultvalueList>, attnestflag, itemCount, &
! isPresent, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! type(ESMF_AttPack), intent(inout) :: attpack
! <valueList>, see below for supported values
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
! <defaultvalueList>, see below for supported values
! type(ESMF_AttNest_Flag),intent(in), optional :: attnestflag
! integer, intent(out), optional :: itemCount
! logical, intent(out), optional :: isPresent
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return an Attribute {\tt valueList} from the <object>, or from an
! Attribute package on the <object>, specified by {\tt attpack}. Internal
! information can also be retrieved from Grid objects by prepending 'ESMF:'
! to the name of the piece of information that is requested. See
! Section~\ref{sec:InternalInfo} for more information
! on which pieces of Grid data can be retrieved through this interface.
! A {\tt defaultvalueList} list argument may be given if
! a return code is not desired when the Attribute is not found.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(in) :: array
! \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
! \item type(ESMF\_CplComp), intent(in) :: comp
! \item type(ESMF\_GridComp), intent(in) :: comp
! \item type(ESMF\_SciComp), intent(in) :: comp
! \item type(ESMF\_DistGrid), intent(in) :: distgrid
! \item type(ESMF\_Field), intent(in) :: field
! \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
! \item type(ESMF\_Grid), intent(in) :: grid
! \item type(ESMF\_State), intent(in) :: state
! \end{description}
!
! Supported values for <valueList> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(out) :: valueList(:)
! \item integer(ESMF\_KIND\_I8), intent(out) :: valueList(:)
! \item real (ESMF\_KIND\_R4), intent(out) :: valueList(:)
! \item real (ESMF\_KIND\_R8), intent(out) :: valueList(:)
! \item logical, intent(out) :: valueList(:)
! \item character (len = *), intent(out) :: valueList(:)
! \end{description}
!
! Supported values for <defaultvalueList> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(in), optional :: defaultvalueList(:)
! \item integer(ESMF\_KIND\_I8), intent(in), optional :: defaultvalueList(:)
! \item real (ESMF\_KIND\_R4), intent(in), optional :: defaultvalueList(:)
! \item real (ESMF\_KIND\_R8), intent(in), optional :: defaultvalueList(:)
! \item logical, intent(in), optional :: defaultvalueList(:)
! \item character (len = *), intent(in), optional :: defaultvalueList(:)
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [name]
! The name of the Attribute to retrieve.
! \item [attpack]
! A handle to the Attribute package.
! \item [<valueList>]
! The valueList of the named Attribute.
! \item [{[<defaultvalueList>]}]
! The default value list of the named Attribute.
! \item [{[attnestflag]}]
! A flag to determine whether to descend the
! Attribute hierarchy when looking for this Attribute, the default
! is {\tt ESMF\_ATTNEST\_ON}. This flag is documented in section
! \ref{const:attnest}.
! \item [{[itemCount]}]
! The number of items in a multi-valued Attribute.
! \item [{[isPresent]}]
! A logical flag to tell if this Attribute is present or not.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get an Attribute pointing to internal class information from an ESMF_AttPack
!
! !INTERFACE:
! subroutine ESMF_AttributeGet(<object>, name, attpack, <valueList>, &
! keywordEnforcer, <defaultvalueList>, inputList, attnestflag, &
! itemCount, isPresent, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! type(ESMF_AttPack), intent(inout) :: attpack
! <valueList>, see below for supported values
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
! <defaultvalueList>, see below for supported values
! character (len = *), intent(in), optional :: inputList(:)
! type(ESMF_AttNest_Flag),intent(in), optional :: attnestflag
! integer, intent(out), optional :: itemCount
! logical, intent(out), optional :: isPresent
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return an Attribute {\tt valueList} from the <object>, or from an
! Attribute package on the <object>, specified by {\tt attpack}. Internal class
! information can be retrieved by prepending 'ESMF:'
! to the name of the piece of information that is requested. See
! Section~\ref{sec:InternalInfo} for more information
! on this capability.
! A {\tt defaultvalueList} list argument may be given if
! a return code is not desired when the Attribute is not found.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Grid), intent(in) :: grid
! \end{description}
!
! Supported values for <valueList> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(out) :: valueList(:)
! \item real (ESMF\_KIND\_R8), intent(out) :: valueList(:)
! \item logical, intent(out) :: valueList(:)
! \end{description}
!
! Supported values for <defaultvalueList> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(in), optional :: defaultvalueList(:)
! \item real (ESMF\_KIND\_R8), intent(in), optional :: defaultvalueList(:)
! \item logical, intent(in), optional :: defaultvalueList(:)
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [name]
! The name of the Attribute to retrieve.
! \item [attpack]
! A handle to the Attribute package.
! \item [<valueList>]
! The valueList of the named Attribute.
! \item [{[<defaultvalueList>]}]
! The default value list of the named Attribute.
! \item [{[inputList]}]
! A list of the input parameters required to retrieve internal info.
! \item [{[attnestflag]}]
! A flag to determine whether to descend the
! Attribute hierarchy when looking for this Attribute, the default
! is {\tt ESMF\_ATTNEST\_ON}. This flag is documented in section
! \ref{const:attnest}.
! \item [{[itemCount]}]
! The number of items in a multi-valued Attribute.
! \item [{[isPresent]}]
! A logical flag to tell if this Attribute is present or not.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get an Attribute
!
! !INTERFACE:
! subroutine ESMF_AttributeGet(<object>, name, <value>, <defaultvalue>, &
! convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! <value>, see below for supported values
! <defaultvalue>, see below for supported values
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! character (len = *), intent(in), optional :: attPackInstanceName
! type(ESMF_AttNest_Flag),intent(in), optional :: attnestflag
! logical, intent(out), optional :: isPresent
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return an Attribute {\tt value} from the <object>, or from an Attribute
! package on the <object>, specified by {\tt convention},
! {\tt purpose}, and {\tt attPackInstanceName}. Internal information can also
! be retrieved from Grid objects by prepending 'ESMF:' to the name of the
! piece of information that is requested. See
! Section~\ref{sec:InternalInfo} for more information
! on which pieces of Grid data can be retrieved through this interface.
! A {\tt defaultvalue} argument
! may be given if a return code is not desired when the Attribute is not
! found. See Section~\ref{sec:AttPacks} for a description of Attribute
! packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(in) :: array
! \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
! \item type(ESMF\_CplComp), intent(in) :: comp
! \item type(ESMF\_GridComp), intent(in) :: comp
! \item type(ESMF\_SciComp), intent(in) :: comp
! \item type(ESMF\_DistGrid), intent(in) :: distgrid
! \item type(ESMF\_Field), intent(in) :: field
! \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
! \item type(ESMF\_Grid), intent(in) :: grid
! \item type(ESMF\_State), intent(in) :: state
! \end{description}
!
! Supported values for <value> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(out) :: value
! \item integer(ESMF\_KIND\_I8), intent(out) :: value
! \item real (ESMF\_KIND\_R4), intent(out) :: value
! \item real (ESMF\_KIND\_R8), intent(out) :: value
! \item logical, intent(out) :: value
! \item character (len = *), intent(out) :: value
! \end{description}
!
! Supported values for <defaultvalue> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(in), optional :: defaultvalue
! \item integer(ESMF\_KIND\_I8), intent(in), optional :: defaultvalue
! \item real (ESMF\_KIND\_R4), intent(in), optional :: defaultvalue
! \item real (ESMF\_KIND\_R8), intent(in), optional :: defaultvalue
! \item logical, intent(in), optional :: defaultvalue
! \item character (len = *), intent(in), optional :: defaultvalue
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [name]
! The name of the Attribute to retrieve.
! \item [<value>]
! The value of the named Attribute.
! \item [{[<defaultvalue>]}]
! The default value of the named Attribute.
! \item [{[convention]}]
! The convention of the Attribute package.
! \item [{[purpose]}]
! The purpose of the Attribute package.
! \item [{[attPackInstanceName]}]
! The name of an Attribute package instance, specifying which one
! of multiple Attribute package instances of the same convention
! and purpose, within a nest. If not specified, defaults to the
! first instance.
! \item [{[attnestflag]}]
! A flag to determine whether to descend the
! Attribute hierarchy when looking for this Attribute, the default
! is {\tt ESMF\_ATTNEST\_ON}. This flag is documented in section
! \ref{const:attnest}.
! \item [{[isPresent]}]
! A logical flag to tell if this Attribute is present or not.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get an Attribute pointing to internal class information
!
! !INTERFACE:
! subroutine ESMF_AttributeGet(<object>, name, <value>, <defaultvalue>, &
! inputList, convention, purpose, attPackInstanceName, attnestflag, &
! isPresent, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! <value>, see below for supported values
! <defaultvalue>, see below for supported values
! character (len = *), intent(in), optional :: inputList(:)
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! character (len = *), intent(in), optional :: attPackInstanceName
! type(ESMF_AttNest_Flag),intent(in), optional :: attnestflag
! logical, intent(out), optional :: isPresent
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return an Attribute {\tt value} from the <object>, or from an Attribute
! package on the <object>, specified by {\tt convention},
! {\tt purpose}, and {\tt attPackInstanceName}. Internal class information can
! be retrieved by prepending 'ESMF:' to the name of the
! piece of information that is requested. See
! Section~\ref{sec:InternalInfo} for more information
! on this capability.
! A {\tt defaultvalue} argument
! may be given if a return code is not desired when the Attribute is not
! found. See Section~\ref{sec:AttPacks} for a description of Attribute
! packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Grid), intent(in) :: grid
! \end{description}
!
! Supported values for <value> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(out) :: value
! \item character (len = *), intent(out) :: value
! \end{description}
!
! Supported values for <defaultvalue> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(in), optional :: defaultvalue
! \item character (len = *), intent(in), optional :: defaultvalue
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [name]
! The name of the Attribute to retrieve.
! \item [<value argument>]
! The value of the named Attribute.
! \item [{[<defaultvalue argument>]}]
! The default value of the named Attribute.
! \item [{[inputList]}]
! A list of the input parameters required to retrieve internal info.
! \item [{[convention]}]
! The convention of the Attribute package.
! \item [{[purpose]}]
! The purpose of the Attribute package.
! \item [{[attPackInstanceName]}]
! The name of an Attribute package instance, specifying which one
! of multiple Attribute package instances of the same convention
! and purpose, within a nest. If not specified, defaults to the
! first instance.
! \item [{[attnestflag]}]
! A flag to determine whether to descend the
! Attribute hierarchy when looking for this Attribute, the default
! is {\tt ESMF\_ATTNEST\_ON}. This flag is documented in section
! \ref{const:attnest}.
! \item [{[isPresent]}]
! A logical flag to tell if this Attribute is present or not.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get an Attribute
!
! !INTERFACE:
! subroutine ESMF_AttributeGet(<object>, name, <valueList>, &
! <defaultvalueList>, convention, purpose, attPackInstanceName, &
! attnestflag, itemCount, isPresent, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! <valueList>, see below for supported values
! <defaultvalueList>, see below for supported values
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! character (len = *), intent(in), optional :: attPackInstanceName
! type(ESMF_AttNest_Flag),intent(in), optional :: attnestflag
! integer, intent(out), optional :: itemCount
! logical, intent(out), optional :: isPresent
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return an Attribute {\tt valueList} from the <object>, or from an
! Attribute package on the <object>, specified by {\tt convention},
! {\tt purpose}, and {\tt attPackInstanceName}. Internal
! information can also be retrieved from Grid objects by prepending 'ESMF:'
! to the name of the piece of information that is requested. See
! Section~\ref{sec:InternalInfo} for more information
! on which pieces of Grid data can be retrieved through this interface.
! A {\tt defaultvalueList} list argument may be given if
! a return code is not desired when the Attribute is not found.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(in) :: array
! \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
! \item type(ESMF\_CplComp), intent(in) :: comp
! \item type(ESMF\_GridComp), intent(in) :: comp
! \item type(ESMF\_SciComp), intent(in) :: comp
! \item type(ESMF\_DistGrid), intent(in) :: distgrid
! \item type(ESMF\_Field), intent(in) :: field
! \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
! \item type(ESMF\_Grid), intent(in) :: grid
! \item type(ESMF\_State), intent(in) :: state
! \end{description}
!
! Supported values for <valueList> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(out) :: valueList(:)
! \item integer(ESMF\_KIND\_I8), intent(out) :: valueList(:)
! \item real (ESMF\_KIND\_R4), intent(out) :: valueList(:)
! \item real (ESMF\_KIND\_R8), intent(out) :: valueList(:)
! \item logical, intent(out) :: valueList(:)
! \item character (len = *), intent(out) :: valueList(:)
! \end{description}
!
! Supported values for <defaultvalueList> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(in), optional :: defaultvalueList(:)
! \item integer(ESMF\_KIND\_I8), intent(in), optional :: defaultvalueList(:)
! \item real (ESMF\_KIND\_R4), intent(in), optional :: defaultvalueList(:)
! \item real (ESMF\_KIND\_R8), intent(in), optional :: defaultvalueList(:)
! \item logical, intent(in), optional :: defaultvalueList(:)
! \item character (len = *), intent(in), optional :: defaultvalueList(:)
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [name]
! The name of the Attribute to retrieve.
! \item [<valueList>]
! The valueList of the named Attribute.
! \item [{[<defaultvalueList>]}]
! The default value list of the named Attribute.
! \item [{[convention]}]
! The convention of the Attribute package.
! \item [{[purpose]}]
! The purpose of the Attribute package.
! \item [{[attPackInstanceName]}]
! The name of an Attribute package instance, specifying which one
! of multiple Attribute package instances of the same convention
! and purpose, within a nest. If not specified, defaults to the
! first instance.
! \item [{[attnestflag]}]
! A flag to determine whether to descend the
! Attribute hierarchy when looking for this Attribute, the default
! is {\tt ESMF\_ATTNEST\_ON}. This flag is documented in section
! \ref{const:attnest}.
! \item [{[itemCount]}]
! The number of items in a multi-valued Attribute.
! \item [{[isPresent]}]
! A logical flag to tell if this Attribute is present or not.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get an Attribute pointing to internal class information
!
! !INTERFACE:
! subroutine ESMF_AttributeGet(<object>, name, <valueList>, &
! <defaultvalueList>, inputList, convention, purpose, attPackInstanceName, &
! attnestflag, itemCount, isPresent, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! <valueList>, see below for supported values
! <defaultvalueList>, see below for supported values
! character (len = *), intent(in), optional :: inputList(:)
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! character (len = *), intent(in), optional :: attPackInstanceName
! type(ESMF_AttNest_Flag),intent(in), optional :: attnestflag
! integer, intent(out), optional :: itemCount
! logical, intent(out), optional :: isPresent
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return an Attribute {\tt valueList} from the <object>, or from an
! Attribute package on the <object>, specified by {\tt convention},
! {\tt purpose}, and {\tt attPackInstanceName}. Internal class
! information can be retrieved by prepending 'ESMF:'
! to the name of the piece of information that is requested. See
! Section~\ref{sec:InternalInfo} for more information
! on this capability.
! A {\tt defaultvalueList} list argument may be given if
! a return code is not desired when the Attribute is not found.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Grid), intent(in) :: grid
! \end{description}
!
! Supported values for <valueList> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(out) :: valueList(:)
! \item real (ESMF\_KIND\_R8), intent(out) :: valueList(:)
! \item logical, intent(out) :: valueList(:)
! \end{description}
!
! Supported values for <defaultvalueList> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(in), optional :: defaultvalueList(:)
! \item real (ESMF\_KIND\_R8), intent(in), optional :: defaultvalueList(:)
! \item logical, intent(in), optional :: defaultvalueList(:)
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [name]
! The name of the Attribute to retrieve.
! \item [<valueList>]
! The valueList of the named Attribute.
! \item [{[<defaultvalueList>]}]
! The default value list of the named Attribute.
! \item [{[inputList]}]
! A list of the input parameters required to retrieve internal info.
! \item [{[convention]}]
! The convention of the Attribute package.
! \item [{[purpose]}]
! The purpose of the Attribute package.
! \item [{[attPackInstanceName]}]
! The name of an Attribute package instance, specifying which one
! of multiple Attribute package instances of the same convention
! and purpose, within a nest. If not specified, defaults to the
! first instance.
! \item [{[attnestflag]}]
! A flag to determine whether to descend the
! Attribute hierarchy when looking for this Attribute, the default
! is {\tt ESMF\_ATTNEST\_ON}. This flag is documented in section
! \ref{const:attnest}.
! \item [{[itemCount]}]
! The number of items in a multi-valued Attribute.
! \item [{[isPresent]}]
! A logical flag to tell if this Attribute is present or not.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get the Attribute count
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeGet()
! subroutine ESMF_AttributeGetCount(<object>, count, attcountflag, &
! attnestflag, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! integer, intent(out) :: count
! type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag
! type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return the Attribute count for <object>.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(in) :: array
! \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
! \item type(ESMF\_CplComp), intent(in) :: comp
! \item type(ESMF\_GridComp), intent(in) :: comp
! \item type(ESMF\_SciComp), intent(in) :: comp
! \item type(ESMF\_DistGrid), intent(in) :: distgrid
! \item type(ESMF\_Field), intent(in) :: field
! \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
! \item type(ESMF\_Grid), intent(in) :: grid
! \item type(ESMF\_State), intent(in) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [count]
! The number of all existing Attributes of the type designated in the
! {\it attcountflag}, not just Attribute that have been set.
! \item [{[attcountflag]}]
! The flag to specify which attribute count to return, the
! default is ESMF\_ATTGETCOUNT\_ATTRIBUTE. This flag is documented
! in section \ref{const:attgetcount}.
! \item [{[attnestflag]}]
! A flag to determine whether to descend the
! Attribute hierarchy when looking for this Attribute, the default
! is {\tt ESMF\_ATTNEST\_ON}. This flag is documented in section
! \ref{const:attnest}.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get Attribute info by name from an ESMF_AttPack
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeGet()
! subroutine ESMF_AttributeGetInfoByNamAP(<object>, name, attpack, &
! keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! type(ESMF_AttPack), intent(inout) :: attpack
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
! type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
! type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
! integer, intent(out), optional :: itemCount
! logical, intent(out), optional :: isPresent
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return information associated with an Attribute in an Attribute package,
! including {\tt typekind} and {\tt itemCount}.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(in) :: array
! \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
! \item type(ESMF\_CplComp), intent(in) :: comp
! \item type(ESMF\_GridComp), intent(in) :: comp
! \item type(ESMF\_SciComp), intent(in) :: comp
! \item type(ESMF\_DistGrid), intent(in) :: distgrid
! \item type(ESMF\_Field), intent(in) :: field
! \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
! \item type(ESMF\_Grid), intent(in) :: grid
! \item type(ESMF\_State), intent(in) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [name]
! The name of the Attribute to query.
! \item [attpack]
! A handle to the Attribute package.
! \item [{[attnestflag]}]
! A flag to determine whether to descend the
! Attribute hierarchy when looking for this Attribute, the default
! is {\tt ESMF\_ATTNEST\_ON}. This flag is documented in section
! \ref{const:attnest}.
! \item [{[typekind]}]
! The typekind of the Attribute. This flag is documented in section
! \ref{const:typekind}.
! \item [{[itemCount]}]
! The number of items in this Attribute.
! \item [{[isPresent]}]
! A logical flag to tell if this Attribute is present or not.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get Attribute info by name
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeGet()
! subroutine ESMF_AttributeGetInfoByNam(<object>, name, keywordEnforcer, &
! convention, purpose, attPackInstanceName, &
! attnestflag, typekind, itemCount, isPresent, rc)
!
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
! character (len=*), intent(in), optional :: convention
! character (len=*), intent(in), optional :: purpose
! character (len=*), intent(in), optional :: attPackInstanceName
! type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
! type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
! integer, intent(out), optional :: itemCount
! logical, intent(out), optional :: isPresent
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return information associated with the named Attribute,
! including {\tt typekind} and {\tt itemCount}.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(in) :: array
! \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
! \item type(ESMF\_CplComp), intent(in) :: comp
! \item type(ESMF\_GridComp), intent(in) :: comp
! \item type(ESMF\_SciComp), intent(in) :: comp
! \item type(ESMF\_DistGrid), intent(in) :: distgrid
! \item type(ESMF\_Field), intent(in) :: field
! \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
! \item type(ESMF\_Grid), intent(in) :: grid
! \item type(ESMF\_State), intent(in) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [name]
! The name of the Attribute to query.
! \item [{[convention]}]
! The convention of the Attribute package.
! \item [{[purpose]}]
! The purpose of the Attribute package.
! \item [{[attPackInstanceName]}]
! The name of an Attribute package instance, specifying which one
! of multiple Attribute package instances of the same convention
! and purpose, within a nest. If not specified, defaults to the
! first instance. (Not implemented yet)
! \item [{[attnestflag]}]
! A flag to determine whether to descend the
! Attribute hierarchy when looking for this Attribute, the default
! is {\tt ESMF\_ATTNEST\_ON}. This flag is documented in section
! \ref{const:attnest}.
! \item [{[typekind]}]
! The typekind of the Attribute. This flag is documented in section
! \ref{const:typekind}.
! \item [{[itemCount]}]
! The number of items in this Attribute.
! \item [{[isPresent]}]
! A logical flag to tell if this Attribute is present or not.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get Attribute info by index number
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeGet()
! subroutine ESMF_AttributeGetInfoByNum(<object>, attributeIndex, &
! name, attnestflag, typekind, itemcount, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! integer, intent(in) :: attributeIndex
! character (len = *), intent(out) :: name
! type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
! type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
! integer, intent(out), optional :: itemCount
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Returns information associated with the indexed Attribute,
! including {\tt name}, {\tt typekind} and {\tt itemCount}. Keep in
! mind that these indexes start from 1, as expected in a Fortran API.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(in) :: array
! \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
! \item type(ESMF\_CplComp), intent(in) :: comp
! \item type(ESMF\_GridComp), intent(in) :: comp
! \item type(ESMF\_SciComp), intent(in) :: comp
! \item type(ESMF\_DistGrid), intent(in) :: distgrid
! \item type(ESMF\_Field), intent(in) :: field
! \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
! \item type(ESMF\_Grid), intent(in) :: grid
! \item type(ESMF\_State), intent(in) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [attributeIndex]
! The index number of the Attribute to query.
! \item [name]
! The name of the Attribute.
! \item [{[attnestflag]}]
! A flag to determine whether to descend the
! Attribute hierarchy when looking for this Attribute, the default
! is {\tt ESMF\_ATTNEST\_ON}. This flag is documented in section
! \ref{const:attnest}.
! \item [{[typekind]}]
! The typekind of the Attribute. This flag is documented in section
! \ref{const:typekind}.
! \item [{[itemCount]}]
! The number of items in this Attribute.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get Attribute package instance names from an ESMF_AttPack
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeGet()
! subroutine ESMF_AttributeGetAPinstNamesAP(<object>, attpack, &
! attPackInstanceNameList, attPackInstanceNameCount, keywordEnforcer, &
! attnestflag, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! type(ESMF_AttPack), intent(inout) :: attpack
! character (len = *), intent(out) :: attPackInstanceNameList(:)
! integer, intent(out) :: attPackInstanceNameCount
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
! type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Get the Attribute package instance names of the ESMF\_AttPack.
! Also get the number of such names.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(in) :: comp
! \item type(ESMF\_GridComp), intent(in) :: comp
! \item type(ESMF\_SciComp), intent(in) :: comp
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [attpack]
! A handle to the Attribute package.
! \item [attPackInstanceNameList]
! The name(s) of the Attribute package instances of the given
! convention and purpose.
! \item [attPackInstanceNameCount]
! The number of Attribute package instance names.
! \item [{[attnestflag]}]
! A flag to determine whether to descend the
! Attribute hierarchy when searching for this Attribute package,
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented
! in section \ref{const:attnest}.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get Attribute package instance names
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeGet()
! subroutine ESMF_AttributeGetAPinstNames(<object>, convention, purpose, &
! attPackInstanceNameList, attPackInstanceNameCount, attnestflag, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in), :: convention
! character (len = *), intent(in), :: purpose
! character (len = *), intent(out) :: attPackInstanceNameList(:)
! integer, intent(out) :: attPackInstanceNameCount
! type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Get the Attribute package instance names of the specified convention
! and purpose. Also get the number of such names.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages
! and their conventions, purposes, and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(in) :: comp
! \item type(ESMF\_GridComp), intent(in) :: comp
! \item type(ESMF\_SciComp), intent(in) :: comp
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [convention]
! The convention of the Attribute package instances.
! \item [purpose]
! The purpose of the Attribute package instances.
! \item [attPackInstanceNameList]
! The name(s) of the Attribute package instances of the given
! convention and purpose.
! \item [attPackInstanceNameCount]
! The number of Attribute package instance names.
! \item [{[attnestflag]}]
! A flag to determine whether to descend the
! Attribute hierarchy when searching for this Attribute package,
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented
! in section \ref{const:attnest}.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeGetAttPack - Get an ESMF Attribute package object and/or query for presence using a specification list
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeGetAttPack()
! subroutine ESMF_AttGetAttPackSL(<object>, specList, keywordEnforcer, &
! attpack, attnestflag, isPresent, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: specList(:)
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
! type(ESMF_AttPack), intent(inout), optional :: attpack
! type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
! logical, intent(out), optional :: isPresent
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Get an ESMF Attribute package object. If there are redundant Attribute
! packages on this object then the {\it most recently created} one will be
! retrieved.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_SciComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [specList]
! A character list of values which identify the Attribute package,
! such as convention, purpose, and instancename.
! \item [{[attpack]}]
! A handle to the Attribute package.
! \item [{[attnestflag]}]
! A flag to determine whether to descend the
! Attribute hierarchy when searching for this Attribute package, the
! default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented in
! section \ref{const:attnest}.
! \item [{[isPresent]}]
! A logical flag to tell if this Attribute package is present or not.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOPI
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGetAttPack - Get an ESMF Attribute package object and/or query for presence
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeGetAttPack()
! subroutine ESMF_AttGetAttPack(<object>, convention, purpose, keywordEnforcer, &
! attPackInstanceName, attpack, attnestflag, isPresent, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: convention
! character (len = *), intent(in) :: purpose
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
! character (len = *), intent(in), optional :: attPackInstanceName
! type(ESMF_AttPack), intent(inout), optional :: attpack
! type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
! logical, intent(out), optional :: isPresent
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Get an ESMF Attribute package object. If there are redundant Attribute
! packages on this object then the {\it most recently created} one will be
! retrieved.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_SciComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [convention]
! The convention of the Attribute package.
! \item [purpose]
! The purpose of the Attribute package.
! \item [{[attPackInstanceName]}]
! The name of an Attribute package instance, specifying which one
! of multiple Attribute package instances of the same convention
! and purpose, within a nest. If not specified, defaults to the
! first instance.
! \item [{[attpack]}]
! A handle to the Attribute package.
! \item [{[attnestflag]}]
! A flag to determine whether to descend the
! Attribute hierarchy when searching for this Attribute package, the
! default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented in
! section \ref{const:attnest}.
! \item [{[isPresent]}]
! A logical flag to tell if this Attribute package is present or not.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a Component Attribute hierarchy to that of a Component or State
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLink()
! subroutine ESMF_CompAttLink(<object1>, <object2>, rc)
!
! !ARGUMENTS:
! <object1>, see below for supported values
! <object2>, see below for supported values
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Attach a {\tt CplComp}, {\tt GridComp}, or {\tt SciComp} Attribute
! hierarchy to the
! hierarchy of a {\tt CplComp}, {\tt GridComp}, {\tt SciComp}, or
! {\tt State}.
!
! Supported values for the <object1> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(inout) :: comp1
! \item type(ESMF\_GridComp), intent(inout) :: comp1
! \item type(ESMF\_SCiComp), intent(inout) :: comp1
! \end{description}
!
! Supported values for the <object2> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(in) :: comp2
! \item type(ESMF\_GridComp), intent(in) :: comp2
! \item type(ESMF\_SciComp), intent(in) :: comp2
! \item type(ESMF\_State), intent(in) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object1>]
! The \textit{parent} object in the Attribute hierarchy link.
! \item [<object2>]
! The \textit{child} object in the Attribute hierarchy link.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a State Attribute hierarchy with the hierarchy of an Array, ArrayBundle, Field, FieldBundle, or State
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLink()
! subroutine ESMF_StateAttLink(state, <object>, rc)
!
! !ARGUMENTS:
! type(ESMF_State), intent(inout) :: state
! <object>, see below for supported values
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Attach a {\tt State} Attribute hierarchy to the hierarchy of
! a {\tt Fieldbundle}, {\tt Field}, or another {\tt State}.
!
! Supported values for the <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(in) :: array
! \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
! \item type(ESMF\_Field), intent(in) :: field
! \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
! \item type(ESMF\_State), intent(in) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [state]
! An {\tt ESMF\_State} object.
! \item [<object>]
! The object with which to link hierarchies.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a FieldBundle and Field Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLink()
! subroutine ESMF_FieldBundleAttLink(fieldbundle, field, rc)
!
! !ARGUMENTS:
! type(ESMF_FieldBundle), intent(inout) :: fieldbundle
! type(ESMF_Field), intent(in) :: field
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Attach a {\tt FieldBundle} Attribute hierarchy to the hierarchy of
! a {\tt Field}.
!
! The arguments are:
! \begin{description}
! \item [fieldbundle]
! An {\tt ESMF\_FieldBundle} object.
! \item [field]
! An {\tt ESMF\_Field} object.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a Field and Grid Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLink()
! subroutine ESMF_FieldAttLink(field, grid, rc)
!
! !ARGUMENTS:
! type(ESMF_Field), intent(inout) :: field
! type(ESMF_Grid), intent(in) :: grid
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Attach a {\tt Field} Attribute hierarchy to the hierarchy of
! a {\tt Grid}.
!
! The arguments are:
! \begin{description}
! \item [field]
! An {\tt ESMF\_Field} object.
! \item [grid]
! An {\tt ESMF\_Grid} object.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link an ArrayBundle and Array Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLink()
! subroutine ESMF_ArrayBundleAttLink(arraybundle, array, rc)
!
! !ARGUMENTS:
! type(ESMF_ArrayBundle), intent(inout) :: arraybundle
! type(ESMF_Array), intent(in) :: array
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Attach an {\tt ArrayBundle} Attribute hierarchy to the hierarchy of
! an {\tt Array}.
!
! The arguments are:
! \begin{description}
! \item [arraybundle]
! An {\tt ESMF\_ArrayBundle} object.
! \item [array]
! An {\tt ESMF\_Array} object.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a Component Attribute hierarchy from that of a Component or State
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLinkRemove()
! subroutine ESMF_CompAttLinkRemove(<object1>, <object2>, rc)
!
! !ARGUMENTS:
! <object1>, see below for supported values
! <object2>, see below for supported values
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Unattach a {\tt CplComp}, {\tt GridComp}, or {\tt SciComp} Attribute
! hierarchy from the hierarchy of a {\tt CplComp}, {\tt GridComp},
! {\tt SciComp}, or {\tt State}.
!
! Supported values for the <object1> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(inout) :: comp1
! \item type(ESMF\_GridComp), intent(inout) :: comp1
! \item type(ESMF\_SciComp), intent(inout) :: comp1
! \end{description}
!
! Supported values for the <object2> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(in) :: comp2
! \item type(ESMF\_GridComp), intent(in) :: comp2
! \item type(ESMF\_SciComp), intent(in) :: comp2
! \item type(ESMF\_State), intent(in) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object1>]
! The \textit{parent} object in the Attribute hierarchy link.
! \item [<object2>]
! The \textit{child} object in the Attribute hierarchy link.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a State Attribute hierarchy from the hierarchy of an Array, ArrayBundle, Field, FieldBundle, or State
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLinkRemove()
! subroutine ESMF_StateAttLinkRemove(state, <object>, rc)
!
! !ARGUMENTS:
! type(ESMF_State), intent(inout) :: state
! <object>, see below for supported values
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Unattach a {\tt State} Attribute hierarchy from the hierarchy of
! a {\tt Fieldbundle}, {\tt Field}, or another {\tt State}.
!
! Supported values for the <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(in) :: array
! \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
! \item type(ESMF\_Field), intent(in) :: field
! \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
! \item type(ESMF\_State), intent(in) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [state]
! An {\tt ESMF\_State} object.
! \item [<object>]
! The object with which to unlink hierarchies.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a FieldBundle and Field Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLinkRemove()
! subroutine ESMF_FieldBundleAttLinkRemove(fieldbundle, field, rc)
!
! !ARGUMENTS:
! type(ESMF_FieldBundle), intent(inout) :: fieldbundle
! type(ESMF_Field), intent(in) :: field
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Unattach a {\tt FieldBundle} Attribute hierarchy from the hierarchy of
! a {\tt Field}.
!
! The arguments are:
! \begin{description}
! \item [fieldbundle]
! An {\tt ESMF\_FieldBundle} object.
! \item [field]
! An {\tt ESMF\_Field} object.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a Field and Grid Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLinkRemove()
! subroutine ESMF_FieldAttLinkRemove(field, grid, rc)
!
! !ARGUMENTS:
! type(ESMF_Field), intent(inout) :: field
! type(ESMF_Grid), intent(in) :: grid
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Unattach a {\tt Field} Attribute hierarchy from the hierarchy of
! a {\tt Grid}.
!
! The arguments are:
! \begin{description}
! \item [field]
! An {\tt ESMF\_Field} object.
! \item [grid]
! An {\tt ESMF\_Grid} object.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink an ArrayBundle and Array Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLinkRemove()
! subroutine ESMF_ArrayBundleAttLinkRemove(arraybundle, array, rc)
!
! !ARGUMENTS:
! type(ESMF_ArrayBundle), intent(inout) :: arraybundle
! type(ESMF_Array), intent(in) :: array
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Unattach an {\tt ArrayBundle} Attribute hierarchy from the hierarchy of
! an {\tt Array}.
!
! The arguments are:
! \begin{description}
! \item [arraybundle]
! An {\tt ESMF\_ArrayBundle} object.
! \item [array]
! An {\tt ESMF\_Array} object.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeRead - Read Attributes from an XML file
! \label{api:AttributeRead}
!
! !INTERFACE:
! subroutine ESMF_AttributeRead(<object>, fileName, schemaFileName, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in), optional :: fileName
! character (len = *), intent(in), optional :: schemaFileName
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Read Attributes for <object> from fileName, whose format is XML.
! schemaFileName format is XSD. If present, the schemaFileName is used to
! validate the contents of fileName. schemaFileName must be specified for
! a fileName containing custom, user-defined Attributes.
!
! Requires the third-party Xerces C++ XML Parser library to be installed,
! v3.1.0 or newer. For more details, see the "ESMF Users Guide",
! "Building and Installing the ESMF, Third Party Libraries, Xerces" and
! the website
! \newline
! "http://xerces.apache.org/xerces-c". Also please see the
! section on Attribute I/O,~\ref{io:attributeio}.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array ! not yet implemented
! \item type(ESMF\_ArrayBundle), intent(inout) :: arrayBundle ! not yet implemented
! \item type(ESMF\_CplComp), intent(inout) :: cplComp
! \item type(ESMF\_GridComp), intent(inout) :: gridComp
! \item type(ESMF\_SciComp), intent(inout) :: gridComp
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle ! not yet implemented
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_DistGrid), intent(inout) :: distGrid ! not yet implemented
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! The {\tt ESMF} object onto which the read Attributes will be placed.
! \item [{[fileName]}]
! The name of the XML file to read.
! \item [{[schemaFileName]}]
! The name of the XSD file to validate the contents of fileName.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute package using an ESMF_AttPack
!
! !INTERFACE:
! subroutine ESMF_AttributeRemove(<object>, keywordEnforcer, name, &
! attpack, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
! character (len = *), intent(in), optional :: name
! type(ESMF_AttPack), intent(inout) :: attpack
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Remove an Attribute, or Attribute package on <object>.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages
! and their conventions, purposes, and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_SciComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [{[name]}]
! The name of the Attribute to remove.
! \item [attpack]
! A handle to the Attribute package.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
! NOTE: An entire Attribute package can be removed by specifying
! {\tt attpack} only, without {\tt name}. By specifying
! {\tt attpack} an Attribute will be removed
! from the corresponding Attribute package, if it exists. An
! Attribute can be removed directly from <object> by specifying
! {\tt name}, without {\tt attpack}.
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute package
!
! !INTERFACE:
! subroutine ESMF_AttributeRemove(<object>, name, convention, purpose, &
! attPackInstanceName, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in), optional :: name
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! character (len = *), intent(in), optional :: attPackInstanceName
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Remove an Attribute, or Attribute package on <object>.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages
! and their conventions, purposes, and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_SciComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [{[name]}]
! The name of the Attribute to remove.
! \item [{[convention]}]
! The convention of the Attribute package.
! \item [{[purpose]}]
! The purpose of the Attribute package.
! \item [{[attPackInstanceName]}]
! The name of an Attribute package instance, specifying which one
! of multiple Attribute package instances of the same convention
! and purpose, within a nest. If not specified, defaults to the
! first instance.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
! NOTE: An entire Attribute package can be removed by specifying
! {\tt convention}, {\tt purpose}, and {\tt attPackInstanceName}
! only, without {\tt name}. An
! Attribute can be removed directly from <object> by specifying
! {\tt name}, without {\tt convention}, {\tt purpose}, and
! {\tt attPackInstanceName}.
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack
!
! !INTERFACE:
! subroutine ESMF_AttributeSet(<object>, name, <value>, attpack, &
! keywordEnforcer, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! <value>, see below for supported values
! type(ESMF_AttPack), intent(inout) :: attpack
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Attach an Attribute to <object>, or set an Attribute in an
! Attribute package. The Attribute has a {\tt name} and {\tt value},
! and, if in an Attribute package, a {\tt attpack}.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_SciComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! Supported values for the <value> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(in) :: value
! \item integer(ESMF\_KIND\_I8), intent(in) :: value
! \item real (ESMF\_KIND\_R4), intent(in) :: value
! \item real (ESMF\_KIND\_R8), intent(in) :: value
! \item logical, intent(in) :: value
! \item character (len = *), intent(in) :: value
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [name]
! The name of the Attribute to set.
! \item [<value argument>]
! The value of the Attribute to set.
! \item [attpack]
! A handle to the Attribute package.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Set an Attribute to point to internal class information in an ESMF_AttPack
!
! !INTERFACE:
! subroutine ESMF_AttributeSet(<object>, name, <value>, attpack, &
! keywordEnforcer, inputList, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! <value>, see below for supported values
! type(ESMF_AttPack), intent(inout) :: attpack
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
! character (len = *), intent(in), optional :: inputList(:)
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Attach an Attribute to <object>, or set an Attribute in an
! Attribute package. The Attribute has a {\tt name} and {\tt value},
! and, if in an Attribute package, a {\tt attpack}.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages.
! The Attribute can
! also be set to be a pointer to internal class information. See Section
! \ref{sec:InternalInfo} for a description of this capability.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Grid), intent(inout) :: grid
! \end{description}
!
! Supported values for the <value> are:
! \begin{description}
! \item character (len = *), intent(in), :: value
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [name]
! The name of the Attribute to set.
! \item [<value argument>]
! The value of the Attribute to set.
! \item [attpack]
! A handle to the Attribute package.
! \item [{[inputList]}]
! A list of the input parameters required to set internal info.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack
!
! !INTERFACE:
! subroutine ESMF_AttributeSet(<object>, name, <valueList>, attpack, &
! keywordEnforcer, itemCount, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! <valueList>, see below for supported values
! type(ESMF_AttPack), intent(in) :: attpack
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
! integer, intent(in), optional :: itemCount
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Attach an Attribute to <object>, or set an Attribute in an
! Attribute package. The Attribute has a {\tt name} and a
! {\tt valueList}, with an {\tt itemCount}, and, if in an Attribute
! package, a {\tt attpack}. See Section~\ref{sec:AttPacks} for a
! description of Attribute packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_SciComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! Supported values for the <valueList> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(in) :: valueList(:)
! \item integer(ESMF\_KIND\_I8), intent(in) :: valueList(:)
! \item real (ESMF\_KIND\_R4), intent(in) :: valueList(:)
! \item real (ESMF\_KIND\_R8), intent(in) :: valueList(:)
! \item logical, intent(in) :: valueList(:)
! \item character (len = *), intent(in) :: valueList(:)
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [name]
! The name of the Attribute to set.
! \item [<valueList argument>]
! The valueList of the Attribute to set.
! \item [attpack]
! A handle to the Attribute package.
! \item [{[itemCount]}]
! The number of items in a multi-valued Attribute.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Set an Attribute
!
! !INTERFACE:
! subroutine ESMF_AttributeSet(<object>, name, <value>, &
! convention, purpose, attPackInstanceName, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! <value>, see below for supported values
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! character (len = *), intent(in), optional :: attPackInstanceName
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Attach an Attribute to <object>, or set an Attribute in an
! Attribute package. The Attribute has a {\tt name} and {\tt value},
! and, if in an Attribute package, {\tt convention}, {\tt purpose}, and
! {\tt attPackInstanceName}.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_SciComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! Supported values for the <value> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(in) :: value
! \item integer(ESMF\_KIND\_I8), intent(in) :: value
! \item real (ESMF\_KIND\_R4), intent(in) :: value
! \item real (ESMF\_KIND\_R8), intent(in) :: value
! \item logical, intent(in) :: value
! \item character (len = *), intent(in) :: value
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [name]
! The name of the Attribute to set.
! \item [<value argument>]
! The value of the Attribute to set.
! \item [{[convention]}]
! The convention of the Attribute package.
! \item [{[purpose]}]
! The purpose of the Attribute package.
! \item [{[attPackInstanceName]}]
! The name of an Attribute package instance, specifying which one
! of multiple Attribute package instances of the same convention
! and purpose, within a nest. If not specified, defaults to the
! first instance. (Not implemented yet)
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Set an Attribute to point to internal class information
!
! !INTERFACE:
! subroutine ESMF_AttributeSet(<object>, name, <value>, inputList,
! convention, purpose, attPackInstanceName, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! <value>, see below for supported values
! character (len = *), intent(in), optional :: inputList(:)
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! character (len = *), intent(in), optional :: attPackInstanceName
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Attach an Attribute to <object>, or set an Attribute in an
! Attribute package. The Attribute has a {\tt name} and {\tt value},
! and, if in an Attribute package, {\tt convention}, {\tt purpose}, and
! {\tt attPackInstanceName}.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages.
! The Attribute can
! also be set to be a pointer to internal class information. See Section
! \ref{sec:InternalInfo} for a description of this capability.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Grid), intent(inout) :: grid
! \end{description}
!
! Supported values for the <value> are:
! \begin{description}
! \item character (len = *), intent(in), :: value
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [name]
! The name of the Attribute to set.
! \item [<value argument>]
! The value of the Attribute to set.
! \item [{[inputList]}]
! A list of the input parameters required to set internal info.
! \item [{[convention]}]
! The convention of the Attribute package.
! \item [{[purpose]}]
! The purpose of the Attribute package.
! \item [{[attPackInstanceName]}]
! The name of an Attribute package instance, specifying which one
! of multiple Attribute package instances of the same convention
! and purpose, within a nest. If not specified, defaults to the
! first instance. (Not implemented yet)
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Set an Attribute
!
! !INTERFACE:
! subroutine ESMF_AttributeSet(<object>, name, <valueList>, &
! convention, purpose, attPackInstanceName, itemCount, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! <valueList>, see below for supported values
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! character (len = *), intent(in), optional :: attPackInstanceName
! integer, intent(in), optional :: itemCount
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Attach an Attribute to <object>, or set an Attribute in an
! Attribute package. The Attribute has a {\tt name} and a
! {\tt valueList}, with an {\tt itemCount}, and, if in an Attribute
! package, {\tt convention}, {\tt purpose}, and {\tt attPackInstanceName}.
! See Section~\ref{sec:AttPacks} for a
! description of Attribute packages.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_SciComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! Supported values for the <valueList> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(in) :: valueList(:)
! \item integer(ESMF\_KIND\_I8), intent(in) :: valueList(:)
! \item real (ESMF\_KIND\_R4), intent(in) :: valueList(:)
! \item real (ESMF\_KIND\_R8), intent(in) :: valueList(:)
! \item logical, intent(in) :: valueList(:)
! \item character (len = *), intent(in) :: valueList(:)
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [name]
! The name of the Attribute to set.
! \item [<valueList argument>]
! The valueList of the Attribute to set.
! \item [{[convention]}]
! The convention of the Attribute package.
! \item [{[purpose]}]
! The purpose of the Attribute package.
! \item [{[attPackInstanceName]}]
! The name of an Attribute package instance, specifying which one
! of multiple Attribute package instances of the same convention
! and purpose, within a nest. If not specified, defaults to the
! first instance. (Not implemented yet)
! \item [{[itemCount]}]
! The number of items in a multi-valued Attribute.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy
!
! !INTERFACE:
! subroutine ESMF_AttributeUpdate(<object>, vm, rootList, reconcile, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! type(ESMF_VM), intent(in) :: vm
! integer, intent(in) :: rootList(:)
! logical, intent(in), optional :: reconcile
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Update an Attribute hierarchy during runtime. The information from
! the PETs in the {\tt rootList} is transferred to the PETs that are not
! in the {\tt rootList}. Care should be taken to ensure that the
! information contained in the Attributes on the PETs in the {\tt rootList}
! is consistent.
! If changes have been made to the underlying object hierarchy then either
! {\tt ESMF\_StateReconcile()} or the {\tt reconcile} flag must be used to
! resolve them. The same applies if changes are made to both PETs and in
! the {\tt rootList} and PETs outside of the {\tt rootList}, or if the same
! changes are made in a different order.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_SciComp), intent(inout) :: comp
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [vm]
! The virtual machine over which this Attribute hierarchy
! should be updated.
! \item [rootList]
! The list of PETs that are to be used as the source of the update.
! \item [{[reconcile]}] 
! A logical flag used to indicate whether to use reconcile behavior 
! or normal update behavior. If {\tt reconcile} is set to 
! {\tt .true.} then the values of the root PETs will be sent to 
! the nonroot PETs without exception. Otherwise, an algorithm that 
! is optimized to use minimal memory will be used to update only 
! the modified parts of the Attribute hierarchy on the nonroot 
! PETs. The default value is {\tt .false.}. 
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package
! \label{api:AttributeWrite}
!
! !INTERFACE:
! subroutine ESMF_AttributeWrite(<object>, convention, purpose, &
! attwriteflag, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Write the Attribute package for <object>. The Attribute package defines
! the convention, purpose, and object type of the associated Attributes. Either
! tab-delimited or xml format is achieved by using {\tt attwriteflag}.
! Currently, only ESMF/ESG/CF Field Attribute packages can be written in
! tab-delimited format. See Section~\ref{sec:AttPacks} for a description
! of Attribute packages and their conventions, purposes, and object types.
!
! This call is collective across the current VM.
!
! Writing Attribute XML files is performed with the standard C++ output
! file stream facility.
!
! Note: For an object type of {\tt ESMF\_GridComp}, convention='WaterML',
! purpose='TimeSeries', and
! \newline
! attwriteflag=ESMF\_ATTWRITE\_XML, an XML file
! conforming to a hydrologic standard called WaterML will be written. See
! the following for more information:
!
! \begin{description}
! \item{"http://his.cuahsi.org/wofws.html"}
! \item{"http://www.earthsystemcurator.org/projects/waterml.shtml"}
! \end{description}
!
! An ESMF Use Test Case is available which showcases an example of how
! to write a WaterML file; please see
!
! \begin{description}
! \item{"http://esmf.cvs.sourceforge.net/viewvc/esmf/use\_test\_cases/ESMF\_WaterML"}
! \item{"http://esmf.cvs.sourceforge.net/viewvc/esmf/use\_test\_cases/README"}
! \end{description}
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(in) :: array
! \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
! \item type(ESMF\_CplComp), intent(in) :: comp
! \item type(ESMF\_GridComp), intent(in) :: comp
! \item type(ESMF\_SciComp), intent(in) :: comp
! \item type(ESMF\_DistGrid), intent(in) :: distgrid
! \item type(ESMF\_Field), intent(in) :: field
! \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
! \item type(ESMF\_Grid), intent(in) :: grid
! \item type(ESMF\_State), intent(in) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object.
! \item [{[convention]}]
! The convention of the Attribute package.
! \item [{[purpose]}]
! The purpose of the Attribute package.
! \item [{[attwriteflag]}]
! The flag to specify which format is desired for the write, the
! default is ESMF\_ATTWRITE\_TAB. This flag is documented in
! section \ref{const:attwrite}.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!EOP
!------------------------------------------------------------------------------
!-----------------------------------------------------------------------------
#undef ESMF_METHOD
#define ESMF_METHOD "AttPackStreamJSON"
!BOPI
! !IROUTINE: ESMF_AttPackStreamJSON - Stream AttPack to JSON formatted string.
!
! !INTERFACE:
      subroutine ESMF_AttPackStreamJSON(attpack, flattenPackList, includeUnset, &
        includeLinks, output, rc)
      type(ESMF_AttPack), intent(in) :: attpack
      logical, intent(in) :: flattenPackList
      logical, intent(in) :: includeUnset
      logical, intent(in) :: includeLinks
      character(len=*), intent(out) :: output
      integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Streams an Attpack into a JSON formatted string.
!
! The arguments are:
! \begin{description}
! \item [attpack]
! The Attribute package to stream.
! \item [flattenPackList]
! Whether to flatten nested attribute packages into a single list
! \item [includeUnset]
! Whether to include unset attributes
! \item [output]
! The character string output variable.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!
!EOPI
      integer :: localrc, errflag, jsonstrlen
      integer :: localFlattenPackList, localIncludeUnset, localIncludeLinks
      if (flattenPackList) then
        localFlattenPackList = 1
      else
        localFlattenPackList = 0
      endif
      if (includeUnset) then
        localIncludeUnset = 1
      else
        localIncludeUnset = 0
      endif
      if (includeLinks) then
        localIncludeLinks = 1
      else
        localIncludeLinks = 0
      endif
      ! Initialize
      localrc = ESMF_RC_NOT_IMPL
      ! Use an inquiry function to find the length of the string needed
      ! for the JSON string. This will be used to allocate the Fortran string,
      ! the user will be responsible for deallocating it.
      call C_ESMC_AttPackStreamJSONstrlen(attpack, localFlattenPackList, localIncludeUnset, &
        localIncludeLinks, jsonstrlen, localrc)
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
              ESMF_CONTEXT, rcToReturn=rc)) return
      errflag = merge (ESMF_SUCCESS, ESMF_RC_BUFFER_SHORT, jsonstrlen <= len (output))
      if (ESMF_LogFoundError(errflag, msg='JSON output string too short', &
              ESMF_CONTEXT, rcToReturn=rc)) return
      ! call the C++ function to stream JSON to the output string
      call C_ESMC_AttPackStreamJSON(attpack, localFlattenPackList, localIncludeUnset, &
        localIncludeLinks, output, localrc)
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
              ESMF_CONTEXT, rcToReturn=rc)) return
      if (present(rc)) rc = ESMF_SUCCESS
      end subroutine ESMF_AttPackStreamJSON
!------------------------------------------------------------------------------
!-------------------------------------------------------------------------
! Macro versions of the routines
!-------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-------------------------------------------------------------------------
! CplComp
!-------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, keywordEnforcer, attPackInstanceName, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object.
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, count 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="comp" 
 type(ESMF_AttPack) :: lattpack 
 character(len=max(len(convention), len(purpose))), dimension(3) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 count = 3 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! guard against a situation which cannot be prevented with the use of optional arguments 
 if (present(attpackInstanceName)) then 
 if (len(attpackInstanceName) > max(len(convention), len(purpose))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="TODO: initialize the specList with length dependent on attpackInstanceName", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 if (present(attpackInstanceName)) then 
 specList(3) = trim(attpackInstanceName) 
 count = 4 
 else 
 specList(3) = "" 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackGet(comp%compp%base, lattpack, & 
 count, specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetAttPack 
!------------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPackSL" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_CplCompAttGetAttPackSL(comp, & 
 specList, keywordEnforcer, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="comp" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if (size(specList) > 4) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackGet(comp%compp%base, lattpack, & 
 size(lens), specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetAttPackSL 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStd" 
 
!BOPI 
! !IROUTINE: AttAddPackStd - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_CplCompAttAddPackStd(comp, convention, purpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j ! Error status 
 character (len=*), parameter :: object="comp" 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (.not.((convention.eq."ESG" .and.purpose.eq."General").or. & 
 (convention.eq."ESMF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."Extended").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."grids").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."grids").or. & 
 (convention.eq."CIM 1.5".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.5".and.purpose.eq."Inputs").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."Inputs").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."Inputs"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute package convention and purpose values", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackCreateStandard(comp%compp%base, & 
 size(lens), specString, lens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_CplCompAttGetAttPackSL(comp, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStdN" 
 
!BOPI 
! !IROUTINE: AttAddPackStdN - Add an ESMF standard Attribute package with nested standard Attribute packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_CplCompAttAddPackStdN(comp, convention, purpose, & 
 nestConvention, nestPurpose, nestAttPackInstanceCountList, & 
 nestAttPackInstanceNameList, nestCount, & 
 nestAttPackInstanceNameCount, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, dimension(:), intent(in) :: nestAttPackInstanceCountList 
 character (len = *), dimension(:), intent(out) :: nestAttPackInstanceNameList 
 integer, intent(in), optional :: nestCount 
 integer, intent(out), optional :: nestAttPackInstanceNameCount 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package which contains a user-specified 
! number of nested standard Attribute packages. ESMF generates and 
! returns default instance names for the nested Attribute packages. 
! These names can be used later to distinguish among multiple nested 
! Attribute packages of the same type in calls to 
! {\tt ESMF\_AttributeGet()}, {\tt ESMF\_AttributeSet()}, and 
! {\tt ESMF\_AttributeRemove()}. See Section~\ref{sec:AttPacks} for a 
! description of Attribute packages and their conventions, purposes, 
! and object types. 
! 
! Add an ESMF standard Attribute package which contains a user-specified 
! number of nested standard Attribute packages. The user specifies the 
! names of the nested Attribute package instances (not yet implemented), 
! or ESMF generates and returns default instance names. These names can 
! be used later to distinguish among multiple nested Attribute packages 
! of the same type in calls to {\tt ESMF\_AttributeGet()}, 
! {\tt ESMF\_AttributeSet()}, and {\tt ESMF\_AttributeRemove()}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attpack] 
! The Attribute package to be created. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [nestConvention] 
! The convention(s) of the standard Attribute package type(s) around 
! which to nest the new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the standard Attribute package type(s) around 
! which to nest the new Attribute package. 
! \item [nestAttPackInstanceCountList] 
! The desired number of nested Attribute package instances for each 
! nested (nestConvention, nestPurpose) package type. Note: if only one 
! of each nested package type is desired, then the 
! {\tt ESMF\_AttributeAdd()} overloaded method 
! {\tt ESMF\_AttAddPackStd()} should be used. 
! \item [nestAttPackInstanceNameList] 
! The name(s) of the nested Attribute package instances, generated 
! by ESMF, used to distinguish between multiple instances of the 
! same convention and purpose. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute package types to add to 
! the new Attribute package. 
! \item [{[nestAttPackInstanceNameCount]}] 
! The number of nested Attribute package instance names. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k 
 integer :: localNestCount, localNestAPinstNameSize, totalInstances 
 integer :: localNestAPinstNameCount 
 character(len=*), parameter :: object="comp" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 
 integer, dimension(size(nestAttPackInstanceNameList)) :: nestAPinstNameLens 
 character(len=(size(nestAttPackInstanceNameList)*len(nestAttPackInstanceNameList))) :: nestAPinstNameString 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 ! TODO: check if (convention, purpose) is standard attpack type 
 ! if so, then check if (nestConvention, nestPurpose) are standard 
 ! children of the parent 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (size(nestAttPackInstanceCountList).ne.size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestAttPackInstanceCountList and nestConvention must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! pack conv,purp strings and lengths, add up instances 
 j = 1 
 k = 1 
 totalInstances = 0 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 totalInstances = totalInstances + nestAttPackInstanceCountList(i) 
 enddo 
 
 if (totalInstances.gt.size(nestAttPackInstanceNameList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="size(nestAttPackInstanceNameList) not big enough for the number of instances specified in nestAttPackInstanceCountList", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! pack widths of NameList elements 
 ! TODO: pack actual lengths (len_trim) when implementing name input 
 localNestAPinstNameSize = size(nestAttPackInstanceNameList) 
 do i=1,localNestAPinstNameSize 
 nestAPinstNameLens(i) = len(nestAttPackInstanceNameList(i)) 
 enddo 
 
 call c_ESMC_AttPackCreateStdNest(comp%compp%base, convention, & 
 purpose, object, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, nestAttPackInstanceCountList, & 
 localNestCount, & 
 nestAPinstNameString, nestAPinstNameLens, localNestAPinstNameSize, & 
 localNestAPinstNameCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! unpack returned attpack instance names 
 j = 1 
 do i=1,localNestAPinstNameCount 
 nestAttPackInstanceNameList(i) = & 
 nestAPinstNameString(j:(j+nestAPinstNameLens(i)-1)) 
 j = j + nestAPinstNameLens(i) 
 enddo 
 
 ! return number of attpack instance names 
 if (present(nestAttPackInstanceNameCount)) then 
 nestAttPackInstanceNameCount = localNestAPinstNameCount 
 endif 
 
 if ( present(attpack) ) then 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! retrieve the optional attribute package handle 
 call ESMF_CplCompAttGetAttPackSL(comp, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttAddPackStdN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_CplCompAttAddPackCst(comp, convention, purpose, attrList, & 
 count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt convention} and {\tt purpose} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 type(ESMF_AttPack) :: lattpack 
 logical :: lispresent, lredundant 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 call ESMF_CplCompAttAddPackCstSL(comp, specList, attrList, & 
 count=localcount, redundant=lredundant, & 
 attpack=lattpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_CplCompAttAddPackCstN(comp, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="comp" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(comp%compp%base, size(lens), specString, lens, & 
 localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(comp%compp%base, attrList(i), & 
 size(lens), specString, lens, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_CplCompAttGetAttPackSL(comp, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_CplCompAttAddPackCstN1(comp, convention, purpose, attrList, & 
 count, nestConvention, nestPurpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribvute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_CplCompAttAddPackCstN(comp, & 
 convention, purpose, & 
 attrList, count, & 
 nestConvString, nestPurpString, & 
 nestCount=1, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttAddPackCstN1
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStdSL" 
 
!BOPI 
! !IROUTINE: AttAddPackStdSL - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_CplCompAttAddPackStdSL(comp, specList, keywordEnforcer, & 
 attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j ! Error status 
 character (len=*), parameter :: object="comp" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (.not.((specList(1).eq."ESG" .and.specList(2).eq."General").or. & 
 (specList(1).eq."ESMF" .and.specList(2).eq."General").or. & 
 (specList(1).eq."CF" .and.specList(2).eq."General").or. & 
 (specList(1).eq."CF" .and.specList(2).eq."Extended").or. & 
 (specList(1).eq."CIM 1.5.1".and.specList(2).eq."grids").or. & 
 (specList(1).eq."CIM 1.7.1".and.specList(2).eq."grids").or. & 
 (specList(1).eq."CIM 1.5" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.5.1" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.7.1" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.5" .and.specList(2).eq."Inputs").or. & 
 (specList(1).eq."CIM 1.5.1" .and.specList(2).eq."Inputs").or. & 
 (specList(1).eq."CIM 1.7.1" .and.specList(2).eq."Inputs"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute packages", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 ! create the attribute package 
 call c_ESMC_AttPackCreateStandard(comp%compp%base, & 
 size(lens), specString, lens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! retrieve the optional attribute package handle 
 if (present(attpack)) then 
 
 call ESMF_CplCompAttGetAttPackSL(comp, specList, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttAddPackStdSL
!AttAddPackStandardNMacroSL(ESMF_CplComp, comp, comp%compp%base)
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstSL" 
!BOPI 
! !IROUTINE: AttAddPackCstSL - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_CplCompAttAddPackCstSL(comp, specList, attrList, & 
 keywordEnforcer, count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), dimension(:), intent(in) :: specList 
 character (len = *), dimension(:), intent(in) :: attrList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! convention, purpose, and instancename. 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt specList} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack}]] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=*), parameter :: object="comp" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 logical :: attpackpresent, lredundant 
 logical :: lispresent, createnewattpack, addtoattpack 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 lispresent = .false. 
 createnewattpack = .false. 
 addtoattpack = .false. 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 ! verify that the count and number of attribute names are reasonable 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if ( lredundant .eqv. .true. ) then 
 createnewattpack = .true. 
 else 
 call ESMF_CplCompAttGetAttPackSL(comp, specList, attpack=lattpack, & 
 isPresent=lispresent, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lispresent .eqv. .false.) then 
 createnewattpack = .true. 
 else 
 addtoattpack = .true. 
 endif 
 endif 
 
 if ( createnewattpack .eqv. .true. ) then 
 call c_ESMC_AttPackCreateCustom(comp%compp%base, & 
 size(lens), specString, lens, & 
 lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 else if ( addtoattpack .eqv. .true. ) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 endif 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttAddPackCstSL
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttributeCopy" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy between objects 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeCopy() 
 subroutine ESMF_CplCompAttCopy(comp1, comp2, attcopy, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(in) :: comp1 
 type(ESMF_CplComp), intent(inout) :: comp2 
 type(ESMF_AttCopy_Flag), intent(in), optional :: attcopy 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Copy all Attributes in one hierarchy to another. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_CplComp} object. 
! \item [comp2] 
! An {\tt ESMF_CplComp} object. 
! \item [attcopyflag] 
! A flag to determine if the copy is to be by reference, value, or hybrid 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 
 character(ESMF_MAXSTR) :: value 
 integer, dimension(1) :: lens 
 type(ESMF_AttCopy_Flag) :: localattcopy 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc) 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc) 
 
 ! set copy flag default 
 localattcopy = ESMF_ATTCOPY_VALUE 
 if (present(attcopy)) then 
 localattcopy = attcopy 
 endif 
 
 call c_ESMC_AttributeCopy(comp1%compp%base, comp2%compp%base, & 
 localattcopy, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttCopy 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetAPI1(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetI1(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetI1 
!------------------------------------------------------------------------------ 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetAPI2(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetI2(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetI2 
!------------------------------------------------------------------------------ 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetAPI4(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetI4(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetI4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetAPI8(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetI8(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetI8 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetAPR4(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetR4(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetR4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetAPR8(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetR8(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetR8 
!------------------------------------------------------------------------------ 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DAPI1(comp, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I1, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DAPI1 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DI1(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I1, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DAPI2(comp, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I2, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DAPI2 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DI2(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I2, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DAPI4(comp, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DAPI4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DI4(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DAPI8(comp, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DAPI8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DI8(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DAPR4(comp, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DAPR4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DR4(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DAPR8(comp, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DAPR8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DR8(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetLgclAP(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, localvalue 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetLgcl(comp, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetLgclListAP(comp, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetLgclList(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetCharAP(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len = *), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_CplCompAttGetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetChar(comp, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, & 
 lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_CplCompAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetCharListAP(comp, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len=*), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetCharList(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetCount(comp, count, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(in) :: comp 
 integer, intent(out) :: count 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given Attribute 
! package in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_Logical) :: isAttpack 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, & 
 attPackInstanceName=attPackInstanceName, & 
 attpack=attpack, attnestflag=lattnestflag, & 
 rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, & 
 lattcountflag, lattnestflag, & 
 localrc) 
 else 
 call c_ESMC_AttributeGetCount(comp%compp%base, count, lattcountflag, & 
 localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetCount 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCountAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetCountAttPack(comp, attpack, count, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(in) :: comp 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, lattcountflag, & 
 lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetCountAttPack 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetInfoByNamAP(comp, name, attpack, & 
 keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(in) :: comp 
 character(len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(comp%compp%base, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetInfoByNamAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetInfoByNam(comp, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(in) :: comp 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}.
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(comp%compp%base, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNumAP" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetInfoByNumAP(comp, attributeIndex, attpack, & 
 name, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(in) :: comp 
 integer, intent(in) :: attributeIndex 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character(len=*), intent(out) :: name 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentIndex(comp%compp%base, attributeIndex, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(comp%compp%base, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetInfoByNumAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetInfoByNum(comp, attributeIndex, name, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(in) :: comp 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentIndex(comp%compp%base, attributeIndex, & 
 attpack, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(comp%compp%base, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresentIndex(comp%compp%base, attributeIndex, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoNum(comp%compp%base, attributeIndex, & 
 localName, localTk, & 
 litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetInfoByNum 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAPinstNamesAP" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a list of AttPack instance names using an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetAPinstNamesAP(comp, attpack, & 
 attPackInstanceNameList, attPackInstanceNameCount, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(in) :: comp 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len = *), dimension(:), intent(out) :: attPackInstanceNameList 
 integer, intent(out) :: attPackInstanceNameCount 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Get the Attribute package instance names of the specified 
! ESMF\_AttPack. Also get the number of such names. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [attPackInstanceNameList] 
! The name(s) of the Attribute package instances of the given 
! convention and purpose. 
! \item [attPackInstanceNameCount] 
! The number of Attribute package instance names. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, APinstNameSize 
 integer, dimension(size(attPackInstanceNameList)) :: APinstNameLens 
 character(len=(size(attPackInstanceNameList)*len(attPackInstanceNameList))) :: APinstNameString 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! pack widths of NameList elements 
 APinstNameSize = size(attPackInstanceNameList) 
 do i=1,APinstNameSize 
 APinstNameLens(i) = len(attPackInstanceNameList(i)) 
 enddo 
 
 call c_ESMC_AttPackGetAPinstNames(comp%compp%base, attpack, & 
 APinstNameString, APinstNameLens, APinstNameSize, & 
 attPackInstanceNameCount, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! unpack returned attpack instance names 
 j = 1 
 do i=1,attPackInstanceNameCount 
 attPackInstanceNameList(i) = & 
 APinstNameString(j:(j+APinstNameLens(i)-1)) 
 j = j + APinstNameLens(i) 
 enddo 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetAPinstNamesAP 
 
!--------------------------------------------------------------------------- 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAPinstNames" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a list of AttPack instance names 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetAPinstNames(comp, convention, purpose, & 
 attPackInstanceNameList, attPackInstanceNameCount, & 
 attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(out) :: attPackInstanceNameList 
 integer, intent(out) :: attPackInstanceNameCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Get the Attribute package instance names of the specified convention 
! and purpose. Also get the number of such names. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the Attribute package instances. 
! \item [purpose] 
! The purpose of the Attribute package instances. 
! \item [attPackInstanceNameList] 
! The name(s) of the Attribute package instances of the given 
! convention and purpose. 
! \item [attPackInstanceNameCount] 
! The number of Attribute package instance names. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, APinstNameSize 
 integer, dimension(size(attPackInstanceNameList)) :: APinstNameLens 
 character(len=(size(attPackInstanceNameList)*len(attPackInstanceNameList))) :: APinstNameString 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! pack widths of NameList elements 
 APinstNameSize = size(attPackInstanceNameList) 
 do i=1,APinstNameSize 
 APinstNameLens(i) = len(attPackInstanceNameList(i)) 
 enddo 
 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, & 
 attpack=attpack, attnestflag=lattnestflag, & 
 rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackGetAPinstNames(comp%compp%base, attpack, & 
 APinstNameString, APinstNameLens, APinstNameSize, & 
 attPackInstanceNameCount, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! unpack returned attpack instance names 
 j = 1 
 do i=1,attPackInstanceNameCount 
 attPackInstanceNameList(i) = & 
 APinstNameString(j:(j+APinstNameLens(i)-1)) 
 j = j + APinstNameLens(i) 
 enddo 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetAPinstNames 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_CplCompAttLinkCplComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp1 
 type(ESMF_CplComp), intent(in) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_CplComp} object. 
! \item [comp2] 
! An {\tt ESMF_CplComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkCplComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_CplCompAttLinkGridComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp1 
 type(ESMF_GridComp), intent(in) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_CplComp} object. 
! \item [comp2] 
! An {\tt ESMF_GridComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkGridComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_CplCompAttLinkSciComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp1 
 type(ESMF_SciComp), intent(in) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_CplComp} object. 
! \item [comp2] 
! An {\tt ESMF_SciComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkSciComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_CplCompAttLinkState(comp, state, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 type(ESMF_State), intent(in) :: state 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [state] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp%compp%base, state%statep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_CplCompAttLinkGrid(comp, grid, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 type(ESMF_Grid), intent(in) :: grid 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp%compp%base, grid, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkGrid 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_CplCompAttLinkLocStream(comp, locStream, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 type(ESMF_LocStream), intent(in) :: locStream 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [locStream] 
! An {\tt ESMF_LocStream} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locStream,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp%compp%base, locStream, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkLocStream 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_CplCompAttLinkRmCplComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp1 
 type(ESMF_CplComp), intent(in) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_CplComp} object. 
! \item [comp2] 
! An {\tt ESMF_CplComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkRmCplComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_CplCompAttLinkRmGridComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp1 
 type(ESMF_GridComp), intent(in) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_CplComp} object. 
! \item [comp2] 
! An {\tt ESMF_GridComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkRmGridComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_CplCompAttLinkRmSciComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp1 
 type(ESMF_SciComp), intent(in) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_CplComp} object. 
! \item [comp2] 
! An {\tt ESMF_SciComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkRmSciComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_CplCompAttLinkRmState(comp, state, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 type(ESMF_State), intent(in) :: state 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [state] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp%compp%base, state%statep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkRmState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_CplCompAttLinkRmGrid(comp, grid, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 type(ESMF_Grid), intent(in) :: grid 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp%compp%base, grid, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkRmGrid 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_CplCompAttLinkRmLocStream(comp, locStream, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 type(ESMF_LocStream), intent(in) :: locStream 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [locStream] 
! An {\tt ESMF_LocStream} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locStream,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp%compp%base, locStream, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkRmLocStream 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_CplCompAttRead(comp, fileName, schemaFileName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len=*), intent(in), optional :: fileName 
 character (len=*), intent(in), optional :: schemaFileName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt comp}. 
! The Attribute package defines the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [{[fileName]}] 
! The file name to read from. 
! \item [{[schemaFileName]}] 
! The name of the XSD file to validate fileName. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, schemaFileNameLen, localrc 
 
 fileNameLen = 0 
 schemaFileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 ! get length of given fileNames for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 if (present(schemaFileName)) then 
 schemaFileNameLen = len_trim(schemaFileName) 
 end if 
 
 ! invoke C to C++ entry point 
 call c_ESMC_AttributeRead(comp%compp%base, fileNameLen, fileName, & 
 schemaFileNameLen, schemaFileName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttRead 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package using an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_CplCompAttRemoveAP(comp, keywordEnforcer, name, & 
 attpack, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(comp%compp%base, name, attpack, & 
 lattnestflag, localrc) 
 else 
 call c_ESMC_AttPackRemove(comp%compp%base, attpack, localrc) 
 ESMF_INIT_SET_DELETED(attpack) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttRemoveAP 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_CplCompAttRemove(comp, name, convention, purpose, & 
 attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpackobj 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemove(comp%compp%base, attpackobj, lattnestflag, localrc) 
 ESMF_INIT_SET_DELETED(attpackobj) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemoveAttribute(comp%compp%base, name, attpackobj, & 
 lattnestflag, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(comp%compp%base, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetAPI1(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetAPI1 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetI1(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DAPI1(comp, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DI1(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetAPI2(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetAPI2 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetI2(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DAPI2(comp, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DI2(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetAPI4(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetAPI4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetI4(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DAPI4(comp, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DI4(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetAPI8(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetAPI8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetI8(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DAPI8(comp, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DI8(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetAPR4(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetAPR4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetR4(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DAPR4(comp, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DR4(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetAPR8(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetAPR8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetR8(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DAPR8(comp, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DR8(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetLgclAP(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 localvalue = value 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetLgcl(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented, 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetLgclListAP(comp, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetLgclList(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetCharAP(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 lens(1) = len_trim(value) 
 count = 1 
 
 call c_ESMC_AttPackSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetChar(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetCharListAP(comp, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetCharList(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_CplCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_CplCompAttUpdate(comp, vm, rootList, reconcile, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 logical, intent(in), optional :: reconcile 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [vm] 
! The virtual machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of PETs that are to be used to as the source of the update. 
! \item [{[reconcile]}] 
! A logical flag used to indicate whether to use reconcile behavior or 
! normal update behavior. If {\tt reconcile} is set to {\tt ESMF\_TRUE} 
! then the values of the root PETs will be sent to the nonroot PETs without 
! exception. Otherwise, an algorithm that is optimized to use minimal 
! memory will be used to update only the modified parts of the Attribute 
! hierarchy on the nonroot PETs. The default value is {\tt ESMF\_FALSE}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 type(ESMF_Logical) :: local_reconcile 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 ! reconcile 
 if ( present(reconcile)) then 
 local_reconcile = reconcile 
 else 
 local_reconcile = ESMF_FALSE 
 endif 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(comp%compp%base, vm, rootList, count, & 
 local_reconcile, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_CplCompAttWrite(comp, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(in) :: comp 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! This call is collective across the current VM. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, petCount, localPet 
 character(len=*), parameter :: object="comp" 
 character(len=*), parameter :: ftarobj="field" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 type(ESMF_VM) :: vm 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 call ESMF_VMGetCurrent(vm, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localPet == 0) then 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttributeWrite(comp%compp%base, convention, & 
 purpose, object, ftarobj, writeflag, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 call ESMF_VMBarrier(vm, rc=rc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttWrite 

!-------------------------------------------------------------------------
! GridComp
!-------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, keywordEnforcer, attPackInstanceName, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object.
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, count 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="comp" 
 type(ESMF_AttPack) :: lattpack 
 character(len=max(len(convention), len(purpose))), dimension(3) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 count = 3 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! guard against a situation which cannot be prevented with the use of optional arguments 
 if (present(attpackInstanceName)) then 
 if (len(attpackInstanceName) > max(len(convention), len(purpose))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="TODO: initialize the specList with length dependent on attpackInstanceName", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 if (present(attpackInstanceName)) then 
 specList(3) = trim(attpackInstanceName) 
 count = 4 
 else 
 specList(3) = "" 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackGet(comp%compp%base, lattpack, & 
 count, specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetAttPack 
!------------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPackSL" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_GridCompAttGetAttPackSL(comp, & 
 specList, keywordEnforcer, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="comp" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if (size(specList) > 4) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackGet(comp%compp%base, lattpack, & 
 size(lens), specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetAttPackSL 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStd" 
 
!BOPI 
! !IROUTINE: AttAddPackStd - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridCompAttAddPackStd(comp, convention, purpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j ! Error status 
 character (len=*), parameter :: object="comp" 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (.not.((convention.eq."ESG" .and.purpose.eq."General").or. & 
 (convention.eq."ESMF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."Extended").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."grids").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."grids").or. & 
 (convention.eq."CIM 1.5".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.5".and.purpose.eq."Inputs").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."Inputs").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."Inputs"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute package convention and purpose values", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackCreateStandard(comp%compp%base, & 
 size(lens), specString, lens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_GridCompAttGetAttPackSL(comp, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStdN" 
 
!BOPI 
! !IROUTINE: AttAddPackStdN - Add an ESMF standard Attribute package with nested standard Attribute packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridCompAttAddPackStdN(comp, convention, purpose, & 
 nestConvention, nestPurpose, nestAttPackInstanceCountList, & 
 nestAttPackInstanceNameList, nestCount, & 
 nestAttPackInstanceNameCount, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, dimension(:), intent(in) :: nestAttPackInstanceCountList 
 character (len = *), dimension(:), intent(out) :: nestAttPackInstanceNameList 
 integer, intent(in), optional :: nestCount 
 integer, intent(out), optional :: nestAttPackInstanceNameCount 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package which contains a user-specified 
! number of nested standard Attribute packages. ESMF generates and 
! returns default instance names for the nested Attribute packages. 
! These names can be used later to distinguish among multiple nested 
! Attribute packages of the same type in calls to 
! {\tt ESMF\_AttributeGet()}, {\tt ESMF\_AttributeSet()}, and 
! {\tt ESMF\_AttributeRemove()}. See Section~\ref{sec:AttPacks} for a 
! description of Attribute packages and their conventions, purposes, 
! and object types. 
! 
! Add an ESMF standard Attribute package which contains a user-specified 
! number of nested standard Attribute packages. The user specifies the 
! names of the nested Attribute package instances (not yet implemented), 
! or ESMF generates and returns default instance names. These names can 
! be used later to distinguish among multiple nested Attribute packages 
! of the same type in calls to {\tt ESMF\_AttributeGet()}, 
! {\tt ESMF\_AttributeSet()}, and {\tt ESMF\_AttributeRemove()}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attpack] 
! The Attribute package to be created. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [nestConvention] 
! The convention(s) of the standard Attribute package type(s) around 
! which to nest the new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the standard Attribute package type(s) around 
! which to nest the new Attribute package. 
! \item [nestAttPackInstanceCountList] 
! The desired number of nested Attribute package instances for each 
! nested (nestConvention, nestPurpose) package type. Note: if only one 
! of each nested package type is desired, then the 
! {\tt ESMF\_AttributeAdd()} overloaded method 
! {\tt ESMF\_AttAddPackStd()} should be used. 
! \item [nestAttPackInstanceNameList] 
! The name(s) of the nested Attribute package instances, generated 
! by ESMF, used to distinguish between multiple instances of the 
! same convention and purpose. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute package types to add to 
! the new Attribute package. 
! \item [{[nestAttPackInstanceNameCount]}] 
! The number of nested Attribute package instance names. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k 
 integer :: localNestCount, localNestAPinstNameSize, totalInstances 
 integer :: localNestAPinstNameCount 
 character(len=*), parameter :: object="comp" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 
 integer, dimension(size(nestAttPackInstanceNameList)) :: nestAPinstNameLens 
 character(len=(size(nestAttPackInstanceNameList)*len(nestAttPackInstanceNameList))) :: nestAPinstNameString 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 ! TODO: check if (convention, purpose) is standard attpack type 
 ! if so, then check if (nestConvention, nestPurpose) are standard 
 ! children of the parent 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (size(nestAttPackInstanceCountList).ne.size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestAttPackInstanceCountList and nestConvention must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! pack conv,purp strings and lengths, add up instances 
 j = 1 
 k = 1 
 totalInstances = 0 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 totalInstances = totalInstances + nestAttPackInstanceCountList(i) 
 enddo 
 
 if (totalInstances.gt.size(nestAttPackInstanceNameList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="size(nestAttPackInstanceNameList) not big enough for the number of instances specified in nestAttPackInstanceCountList", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! pack widths of NameList elements 
 ! TODO: pack actual lengths (len_trim) when implementing name input 
 localNestAPinstNameSize = size(nestAttPackInstanceNameList) 
 do i=1,localNestAPinstNameSize 
 nestAPinstNameLens(i) = len(nestAttPackInstanceNameList(i)) 
 enddo 
 
 call c_ESMC_AttPackCreateStdNest(comp%compp%base, convention, & 
 purpose, object, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, nestAttPackInstanceCountList, & 
 localNestCount, & 
 nestAPinstNameString, nestAPinstNameLens, localNestAPinstNameSize, & 
 localNestAPinstNameCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! unpack returned attpack instance names 
 j = 1 
 do i=1,localNestAPinstNameCount 
 nestAttPackInstanceNameList(i) = & 
 nestAPinstNameString(j:(j+nestAPinstNameLens(i)-1)) 
 j = j + nestAPinstNameLens(i) 
 enddo 
 
 ! return number of attpack instance names 
 if (present(nestAttPackInstanceNameCount)) then 
 nestAttPackInstanceNameCount = localNestAPinstNameCount 
 endif 
 
 if ( present(attpack) ) then 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! retrieve the optional attribute package handle 
 call ESMF_GridCompAttGetAttPackSL(comp, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttAddPackStdN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridCompAttAddPackCst(comp, convention, purpose, attrList, & 
 count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt convention} and {\tt purpose} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 type(ESMF_AttPack) :: lattpack 
 logical :: lispresent, lredundant 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 call ESMF_GridCompAttAddPackCstSL(comp, specList, attrList, & 
 count=localcount, redundant=lredundant, & 
 attpack=lattpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridCompAttAddPackCstN(comp, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="comp" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(comp%compp%base, size(lens), specString, lens, & 
 localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(comp%compp%base, attrList(i), & 
 size(lens), specString, lens, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_GridCompAttGetAttPackSL(comp, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridCompAttAddPackCstN1(comp, convention, purpose, attrList, & 
 count, nestConvention, nestPurpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribvute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_GridCompAttAddPackCstN(comp, & 
 convention, purpose, & 
 attrList, count, & 
 nestConvString, nestPurpString, & 
 nestCount=1, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttAddPackCstN1
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStdSL" 
 
!BOPI 
! !IROUTINE: AttAddPackStdSL - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridCompAttAddPackStdSL(comp, specList, keywordEnforcer, & 
 attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j ! Error status 
 character (len=*), parameter :: object="comp" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (.not.((specList(1).eq."ESG" .and.specList(2).eq."General").or. & 
 (specList(1).eq."ESMF" .and.specList(2).eq."General").or. & 
 (specList(1).eq."CF" .and.specList(2).eq."General").or. & 
 (specList(1).eq."CF" .and.specList(2).eq."Extended").or. & 
 (specList(1).eq."CIM 1.5.1".and.specList(2).eq."grids").or. & 
 (specList(1).eq."CIM 1.7.1".and.specList(2).eq."grids").or. & 
 (specList(1).eq."CIM 1.5" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.5.1" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.7.1" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.5" .and.specList(2).eq."Inputs").or. & 
 (specList(1).eq."CIM 1.5.1" .and.specList(2).eq."Inputs").or. & 
 (specList(1).eq."CIM 1.7.1" .and.specList(2).eq."Inputs"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute packages", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 ! create the attribute package 
 call c_ESMC_AttPackCreateStandard(comp%compp%base, & 
 size(lens), specString, lens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! retrieve the optional attribute package handle 
 if (present(attpack)) then 
 
 call ESMF_GridCompAttGetAttPackSL(comp, specList, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttAddPackStdSL
!AttAddPackStandardNMacroSL(ESMF_GridComp, comp, comp%compp%base)
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstSL" 
!BOPI 
! !IROUTINE: AttAddPackCstSL - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridCompAttAddPackCstSL(comp, specList, attrList, & 
 keywordEnforcer, count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), dimension(:), intent(in) :: specList 
 character (len = *), dimension(:), intent(in) :: attrList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! convention, purpose, and instancename. 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt specList} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack}]] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=*), parameter :: object="comp" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 logical :: attpackpresent, lredundant 
 logical :: lispresent, createnewattpack, addtoattpack 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 lispresent = .false. 
 createnewattpack = .false. 
 addtoattpack = .false. 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 ! verify that the count and number of attribute names are reasonable 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if ( lredundant .eqv. .true. ) then 
 createnewattpack = .true. 
 else 
 call ESMF_GridCompAttGetAttPackSL(comp, specList, attpack=lattpack, & 
 isPresent=lispresent, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lispresent .eqv. .false.) then 
 createnewattpack = .true. 
 else 
 addtoattpack = .true. 
 endif 
 endif 
 
 if ( createnewattpack .eqv. .true. ) then 
 call c_ESMC_AttPackCreateCustom(comp%compp%base, & 
 size(lens), specString, lens, & 
 lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 else if ( addtoattpack .eqv. .true. ) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 endif 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttAddPackCstSL
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttributeCopy" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy between objects 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeCopy() 
 subroutine ESMF_GridCompAttCopy(comp1, comp2, attcopy, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(in) :: comp1 
 type(ESMF_GridComp), intent(inout) :: comp2 
 type(ESMF_AttCopy_Flag), intent(in), optional :: attcopy 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Copy all Attributes in one hierarchy to another. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_GridComp} object. 
! \item [comp2] 
! An {\tt ESMF_GridComp} object. 
! \item [attcopyflag] 
! A flag to determine if the copy is to be by reference, value, or hybrid 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 
 character(ESMF_MAXSTR) :: value 
 integer, dimension(1) :: lens 
 type(ESMF_AttCopy_Flag) :: localattcopy 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc) 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc) 
 
 ! set copy flag default 
 localattcopy = ESMF_ATTCOPY_VALUE 
 if (present(attcopy)) then 
 localattcopy = attcopy 
 endif 
 
 call c_ESMC_AttributeCopy(comp1%compp%base, comp2%compp%base, & 
 localattcopy, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttCopy 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package using an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_GridCompAttRemoveAP(comp, keywordEnforcer, name, & 
 attpack, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(comp%compp%base, name, attpack, & 
 lattnestflag, localrc) 
 else 
 call c_ESMC_AttPackRemove(comp%compp%base, attpack, localrc) 
 ESMF_INIT_SET_DELETED(attpack) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttRemoveAP 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_GridCompAttRemove(comp, name, convention, purpose, & 
 attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpackobj 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemove(comp%compp%base, attpackobj, lattnestflag, localrc) 
 ESMF_INIT_SET_DELETED(attpackobj) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemoveAttribute(comp%compp%base, name, attpackobj, & 
 lattnestflag, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(comp%compp%base, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetAPI1(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetI1(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetI1 
!------------------------------------------------------------------------------ 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetAPI2(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetI2(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetI2 
!------------------------------------------------------------------------------ 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetAPI4(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetI4(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetI4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetAPI8(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetI8(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetI8 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetAPR4(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetR4(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetR4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetAPR8(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetR8(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetR8 
!------------------------------------------------------------------------------ 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DAPI1(comp, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I1, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DAPI1 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DI1(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I1, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DAPI2(comp, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I2, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DAPI2 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DI2(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I2, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DAPI4(comp, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DAPI4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DI4(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DAPI8(comp, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DAPI8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DI8(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DAPR4(comp, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DAPR4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DR4(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DAPR8(comp, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DAPR8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DR8(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetLgclAP(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, localvalue 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetLgcl(comp, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetLgclListAP(comp, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetLgclList(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetCharAP(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len = *), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_GridCompAttGetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetChar(comp, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, & 
 lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_GridCompAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetCharListAP(comp, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len=*), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetCharList(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetCount(comp, count, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(in) :: comp 
 integer, intent(out) :: count 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given Attribute 
! package in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_Logical) :: isAttpack 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, & 
 attPackInstanceName=attPackInstanceName, & 
 attpack=attpack, attnestflag=lattnestflag, & 
 rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, & 
 lattcountflag, lattnestflag, & 
 localrc) 
 else 
 call c_ESMC_AttributeGetCount(comp%compp%base, count, lattcountflag, & 
 localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetCount 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCountAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetCountAttPack(comp, attpack, count, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(in) :: comp 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, lattcountflag, & 
 lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetCountAttPack 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetInfoByNamAP(comp, name, attpack, & 
 keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(in) :: comp 
 character(len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(comp%compp%base, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetInfoByNamAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetInfoByNam(comp, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(in) :: comp 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}.
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(comp%compp%base, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNumAP" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetInfoByNumAP(comp, attributeIndex, attpack, & 
 name, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(in) :: comp 
 integer, intent(in) :: attributeIndex 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character(len=*), intent(out) :: name 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentIndex(comp%compp%base, attributeIndex, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(comp%compp%base, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetInfoByNumAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetInfoByNum(comp, attributeIndex, name, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(in) :: comp 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentIndex(comp%compp%base, attributeIndex, & 
 attpack, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(comp%compp%base, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresentIndex(comp%compp%base, attributeIndex, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoNum(comp%compp%base, attributeIndex, & 
 localName, localTk, & 
 litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetInfoByNum 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAPinstNamesAP" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a list of AttPack instance names using an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetAPinstNamesAP(comp, attpack, & 
 attPackInstanceNameList, attPackInstanceNameCount, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(in) :: comp 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len = *), dimension(:), intent(out) :: attPackInstanceNameList 
 integer, intent(out) :: attPackInstanceNameCount 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Get the Attribute package instance names of the specified 
! ESMF\_AttPack. Also get the number of such names. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [attPackInstanceNameList] 
! The name(s) of the Attribute package instances of the given 
! convention and purpose. 
! \item [attPackInstanceNameCount] 
! The number of Attribute package instance names. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, APinstNameSize 
 integer, dimension(size(attPackInstanceNameList)) :: APinstNameLens 
 character(len=(size(attPackInstanceNameList)*len(attPackInstanceNameList))) :: APinstNameString 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! pack widths of NameList elements 
 APinstNameSize = size(attPackInstanceNameList) 
 do i=1,APinstNameSize 
 APinstNameLens(i) = len(attPackInstanceNameList(i)) 
 enddo 
 
 call c_ESMC_AttPackGetAPinstNames(comp%compp%base, attpack, & 
 APinstNameString, APinstNameLens, APinstNameSize, & 
 attPackInstanceNameCount, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! unpack returned attpack instance names 
 j = 1 
 do i=1,attPackInstanceNameCount 
 attPackInstanceNameList(i) = & 
 APinstNameString(j:(j+APinstNameLens(i)-1)) 
 j = j + APinstNameLens(i) 
 enddo 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetAPinstNamesAP 
 
!--------------------------------------------------------------------------- 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAPinstNames" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a list of AttPack instance names 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetAPinstNames(comp, convention, purpose, & 
 attPackInstanceNameList, attPackInstanceNameCount, & 
 attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(out) :: attPackInstanceNameList 
 integer, intent(out) :: attPackInstanceNameCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Get the Attribute package instance names of the specified convention 
! and purpose. Also get the number of such names. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the Attribute package instances. 
! \item [purpose] 
! The purpose of the Attribute package instances. 
! \item [attPackInstanceNameList] 
! The name(s) of the Attribute package instances of the given 
! convention and purpose. 
! \item [attPackInstanceNameCount] 
! The number of Attribute package instance names. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, APinstNameSize 
 integer, dimension(size(attPackInstanceNameList)) :: APinstNameLens 
 character(len=(size(attPackInstanceNameList)*len(attPackInstanceNameList))) :: APinstNameString 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! pack widths of NameList elements 
 APinstNameSize = size(attPackInstanceNameList) 
 do i=1,APinstNameSize 
 APinstNameLens(i) = len(attPackInstanceNameList(i)) 
 enddo 
 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, & 
 attpack=attpack, attnestflag=lattnestflag, & 
 rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackGetAPinstNames(comp%compp%base, attpack, & 
 APinstNameString, APinstNameLens, APinstNameSize, & 
 attPackInstanceNameCount, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! unpack returned attpack instance names 
 j = 1 
 do i=1,attPackInstanceNameCount 
 attPackInstanceNameList(i) = & 
 APinstNameString(j:(j+APinstNameLens(i)-1)) 
 j = j + APinstNameLens(i) 
 enddo 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetAPinstNames 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_GridCompAttLinkCplComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp1 
 type(ESMF_CplComp), intent(in) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_GridComp} object. 
! \item [comp2] 
! An {\tt ESMF_CplComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkCplComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_GridCompAttLinkGridComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp1 
 type(ESMF_GridComp), intent(in) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_GridComp} object. 
! \item [comp2] 
! An {\tt ESMF_GridComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkGridComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_GridCompAttLinkSciComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp1 
 type(ESMF_SciComp), intent(in) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_GridComp} object. 
! \item [comp2] 
! An {\tt ESMF_SciComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkSciComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_GridCompAttLinkState(comp, state, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 type(ESMF_State), intent(in) :: state 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [state] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp%compp%base, state%statep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_GridCompAttLinkGrid(comp, grid, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 type(ESMF_Grid), intent(in) :: grid 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp%compp%base, grid, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkGrid 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_GridCompAttLinkLocStream(comp, locStream, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 type(ESMF_LocStream), intent(in) :: locStream 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [locStream] 
! An {\tt ESMF_LocStream} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locStream,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp%compp%base, locStream, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkLocStream 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_GridCompAttLinkRmCplComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp1 
 type(ESMF_CplComp), intent(in) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_GridComp} object. 
! \item [comp2] 
! An {\tt ESMF_CplComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkRmCplComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_GridCompAttLinkRmGridComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp1 
 type(ESMF_GridComp), intent(in) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_GridComp} object. 
! \item [comp2] 
! An {\tt ESMF_GridComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkRmGridComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_GridCompAttLinkRmSciComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp1 
 type(ESMF_SciComp), intent(in) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_GridComp} object. 
! \item [comp2] 
! An {\tt ESMF_SciComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkRmSciComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_GridCompAttLinkRmState(comp, state, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 type(ESMF_State), intent(in) :: state 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [state] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp%compp%base, state%statep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkRmState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_GridCompAttLinkRmGrid(comp, grid, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 type(ESMF_Grid), intent(in) :: grid 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp%compp%base, grid, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkRmGrid 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_GridCompAttLinkRmLocStream(comp, locStream, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 type(ESMF_LocStream), intent(in) :: locStream 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [locStream] 
! An {\tt ESMF_LocStream} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locStream,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp%compp%base, locStream, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkRmLocStream 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_GridCompAttRead(comp, fileName, schemaFileName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len=*), intent(in), optional :: fileName 
 character (len=*), intent(in), optional :: schemaFileName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt comp}. 
! The Attribute package defines the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [{[fileName]}] 
! The file name to read from. 
! \item [{[schemaFileName]}] 
! The name of the XSD file to validate fileName. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, schemaFileNameLen, localrc 
 
 fileNameLen = 0 
 schemaFileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 ! get length of given fileNames for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 if (present(schemaFileName)) then 
 schemaFileNameLen = len_trim(schemaFileName) 
 end if 
 
 ! invoke C to C++ entry point 
 call c_ESMC_AttributeRead(comp%compp%base, fileNameLen, fileName, & 
 schemaFileNameLen, schemaFileName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttRead 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetAPI1(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetAPI1 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetI1(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DAPI1(comp, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DI1(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetAPI2(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetAPI2 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetI2(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DAPI2(comp, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DI2(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetAPI4(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetAPI4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetI4(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DAPI4(comp, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DI4(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetAPI8(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetAPI8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetI8(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DAPI8(comp, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DI8(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetAPR4(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetAPR4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetR4(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DAPR4(comp, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DR4(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetAPR8(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetAPR8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetR8(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DAPR8(comp, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DR8(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetLgclAP(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 localvalue = value 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetLgcl(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented, 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetLgclListAP(comp, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetLgclList(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetCharAP(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 lens(1) = len_trim(value) 
 count = 1 
 
 call c_ESMC_AttPackSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetChar(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetCharListAP(comp, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetCharList(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_GridCompAttUpdate(comp, vm, rootList, reconcile, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 logical, intent(in), optional :: reconcile 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [vm] 
! The virtual machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of PETs that are to be used to as the source of the update. 
! \item [{[reconcile]}] 
! A logical flag used to indicate whether to use reconcile behavior or 
! normal update behavior. If {\tt reconcile} is set to {\tt ESMF\_TRUE} 
! then the values of the root PETs will be sent to the nonroot PETs without 
! exception. Otherwise, an algorithm that is optimized to use minimal 
! memory will be used to update only the modified parts of the Attribute 
! hierarchy on the nonroot PETs. The default value is {\tt ESMF\_FALSE}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 type(ESMF_Logical) :: local_reconcile 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 ! reconcile 
 if ( present(reconcile)) then 
 local_reconcile = reconcile 
 else 
 local_reconcile = ESMF_FALSE 
 endif 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(comp%compp%base, vm, rootList, count, & 
 local_reconcile, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_GridCompAttWrite(comp, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(in) :: comp 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! This call is collective across the current VM. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, petCount, localPet 
 character(len=*), parameter :: object="comp" 
 character(len=*), parameter :: ftarobj="field" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 type(ESMF_VM) :: vm 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 call ESMF_VMGetCurrent(vm, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localPet == 0) then 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttributeWrite(comp%compp%base, convention, & 
 purpose, object, ftarobj, writeflag, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 call ESMF_VMBarrier(vm, rc=rc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttWrite 

!-------------------------------------------------------------------------
! SciComp
!-------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, keywordEnforcer, attPackInstanceName, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object.
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, count 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="comp" 
 type(ESMF_AttPack) :: lattpack 
 character(len=max(len(convention), len(purpose))), dimension(3) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 count = 3 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! guard against a situation which cannot be prevented with the use of optional arguments 
 if (present(attpackInstanceName)) then 
 if (len(attpackInstanceName) > max(len(convention), len(purpose))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="TODO: initialize the specList with length dependent on attpackInstanceName", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 if (present(attpackInstanceName)) then 
 specList(3) = trim(attpackInstanceName) 
 count = 4 
 else 
 specList(3) = "" 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackGet(comp%compp%base, lattpack, & 
 count, specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetAttPack 
!------------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPackSL" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_SciCompAttGetAttPackSL(comp, & 
 specList, keywordEnforcer, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="comp" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if (size(specList) > 4) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackGet(comp%compp%base, lattpack, & 
 size(lens), specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetAttPackSL 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStd" 
 
!BOPI 
! !IROUTINE: AttAddPackStd - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_SciCompAttAddPackStd(comp, convention, purpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_SciComp} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j ! Error status 
 character (len=*), parameter :: object="comp" 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (.not.((convention.eq."ESG" .and.purpose.eq."General").or. & 
 (convention.eq."ESMF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."Extended").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."grids").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."grids").or. & 
 (convention.eq."CIM 1.5".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.5".and.purpose.eq."Inputs").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."Inputs").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."Inputs"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute package convention and purpose values", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackCreateStandard(comp%compp%base, & 
 size(lens), specString, lens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_SciCompAttGetAttPackSL(comp, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStdN" 
 
!BOPI 
! !IROUTINE: AttAddPackStdN - Add an ESMF standard Attribute package with nested standard Attribute packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_SciCompAttAddPackStdN(comp, convention, purpose, & 
 nestConvention, nestPurpose, nestAttPackInstanceCountList, & 
 nestAttPackInstanceNameList, nestCount, & 
 nestAttPackInstanceNameCount, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, dimension(:), intent(in) :: nestAttPackInstanceCountList 
 character (len = *), dimension(:), intent(out) :: nestAttPackInstanceNameList 
 integer, intent(in), optional :: nestCount 
 integer, intent(out), optional :: nestAttPackInstanceNameCount 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package which contains a user-specified 
! number of nested standard Attribute packages. ESMF generates and 
! returns default instance names for the nested Attribute packages. 
! These names can be used later to distinguish among multiple nested 
! Attribute packages of the same type in calls to 
! {\tt ESMF\_AttributeGet()}, {\tt ESMF\_AttributeSet()}, and 
! {\tt ESMF\_AttributeRemove()}. See Section~\ref{sec:AttPacks} for a 
! description of Attribute packages and their conventions, purposes, 
! and object types. 
! 
! Add an ESMF standard Attribute package which contains a user-specified 
! number of nested standard Attribute packages. The user specifies the 
! names of the nested Attribute package instances (not yet implemented), 
! or ESMF generates and returns default instance names. These names can 
! be used later to distinguish among multiple nested Attribute packages 
! of the same type in calls to {\tt ESMF\_AttributeGet()}, 
! {\tt ESMF\_AttributeSet()}, and {\tt ESMF\_AttributeRemove()}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attpack] 
! The Attribute package to be created. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [nestConvention] 
! The convention(s) of the standard Attribute package type(s) around 
! which to nest the new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the standard Attribute package type(s) around 
! which to nest the new Attribute package. 
! \item [nestAttPackInstanceCountList] 
! The desired number of nested Attribute package instances for each 
! nested (nestConvention, nestPurpose) package type. Note: if only one 
! of each nested package type is desired, then the 
! {\tt ESMF\_AttributeAdd()} overloaded method 
! {\tt ESMF\_AttAddPackStd()} should be used. 
! \item [nestAttPackInstanceNameList] 
! The name(s) of the nested Attribute package instances, generated 
! by ESMF, used to distinguish between multiple instances of the 
! same convention and purpose. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute package types to add to 
! the new Attribute package. 
! \item [{[nestAttPackInstanceNameCount]}] 
! The number of nested Attribute package instance names. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k 
 integer :: localNestCount, localNestAPinstNameSize, totalInstances 
 integer :: localNestAPinstNameCount 
 character(len=*), parameter :: object="comp" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 
 integer, dimension(size(nestAttPackInstanceNameList)) :: nestAPinstNameLens 
 character(len=(size(nestAttPackInstanceNameList)*len(nestAttPackInstanceNameList))) :: nestAPinstNameString 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 ! TODO: check if (convention, purpose) is standard attpack type 
 ! if so, then check if (nestConvention, nestPurpose) are standard 
 ! children of the parent 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (size(nestAttPackInstanceCountList).ne.size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestAttPackInstanceCountList and nestConvention must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! pack conv,purp strings and lengths, add up instances 
 j = 1 
 k = 1 
 totalInstances = 0 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 totalInstances = totalInstances + nestAttPackInstanceCountList(i) 
 enddo 
 
 if (totalInstances.gt.size(nestAttPackInstanceNameList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="size(nestAttPackInstanceNameList) not big enough for the number of instances specified in nestAttPackInstanceCountList", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! pack widths of NameList elements 
 ! TODO: pack actual lengths (len_trim) when implementing name input 
 localNestAPinstNameSize = size(nestAttPackInstanceNameList) 
 do i=1,localNestAPinstNameSize 
 nestAPinstNameLens(i) = len(nestAttPackInstanceNameList(i)) 
 enddo 
 
 call c_ESMC_AttPackCreateStdNest(comp%compp%base, convention, & 
 purpose, object, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, nestAttPackInstanceCountList, & 
 localNestCount, & 
 nestAPinstNameString, nestAPinstNameLens, localNestAPinstNameSize, & 
 localNestAPinstNameCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! unpack returned attpack instance names 
 j = 1 
 do i=1,localNestAPinstNameCount 
 nestAttPackInstanceNameList(i) = & 
 nestAPinstNameString(j:(j+nestAPinstNameLens(i)-1)) 
 j = j + nestAPinstNameLens(i) 
 enddo 
 
 ! return number of attpack instance names 
 if (present(nestAttPackInstanceNameCount)) then 
 nestAttPackInstanceNameCount = localNestAPinstNameCount 
 endif 
 
 if ( present(attpack) ) then 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! retrieve the optional attribute package handle 
 call ESMF_SciCompAttGetAttPackSL(comp, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttAddPackStdN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_SciCompAttAddPackCst(comp, convention, purpose, attrList, & 
 count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt convention} and {\tt purpose} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 type(ESMF_AttPack) :: lattpack 
 logical :: lispresent, lredundant 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 call ESMF_SciCompAttAddPackCstSL(comp, specList, attrList, & 
 count=localcount, redundant=lredundant, & 
 attpack=lattpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_SciCompAttAddPackCstN(comp, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="comp" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(comp%compp%base, size(lens), specString, lens, & 
 localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(comp%compp%base, attrList(i), & 
 size(lens), specString, lens, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_SciCompAttGetAttPackSL(comp, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_SciCompAttAddPackCstN1(comp, convention, purpose, attrList, & 
 count, nestConvention, nestPurpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribvute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_SciCompAttAddPackCstN(comp, & 
 convention, purpose, & 
 attrList, count, & 
 nestConvString, nestPurpString, & 
 nestCount=1, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttAddPackCstN1
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStdSL" 
 
!BOPI 
! !IROUTINE: AttAddPackStdSL - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_SciCompAttAddPackStdSL(comp, specList, keywordEnforcer, & 
 attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_SciComp} object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j ! Error status 
 character (len=*), parameter :: object="comp" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (.not.((specList(1).eq."ESG" .and.specList(2).eq."General").or. & 
 (specList(1).eq."ESMF" .and.specList(2).eq."General").or. & 
 (specList(1).eq."CF" .and.specList(2).eq."General").or. & 
 (specList(1).eq."CF" .and.specList(2).eq."Extended").or. & 
 (specList(1).eq."CIM 1.5.1".and.specList(2).eq."grids").or. & 
 (specList(1).eq."CIM 1.7.1".and.specList(2).eq."grids").or. & 
 (specList(1).eq."CIM 1.5" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.5.1" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.7.1" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.5" .and.specList(2).eq."Inputs").or. & 
 (specList(1).eq."CIM 1.5.1" .and.specList(2).eq."Inputs").or. & 
 (specList(1).eq."CIM 1.7.1" .and.specList(2).eq."Inputs"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute packages", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 ! create the attribute package 
 call c_ESMC_AttPackCreateStandard(comp%compp%base, & 
 size(lens), specString, lens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! retrieve the optional attribute package handle 
 if (present(attpack)) then 
 
 call ESMF_SciCompAttGetAttPackSL(comp, specList, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttAddPackStdSL
!AttAddPackStandardNMacroSL(ESMF_SciComp, comp, comp%compp%base)
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstSL" 
!BOPI 
! !IROUTINE: AttAddPackCstSL - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_SciCompAttAddPackCstSL(comp, specList, attrList, & 
 keywordEnforcer, count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), dimension(:), intent(in) :: specList 
 character (len = *), dimension(:), intent(in) :: attrList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! convention, purpose, and instancename. 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt specList} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack}]] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=*), parameter :: object="comp" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 logical :: attpackpresent, lredundant 
 logical :: lispresent, createnewattpack, addtoattpack 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 lispresent = .false. 
 createnewattpack = .false. 
 addtoattpack = .false. 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 ! verify that the count and number of attribute names are reasonable 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if ( lredundant .eqv. .true. ) then 
 createnewattpack = .true. 
 else 
 call ESMF_SciCompAttGetAttPackSL(comp, specList, attpack=lattpack, & 
 isPresent=lispresent, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lispresent .eqv. .false.) then 
 createnewattpack = .true. 
 else 
 addtoattpack = .true. 
 endif 
 endif 
 
 if ( createnewattpack .eqv. .true. ) then 
 call c_ESMC_AttPackCreateCustom(comp%compp%base, & 
 size(lens), specString, lens, & 
 lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 else if ( addtoattpack .eqv. .true. ) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 endif 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttAddPackCstSL
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttributeCopy" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy between objects 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeCopy() 
 subroutine ESMF_SciCompAttCopy(comp1, comp2, attcopy, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(in) :: comp1 
 type(ESMF_SciComp), intent(inout) :: comp2 
 type(ESMF_AttCopy_Flag), intent(in), optional :: attcopy 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Copy all Attributes in one hierarchy to another. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_SciComp} object. 
! \item [comp2] 
! An {\tt ESMF_SciComp} object. 
! \item [attcopyflag] 
! A flag to determine if the copy is to be by reference, value, or hybrid 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 
 character(ESMF_MAXSTR) :: value 
 integer, dimension(1) :: lens 
 type(ESMF_AttCopy_Flag) :: localattcopy 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp1,rc) 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp2,rc) 
 
 ! set copy flag default 
 localattcopy = ESMF_ATTCOPY_VALUE 
 if (present(attcopy)) then 
 localattcopy = attcopy 
 endif 
 
 call c_ESMC_AttributeCopy(comp1%compp%base, comp2%compp%base, & 
 localattcopy, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttCopy 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package using an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_SciCompAttRemoveAP(comp, keywordEnforcer, name, & 
 attpack, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(comp%compp%base, name, attpack, & 
 lattnestflag, localrc) 
 else 
 call c_ESMC_AttPackRemove(comp%compp%base, attpack, localrc) 
 ESMF_INIT_SET_DELETED(attpack) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttRemoveAP 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_SciCompAttRemove(comp, name, convention, purpose, & 
 attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpackobj 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemove(comp%compp%base, attpackobj, lattnestflag, localrc) 
 ESMF_INIT_SET_DELETED(attpackobj) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemoveAttribute(comp%compp%base, name, attpackobj, & 
 lattnestflag, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(comp%compp%base, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetAPI1(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetI1(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetI1 
!------------------------------------------------------------------------------ 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetAPI2(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetI2(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetI2 
!------------------------------------------------------------------------------ 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetAPI4(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetI4(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetI4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetAPI8(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetI8(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetI8 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetAPR4(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetR4(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetR4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetAPR8(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetR8(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetR8 
!------------------------------------------------------------------------------ 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGet1DAPI1(comp, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I1, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGet1DAPI1 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGet1DI1(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I1, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGet1DAPI2(comp, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I2, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGet1DAPI2 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGet1DI2(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I2, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGet1DAPI4(comp, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGet1DAPI4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGet1DI4(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGet1DAPI8(comp, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGet1DAPI8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGet1DI8(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_I8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGet1DAPR4(comp, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGet1DAPR4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGet1DR4(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGet1DAPR8(comp, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGet1DAPR8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGet1DR8(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_R8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetLgclAP(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, localvalue 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetLgcl(comp, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetLgclListAP(comp, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetLgclList(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetCharAP(comp, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len = *), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_SciCompAttGetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetChar(comp, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, & 
 lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_SciCompAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetCharListAP(comp, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len=*), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetCharList(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(comp%compp%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetCount(comp, count, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(in) :: comp 
 integer, intent(out) :: count 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given Attribute 
! package in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_Logical) :: isAttpack 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, & 
 attPackInstanceName=attPackInstanceName, & 
 attpack=attpack, attnestflag=lattnestflag, & 
 rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, & 
 lattcountflag, lattnestflag, & 
 localrc) 
 else 
 call c_ESMC_AttributeGetCount(comp%compp%base, count, lattcountflag, & 
 localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetCount 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCountAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetCountAttPack(comp, attpack, count, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(in) :: comp 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, lattcountflag, & 
 lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetCountAttPack 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetInfoByNamAP(comp, name, attpack, & 
 keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(in) :: comp 
 character(len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(comp%compp%base, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetInfoByNamAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetInfoByNam(comp, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(in) :: comp 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}.
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(comp%compp%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(comp%compp%base, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNumAP" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetInfoByNumAP(comp, attributeIndex, attpack, & 
 name, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(in) :: comp 
 integer, intent(in) :: attributeIndex 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character(len=*), intent(out) :: name 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentIndex(comp%compp%base, attributeIndex, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(comp%compp%base, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetInfoByNumAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetInfoByNum(comp, attributeIndex, name, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(in) :: comp 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentIndex(comp%compp%base, attributeIndex, & 
 attpack, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(comp%compp%base, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresentIndex(comp%compp%base, attributeIndex, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoNum(comp%compp%base, attributeIndex, & 
 localName, localTk, & 
 litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetInfoByNum 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAPinstNamesAP" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a list of AttPack instance names using an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetAPinstNamesAP(comp, attpack, & 
 attPackInstanceNameList, attPackInstanceNameCount, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(in) :: comp 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len = *), dimension(:), intent(out) :: attPackInstanceNameList 
 integer, intent(out) :: attPackInstanceNameCount 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Get the Attribute package instance names of the specified 
! ESMF\_AttPack. Also get the number of such names. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [attPackInstanceNameList] 
! The name(s) of the Attribute package instances of the given 
! convention and purpose. 
! \item [attPackInstanceNameCount] 
! The number of Attribute package instance names. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, APinstNameSize 
 integer, dimension(size(attPackInstanceNameList)) :: APinstNameLens 
 character(len=(size(attPackInstanceNameList)*len(attPackInstanceNameList))) :: APinstNameString 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! pack widths of NameList elements 
 APinstNameSize = size(attPackInstanceNameList) 
 do i=1,APinstNameSize 
 APinstNameLens(i) = len(attPackInstanceNameList(i)) 
 enddo 
 
 call c_ESMC_AttPackGetAPinstNames(comp%compp%base, attpack, & 
 APinstNameString, APinstNameLens, APinstNameSize, & 
 attPackInstanceNameCount, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! unpack returned attpack instance names 
 j = 1 
 do i=1,attPackInstanceNameCount 
 attPackInstanceNameList(i) = & 
 APinstNameString(j:(j+APinstNameLens(i)-1)) 
 j = j + APinstNameLens(i) 
 enddo 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetAPinstNamesAP 
 
!--------------------------------------------------------------------------- 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAPinstNames" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a list of AttPack instance names 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_SciCompAttGetAPinstNames(comp, convention, purpose, & 
 attPackInstanceNameList, attPackInstanceNameCount, & 
 attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(out) :: attPackInstanceNameList 
 integer, intent(out) :: attPackInstanceNameCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Get the Attribute package instance names of the specified convention 
! and purpose. Also get the number of such names. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the Attribute package instances. 
! \item [purpose] 
! The purpose of the Attribute package instances. 
! \item [attPackInstanceNameList] 
! The name(s) of the Attribute package instances of the given 
! convention and purpose. 
! \item [attPackInstanceNameCount] 
! The number of Attribute package instance names. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, APinstNameSize 
 integer, dimension(size(attPackInstanceNameList)) :: APinstNameLens 
 character(len=(size(attPackInstanceNameList)*len(attPackInstanceNameList))) :: APinstNameString 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! pack widths of NameList elements 
 APinstNameSize = size(attPackInstanceNameList) 
 do i=1,APinstNameSize 
 APinstNameLens(i) = len(attPackInstanceNameList(i)) 
 enddo 
 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, & 
 attpack=attpack, attnestflag=lattnestflag, & 
 rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackGetAPinstNames(comp%compp%base, attpack, & 
 APinstNameString, APinstNameLens, APinstNameSize, & 
 attPackInstanceNameCount, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! unpack returned attpack instance names 
 j = 1 
 do i=1,attPackInstanceNameCount 
 attPackInstanceNameList(i) = & 
 APinstNameString(j:(j+APinstNameLens(i)-1)) 
 j = j + APinstNameLens(i) 
 enddo 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttGetAPinstNames 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_SciCompAttLinkCplComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp1 
 type(ESMF_CplComp), intent(in) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_SciComp} object. 
! \item [comp2] 
! An {\tt ESMF_CplComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttLinkCplComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_SciCompAttLinkGridComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp1 
 type(ESMF_GridComp), intent(in) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_SciComp} object. 
! \item [comp2] 
! An {\tt ESMF_GridComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttLinkGridComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_SciCompAttLinkSciComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp1 
 type(ESMF_SciComp), intent(in) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_SciComp} object. 
! \item [comp2] 
! An {\tt ESMF_SciComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttLinkSciComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_SciCompAttLinkState(comp, state, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 type(ESMF_State), intent(in) :: state 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_SciComp} object. 
! \item [state] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp%compp%base, state%statep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttLinkState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_SciCompAttLinkGrid(comp, grid, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 type(ESMF_Grid), intent(in) :: grid 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_SciComp} object. 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp%compp%base, grid, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttLinkGrid 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_SciCompAttLinkLocStream(comp, locStream, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 type(ESMF_LocStream), intent(in) :: locStream 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_SciComp} object. 
! \item [locStream] 
! An {\tt ESMF_LocStream} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locStream,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp%compp%base, locStream, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttLinkLocStream 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_SciCompAttLinkRmCplComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp1 
 type(ESMF_CplComp), intent(in) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_SciComp} object. 
! \item [comp2] 
! An {\tt ESMF_CplComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttLinkRmCplComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_SciCompAttLinkRmGridComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp1 
 type(ESMF_GridComp), intent(in) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_SciComp} object. 
! \item [comp2] 
! An {\tt ESMF_GridComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttLinkRmGridComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_SciCompAttLinkRmSciComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp1 
 type(ESMF_SciComp), intent(in) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_SciComp} object. 
! \item [comp2] 
! An {\tt ESMF_SciComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttLinkRmSciComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_SciCompAttLinkRmState(comp, state, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 type(ESMF_State), intent(in) :: state 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_SciComp} object. 
! \item [state] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp%compp%base, state%statep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttLinkRmState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_SciCompAttLinkRmGrid(comp, grid, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 type(ESMF_Grid), intent(in) :: grid 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_SciComp} object. 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp%compp%base, grid, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttLinkRmGrid 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_SciCompAttLinkRmLocStream(comp, locStream, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 type(ESMF_LocStream), intent(in) :: locStream 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_SciComp} object. 
! \item [locStream] 
! An {\tt ESMF_LocStream} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locStream,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp%compp%base, locStream, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttLinkRmLocStream 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_SciCompAttRead(comp, fileName, schemaFileName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len=*), intent(in), optional :: fileName 
 character (len=*), intent(in), optional :: schemaFileName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt comp}. 
! The Attribute package defines the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_SciComp} object. 
! \item [{[fileName]}] 
! The file name to read from. 
! \item [{[schemaFileName]}] 
! The name of the XSD file to validate fileName. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, schemaFileNameLen, localrc 
 
 fileNameLen = 0 
 schemaFileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 ! get length of given fileNames for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 if (present(schemaFileName)) then 
 schemaFileNameLen = len_trim(schemaFileName) 
 end if 
 
 ! invoke C to C++ entry point 
 call c_ESMC_AttributeRead(comp%compp%base, fileNameLen, fileName, & 
 schemaFileNameLen, schemaFileName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttRead 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetAPI1(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetAPI1 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetI1(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSet1DAPI1(comp, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSet1DAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSet1DI1(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetAPI2(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetAPI2 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetI2(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSet1DAPI2(comp, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSet1DAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSet1DI2(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetAPI4(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetAPI4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetI4(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSet1DAPI4(comp, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSet1DAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSet1DI4(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetAPI8(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetAPI8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetI8(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSet1DAPI8(comp, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSet1DAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSet1DI8(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetAPR4(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetAPR4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetR4(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSet1DAPR4(comp, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSet1DAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSet1DR4(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetAPR8(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetAPR8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetR8(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSet1DAPR8(comp, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSet1DAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSet1DR8(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetLgclAP(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 localvalue = value 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetLgcl(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented, 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetLgclListAP(comp, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetLgclList(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetCharAP(comp, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 lens(1) = len_trim(value) 
 count = 1 
 
 call c_ESMC_AttPackSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetChar(comp, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetCharListAP(comp, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_SciCompAttSetCharList(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_SciCompAttGetAttPack(comp, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_SciCompAttUpdate(comp, vm, rootList, reconcile, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(inout) :: comp 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 logical, intent(in), optional :: reconcile 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_SciComp} object. 
! \item [vm] 
! The virtual machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of PETs that are to be used to as the source of the update. 
! \item [{[reconcile]}] 
! A logical flag used to indicate whether to use reconcile behavior or 
! normal update behavior. If {\tt reconcile} is set to {\tt ESMF\_TRUE} 
! then the values of the root PETs will be sent to the nonroot PETs without 
! exception. Otherwise, an algorithm that is optimized to use minimal 
! memory will be used to update only the modified parts of the Attribute 
! hierarchy on the nonroot PETs. The default value is {\tt ESMF\_FALSE}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 type(ESMF_Logical) :: local_reconcile 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 ! reconcile 
 if ( present(reconcile)) then 
 local_reconcile = reconcile 
 else 
 local_reconcile = ESMF_FALSE 
 endif 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(comp%compp%base, vm, rootList, count, & 
 local_reconcile, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_SciCompAttWrite(comp, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_SciComp), intent(in) :: comp 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! This call is collective across the current VM. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_SciComp} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, petCount, localPet 
 character(len=*), parameter :: object="comp" 
 character(len=*), parameter :: ftarobj="field" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 type(ESMF_VM) :: vm 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit,comp,rc) 
 
 call ESMF_VMGetCurrent(vm, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localPet == 0) then 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttributeWrite(comp%compp%base, convention, & 
 purpose, object, ftarobj, writeflag, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 call ESMF_VMBarrier(vm, rc=rc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_SciCompAttWrite 

!-------------------------------------------------------------------------
! STATE
!-------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_StateAttGetAttPack(state, & 
 convention, purpose, keywordEnforcer, attPackInstanceName, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object.
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, count 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="state" 
 type(ESMF_AttPack) :: lattpack 
 character(len=max(len(convention), len(purpose))), dimension(3) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 count = 3 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! guard against a situation which cannot be prevented with the use of optional arguments 
 if (present(attpackInstanceName)) then 
 if (len(attpackInstanceName) > max(len(convention), len(purpose))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="TODO: initialize the specList with length dependent on attpackInstanceName", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 if (present(attpackInstanceName)) then 
 specList(3) = trim(attpackInstanceName) 
 count = 4 
 else 
 specList(3) = "" 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackGet(state%statep%base, lattpack, & 
 count, specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetAttPack 
!------------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPackSL" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_StateAttGetAttPackSL(state, & 
 specList, keywordEnforcer, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="state" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if (size(specList) > 4) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackGet(state%statep%base, lattpack, & 
 size(lens), specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetAttPackSL 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStd" 
 
!BOPI 
! !IROUTINE: AttAddPackStd - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_StateAttAddPackStd(state, convention, purpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j ! Error status 
 character (len=*), parameter :: object="state" 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (.not.((convention.eq."ESG" .and.purpose.eq."General").or. & 
 (convention.eq."ESMF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."Extended").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."grids").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."grids").or. & 
 (convention.eq."CIM 1.5".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.5".and.purpose.eq."Inputs").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."Inputs").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."Inputs"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute package convention and purpose values", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackCreateStandard(state%statep%base, & 
 size(lens), specString, lens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_StateAttGetAttPackSL(state, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_StateAttAddPackCst(state, convention, purpose, attrList, & 
 count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt convention} and {\tt purpose} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 type(ESMF_AttPack) :: lattpack 
 logical :: lispresent, lredundant 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 call ESMF_StateAttAddPackCstSL(state, specList, attrList, & 
 count=localcount, redundant=lredundant, & 
 attpack=lattpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_StateAttAddPackCstN(state, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="state" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(state%statep%base, size(lens), specString, lens, & 
 localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(state%statep%base, attrList(i), & 
 size(lens), specString, lens, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_StateAttGetAttPackSL(state, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_StateAttAddPackCstN1(state, convention, purpose, attrList, & 
 count, nestConvention, nestPurpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribvute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_StateAttAddPackCstN(state, & 
 convention, purpose, & 
 attrList, count, & 
 nestConvString, nestPurpString, & 
 nestCount=1, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttAddPackCstN1
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStdSL" 
 
!BOPI 
! !IROUTINE: AttAddPackStdSL - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_StateAttAddPackStdSL(state, specList, keywordEnforcer, & 
 attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j ! Error status 
 character (len=*), parameter :: object="state" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (.not.((specList(1).eq."ESG" .and.specList(2).eq."General").or. & 
 (specList(1).eq."ESMF" .and.specList(2).eq."General").or. & 
 (specList(1).eq."CF" .and.specList(2).eq."General").or. & 
 (specList(1).eq."CF" .and.specList(2).eq."Extended").or. & 
 (specList(1).eq."CIM 1.5.1".and.specList(2).eq."grids").or. & 
 (specList(1).eq."CIM 1.7.1".and.specList(2).eq."grids").or. & 
 (specList(1).eq."CIM 1.5" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.5.1" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.7.1" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.5" .and.specList(2).eq."Inputs").or. & 
 (specList(1).eq."CIM 1.5.1" .and.specList(2).eq."Inputs").or. & 
 (specList(1).eq."CIM 1.7.1" .and.specList(2).eq."Inputs"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute packages", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 ! create the attribute package 
 call c_ESMC_AttPackCreateStandard(state%statep%base, & 
 size(lens), specString, lens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! retrieve the optional attribute package handle 
 if (present(attpack)) then 
 
 call ESMF_StateAttGetAttPackSL(state, specList, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttAddPackStdSL
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstSL" 
!BOPI 
! !IROUTINE: AttAddPackCstSL - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_StateAttAddPackCstSL(state, specList, attrList, & 
 keywordEnforcer, count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), dimension(:), intent(in) :: specList 
 character (len = *), dimension(:), intent(in) :: attrList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! convention, purpose, and instancename. 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt specList} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack}]] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=*), parameter :: object="state" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 logical :: attpackpresent, lredundant 
 logical :: lispresent, createnewattpack, addtoattpack 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 lispresent = .false. 
 createnewattpack = .false. 
 addtoattpack = .false. 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 ! verify that the count and number of attribute names are reasonable 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if ( lredundant .eqv. .true. ) then 
 createnewattpack = .true. 
 else 
 call ESMF_StateAttGetAttPackSL(state, specList, attpack=lattpack, & 
 isPresent=lispresent, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lispresent .eqv. .false.) then 
 createnewattpack = .true. 
 else 
 addtoattpack = .true. 
 endif 
 endif 
 
 if ( createnewattpack .eqv. .true. ) then 
 call c_ESMC_AttPackCreateCustom(state%statep%base, & 
 size(lens), specString, lens, & 
 lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 else if ( addtoattpack .eqv. .true. ) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 endif 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttAddPackCstSL
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttributeCopy" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy between objects 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeCopy() 
 subroutine ESMF_StateAttCopy(state1, state2, attcopy, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(in) :: state1 
 type(ESMF_State), intent(inout) :: state2 
 type(ESMF_AttCopy_Flag), intent(in), optional :: attcopy 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Copy all Attributes in one hierarchy to another. 
! 
! The arguments are: 
! \begin{description} 
! \item [state1] 
! An {\tt ESMF_State} object. 
! \item [state2] 
! An {\tt ESMF_State} object. 
! \item [attcopyflag] 
! A flag to determine if the copy is to be by reference, value, or hybrid 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 
 character(ESMF_MAXSTR) :: value 
 integer, dimension(1) :: lens 
 type(ESMF_AttCopy_Flag) :: localattcopy 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state1,rc) 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state2,rc) 
 
 ! set copy flag default 
 localattcopy = ESMF_ATTCOPY_VALUE 
 if (present(attcopy)) then 
 localattcopy = attcopy 
 endif 
 
 call c_ESMC_AttributeCopy(state1%statep%base, state2%statep%base, & 
 localattcopy, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttCopy 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetAPI1(state, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetI1(state, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetI1 
!------------------------------------------------------------------------------ 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetAPI2(state, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetI2(state, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetI2 
!------------------------------------------------------------------------------ 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetAPI4(state, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetI4(state, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetI4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetAPI8(state, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetI8(state, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetI8 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetAPR4(state, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetR4(state, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetR4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetAPR8(state, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetR8(state, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetR8 
!------------------------------------------------------------------------------ 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DAPI1(state, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_I1, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DAPI1 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DI1(state, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_I1, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DAPI2(state, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_I2, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DAPI2 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DI2(state, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_I2, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DAPI4(state, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_I4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DAPI4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DI4(state, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_I4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DAPI8(state, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_I8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DAPI8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DI8(state, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_I8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DAPR4(state, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_R4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DAPR4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DR4(state, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_R4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DAPR8(state, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_R8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DAPR8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DR8(state, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_State), intent(in) :: state 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_R8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetLgclAP(state, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, localvalue 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetLgcl(state, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetLgclListAP(state, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(in) :: state 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetLgclList(state, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(in) :: state 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetCharAP(state, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len = *), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_StateAttGetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetChar(state, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, & 
 lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(state%statep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_StateAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetCharListAP(state, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len=*), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetCharList(state, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(state%statep%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(state%statep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetCount(state, count, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(in) :: state 
 integer, intent(out) :: count 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given Attribute 
! package in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_Logical) :: isAttpack 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, & 
 attPackInstanceName=attPackInstanceName, & 
 attpack=attpack, attnestflag=lattnestflag, & 
 rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, & 
 lattcountflag, lattnestflag, & 
 localrc) 
 else 
 call c_ESMC_AttributeGetCount(state%statep%base, count, lattcountflag, & 
 localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetCount 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCountAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetCountAttPack(state, attpack, count, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(in) :: state 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, lattcountflag, & 
 lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetCountAttPack 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetInfoByNamAP(state, name, attpack, & 
 keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(in) :: state 
 character(len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(state%statep%base, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetInfoByNamAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetInfoByNam(state, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(in) :: state 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}.
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(state%statep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(state%statep%base, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNumAP" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetInfoByNumAP(state, attributeIndex, attpack, & 
 name, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(in) :: state 
 integer, intent(in) :: attributeIndex 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character(len=*), intent(out) :: name 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentIndex(state%statep%base, attributeIndex, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(state%statep%base, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetInfoByNumAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetInfoByNum(state, attributeIndex, name, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(in) :: state 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentIndex(state%statep%base, attributeIndex, & 
 attpack, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(state%statep%base, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresentIndex(state%statep%base, attributeIndex, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoNum(state%statep%base, attributeIndex, & 
 localName, localTk, & 
 litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetInfoByNum 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_StateAttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_StateAttLinkArray(state, array, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_Array), intent(in) :: array 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [array] 
! An {\tt ESMF_Array} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: lvalue1, lvalue2 
 character (len=*), parameter :: lobject = "array" 
 character (len=*), parameter :: lname1 = 'import' 
 character (len=*), parameter :: lname2 = 'export' 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(state%statep%base, & 
 array, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! set the import and export Attributes on any Field connected to this State 
 lvalue1 = .true. 
 lvalue2 = .false. 
 if (state%statep%st == ESMF_STATEINTENT_IMPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 else if (state%statep%st == ESMF_STATEINTENT_EXPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkArray 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_StateAttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_StateAttLinkArrayBundle(state, arraybundle, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [arraybundle] 
! An {\tt ESMF_ArrayBundle} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: lvalue1, lvalue2 
 character (len=*), parameter :: lobject = "array" 
 character (len=*), parameter :: lname1 = 'import' 
 character (len=*), parameter :: lname2 = 'export' 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(state%statep%base, & 
 arraybundle, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! set the import and export Attributes on any Field connected to this State 
 lvalue1 = .true. 
 lvalue2 = .false. 
 if (state%statep%st == ESMF_STATEINTENT_IMPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 else if (state%statep%st == ESMF_STATEINTENT_EXPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkArrayBundle 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_StateAttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_StateAttLinkField(state, field, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_Field), intent(in) :: field 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [field] 
! An {\tt ESMF_Field} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: lvalue1, lvalue2 
 character (len=*), parameter :: lobject = "field" 
 character (len=*), parameter :: lname1 = 'import' 
 character (len=*), parameter :: lname2 = 'export' 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(state%statep%base, & 
 field%ftypep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! set the import and export Attributes on any Field connected to this State 
 lvalue1 = .true. 
 lvalue2 = .false. 
 if (state%statep%st == ESMF_STATEINTENT_IMPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 else if (state%statep%st == ESMF_STATEINTENT_EXPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkField 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_StateAttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_StateAttLinkFieldBundle(state, fieldbundle, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: lvalue1, lvalue2 
 character (len=*), parameter :: lobject = "field" 
 character (len=*), parameter :: lname1 = 'import' 
 character (len=*), parameter :: lname2 = 'export' 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(state%statep%base, & 
 fieldbundle%this%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! set the import and export Attributes on any Field connected to this State 
 lvalue1 = .true. 
 lvalue2 = .false. 
 if (state%statep%st == ESMF_STATEINTENT_IMPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 else if (state%statep%st == ESMF_STATEINTENT_EXPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkFieldBundle 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_StateAttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_StateAttLinkState(state1, state2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state1 
 type(ESMF_State), intent(in) :: state2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state1] 
! An {\tt ESMF\_State} object. 
! \item [state2] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: lvalue1, lvalue2 
 character (len=*), parameter :: lobject = "field" 
 character (len=*), parameter :: lname1 = 'import' 
 character (len=*), parameter :: lname2 = 'export' 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state1,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state2,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(state1%statep%base, & 
 state2%statep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! set the import and export Attributes on any Field connected to this State 
 lvalue1 = .true. 
 lvalue2 = .false. 
 if (state1%statep%st == ESMF_STATEINTENT_IMPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state1%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state1%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 else if (state1%statep%st == ESMF_STATEINTENT_EXPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state1%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state1%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_StateAttLinkRmArray(state, array, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_Array), intent(in) :: array 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [array] 
! An {\tt ESMF_Array} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 state%statep%base, array, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkRmArray 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_StateAttLinkRmArrayBundle(state, arraybundle, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [arraybundle] 
! An {\tt ESMF_ArrayBundle} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 state%statep%base, arraybundle, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkRmArrayBundle 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_StateAttLinkRmField(state, field, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_Field), intent(in) :: field 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [field] 
! An {\tt ESMF_Field} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 state%statep%base, field%ftypep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkRmField 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_StateAttLinkRmFieldBundle(state, fieldbundle, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 state%statep%base, fieldbundle%this%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkRmFieldBundle 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_StateAttLinkRmState(state1, state2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state1 
 type(ESMF_State), intent(in) :: state2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state1] 
! An {\tt ESMF_State} object. 
! \item [state2] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state2,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 state1%statep%base, state2%statep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkRmState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package using an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_StateAttRemoveAP(state, keywordEnforcer, name, & 
 attpack, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(state%statep%base, name, attpack, & 
 lattnestflag, localrc) 
 else 
 call c_ESMC_AttPackRemove(state%statep%base, attpack, localrc) 
 ESMF_INIT_SET_DELETED(attpack) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttRemoveAP 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_StateAttRemove(state, name, convention, purpose, & 
 attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpackobj 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemove(state%statep%base, attpackobj, lattnestflag, localrc) 
 ESMF_INIT_SET_DELETED(attpackobj) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemoveAttribute(state%statep%base, name, attpackobj, & 
 lattnestflag, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(state%statep%base, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttRemove 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_StateAttRead(state, fileName, schemaFileName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len=*), intent(in), optional :: fileName 
 character (len=*), intent(in), optional :: schemaFileName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt state}. 
! The Attribute package defines the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [{[fileName]}] 
! The file name to read from. 
! \item [{[schemaFileName]}] 
! The name of the XSD file to validate fileName. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, schemaFileNameLen, localrc 
 
 fileNameLen = 0 
 schemaFileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 ! get length of given fileNames for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 if (present(schemaFileName)) then 
 schemaFileNameLen = len_trim(schemaFileName) 
 end if 
 
 ! invoke C to C++ entry point 
 call c_ESMC_AttributeRead(state%statep%base, fileNameLen, fileName, & 
 schemaFileNameLen, schemaFileName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttRead 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetAPI1(state, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetAPI1 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetI1(state, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DAPI1(state, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DI1(state, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetAPI2(state, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetAPI2 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetI2(state, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DAPI2(state, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DI2(state, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetAPI4(state, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetAPI4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetI4(state, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DAPI4(state, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DI4(state, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetAPI8(state, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetAPI8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetI8(state, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DAPI8(state, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DI8(state, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetAPR4(state, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetAPR4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetR4(state, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DAPR4(state, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DR4(state, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetAPR8(state, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetAPR8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetR8(state, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DAPR8(state, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DR8(state, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetLgclAP(state, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 localvalue = value 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetLgcl(state, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented, 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetLgclListAP(state, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetLgclList(state, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetCharAP(state, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 lens(1) = len_trim(value) 
 count = 1 
 
 call c_ESMC_AttPackSetCharList(state%statep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetChar(state, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(state%statep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(state%statep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetCharListAP(state, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackSetCharList(state%statep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetCharList(state, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_StateAttGetAttPack(state, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(state%statep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(state%statep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_StateAttUpdate(state, vm, rootList, reconcile, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 logical, intent(in), optional :: reconcile 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [vm] 
! The virtual machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of PETs that are to be used to as the source of the update. 
! \item [{[reconcile]}] 
! A logical flag used to indicate whether to use reconcile behavior or 
! normal update behavior. If {\tt reconcile} is set to {\tt ESMF\_TRUE} 
! then the values of the root PETs will be sent to the nonroot PETs without 
! exception. Otherwise, an algorithm that is optimized to use minimal 
! memory will be used to update only the modified parts of the Attribute 
! hierarchy on the nonroot PETs. The default value is {\tt ESMF\_FALSE}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 type(ESMF_Logical) :: local_reconcile 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 ! reconcile 
 if ( present(reconcile)) then 
 local_reconcile = reconcile 
 else 
 local_reconcile = ESMF_FALSE 
 endif 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(state%statep%base, vm, rootList, count, & 
 local_reconcile, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_StateAttWrite(state, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_State), intent(in) :: state 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! This call is collective across the current VM. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, petCount, localPet 
 character(len=*), parameter :: object="state" 
 character(len=*), parameter :: ftarobj="field" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 type(ESMF_VM) :: vm 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 call ESMF_VMGetCurrent(vm, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localPet == 0) then 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttributeWrite(state%statep%base, convention, & 
 purpose, object, ftarobj, writeflag, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 call ESMF_VMBarrier(vm, rc=rc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttWrite 

!-------------------------------------------------------------------------
! FIELDBUNDLE
!-------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, keywordEnforcer, attPackInstanceName, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object.
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, count 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="fieldbundle" 
 type(ESMF_AttPack) :: lattpack 
 character(len=max(len(convention), len(purpose))), dimension(3) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 count = 3 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! guard against a situation which cannot be prevented with the use of optional arguments 
 if (present(attpackInstanceName)) then 
 if (len(attpackInstanceName) > max(len(convention), len(purpose))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="TODO: initialize the specList with length dependent on attpackInstanceName", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 if (present(attpackInstanceName)) then 
 specList(3) = trim(attpackInstanceName) 
 count = 4 
 else 
 specList(3) = "" 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackGet(fieldbundle%this%base, lattpack, & 
 count, specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetAttPack 
!------------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPackSL" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_FieldBundleAttGetAttPackSL(fieldbundle, & 
 specList, keywordEnforcer, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="fieldbundle" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if (size(specList) > 4) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackGet(fieldbundle%this%base, lattpack, & 
 size(lens), specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetAttPackSL 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldBundleAttAddPackCst(fieldbundle, convention, purpose, attrList, & 
 count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt convention} and {\tt purpose} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 type(ESMF_AttPack) :: lattpack 
 logical :: lispresent, lredundant 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 call ESMF_FieldBundleAttAddPackCstSL(fieldbundle, specList, attrList, & 
 count=localcount, redundant=lredundant, & 
 attpack=lattpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldBundleAttAddPackCstN(fieldbundle, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="fieldbundle" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(fieldbundle%this%base, size(lens), specString, lens, & 
 localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(fieldbundle%this%base, attrList(i), & 
 size(lens), specString, lens, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_FieldBundleAttGetAttPackSL(fieldbundle, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldBundleAttAddPackCstN1(fieldbundle, convention, purpose, attrList, & 
 count, nestConvention, nestPurpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribvute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_FieldBundleAttAddPackCstN(fieldbundle, & 
 convention, purpose, & 
 attrList, count, & 
 nestConvString, nestPurpString, & 
 nestCount=1, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttAddPackCstN1
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstSL" 
!BOPI 
! !IROUTINE: AttAddPackCstSL - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldBundleAttAddPackCstSL(fieldbundle, specList, attrList, & 
 keywordEnforcer, count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), dimension(:), intent(in) :: specList 
 character (len = *), dimension(:), intent(in) :: attrList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! convention, purpose, and instancename. 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt specList} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack}]] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=*), parameter :: object="fieldbundle" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 logical :: attpackpresent, lredundant 
 logical :: lispresent, createnewattpack, addtoattpack 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 lispresent = .false. 
 createnewattpack = .false. 
 addtoattpack = .false. 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 ! verify that the count and number of attribute names are reasonable 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if ( lredundant .eqv. .true. ) then 
 createnewattpack = .true. 
 else 
 call ESMF_FieldBundleAttGetAttPackSL(fieldbundle, specList, attpack=lattpack, & 
 isPresent=lispresent, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lispresent .eqv. .false.) then 
 createnewattpack = .true. 
 else 
 addtoattpack = .true. 
 endif 
 endif 
 
 if ( createnewattpack .eqv. .true. ) then 
 call c_ESMC_AttPackCreateCustom(fieldbundle%this%base, & 
 size(lens), specString, lens, & 
 lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 else if ( addtoattpack .eqv. .true. ) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 endif 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttAddPackCstSL
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttributeCopy" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy between objects 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeCopy() 
 subroutine ESMF_FieldBundleAttCopy(fieldbundle1, fieldbundle2, attcopy, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle1 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle2 
 type(ESMF_AttCopy_Flag), intent(in), optional :: attcopy 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Copy all Attributes in one hierarchy to another. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle1] 
! An {\tt ESMF_FieldBundle} object. 
! \item [fieldbundle2] 
! An {\tt ESMF_FieldBundle} object. 
! \item [attcopyflag] 
! A flag to determine if the copy is to be by reference, value, or hybrid 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 
 character(ESMF_MAXSTR) :: value 
 integer, dimension(1) :: lens 
 type(ESMF_AttCopy_Flag) :: localattcopy 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle1,rc) 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle2,rc) 
 
 ! set copy flag default 
 localattcopy = ESMF_ATTCOPY_VALUE 
 if (present(attcopy)) then 
 localattcopy = attcopy 
 endif 
 
 call c_ESMC_AttributeCopy(fieldbundle1%this%base, fieldbundle2%this%base, & 
 localattcopy, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttCopy 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetAPI1(fieldbundle, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetI1(fieldbundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetI1 
!------------------------------------------------------------------------------ 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetAPI2(fieldbundle, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetI2(fieldbundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetI2 
!------------------------------------------------------------------------------ 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetAPI4(fieldbundle, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetI4(fieldbundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetI4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetAPI8(fieldbundle, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetI8(fieldbundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetI8 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetAPR4(fieldbundle, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetR4(fieldbundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetR4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetAPR8(fieldbundle, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetR8(fieldbundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetR8 
!------------------------------------------------------------------------------ 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DAPI1(fieldbundle, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_I1, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DAPI1 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DI1(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_I1, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DAPI2(fieldbundle, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_I2, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DAPI2 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DI2(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_I2, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DAPI4(fieldbundle, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_I4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DAPI4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DI4(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_I4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DAPI8(fieldbundle, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_I8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DAPI8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DI8(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_I8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DAPR4(fieldbundle, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_R4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DAPR4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DR4(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_R4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DAPR8(fieldbundle, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_R8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DAPR8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DR8(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_R8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetLgclAP(fieldbundle, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, localvalue 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetLgcl(fieldbundle, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetLgclListAP(fieldbundle, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetLgclList(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetCharAP(fieldbundle, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len = *), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_FieldBundleAttGetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetChar(fieldbundle, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, & 
 lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(fieldbundle%this%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_FieldBundleAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetCharListAP(fieldbundle, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len=*), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetCharList(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(fieldbundle%this%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(fieldbundle%this%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetCount(fieldbundle, count, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 integer, intent(out) :: count 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given Attribute 
! package in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_Logical) :: isAttpack 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, & 
 attPackInstanceName=attPackInstanceName, & 
 attpack=attpack, attnestflag=lattnestflag, & 
 rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, & 
 lattcountflag, lattnestflag, & 
 localrc) 
 else 
 call c_ESMC_AttributeGetCount(fieldbundle%this%base, count, lattcountflag, & 
 localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetCount 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCountAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetCountAttPack(fieldbundle, attpack, count, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, lattcountflag, & 
 lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetCountAttPack 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetInfoByNamAP(fieldbundle, name, attpack, & 
 keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character(len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(fieldbundle%this%base, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetInfoByNamAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetInfoByNam(fieldbundle, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}.
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(fieldbundle%this%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(fieldbundle%this%base, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNumAP" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetInfoByNumAP(fieldbundle, attributeIndex, attpack, & 
 name, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 integer, intent(in) :: attributeIndex 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character(len=*), intent(out) :: name 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentIndex(fieldbundle%this%base, attributeIndex, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(fieldbundle%this%base, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetInfoByNumAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetInfoByNum(fieldbundle, attributeIndex, name, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentIndex(fieldbundle%this%base, attributeIndex, & 
 attpack, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(fieldbundle%this%base, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresentIndex(fieldbundle%this%base, attributeIndex, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoNum(fieldbundle%this%base, attributeIndex, & 
 localName, localTk, & 
 litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetInfoByNum 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_FieldBundleAttLinkField(fieldbundle, field, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 type(ESMF_Field), intent(in) :: field 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [field] 
! An {\tt ESMF_Field} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(& 
 fieldbundle%this%base, field%ftypep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttLinkField 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_FieldBundleAttLinkGrid(fieldbundle, grid, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 type(ESMF_Grid), intent(in) :: grid 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(& 
 fieldbundle%this%base, grid, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttLinkGrid 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_FieldBundleAttLinkLocStream(fieldbundle, locStream, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 type(ESMF_LocStream), intent(in) :: locStream 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [locStream] 
! An {\tt ESMF_LocStream} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locStream,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(& 
 fieldbundle%this%base, locStream%lstypep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttLinkLocStream 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_FieldBundleAttLinkRmField(fieldbundle, field, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 type(ESMF_Field), intent(in) :: field 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [field] 
! An {\tt ESMF_Field} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 fieldbundle%this%base, field%ftypep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttLinkRmField 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_FieldBundleAttLinkRmGrid(fieldbundle, grid, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 type(ESMF_Grid), intent(in) :: grid 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 fieldbundle%this%base, grid, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttLinkRmGrid 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_FieldBundleAttLinkRmLocStream(fieldbundle, locStream, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 type(ESMF_LocStream), intent(in) :: locStream 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [locStream] 
! An {\tt ESMF_LocStream} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locStream,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 fieldbundle%this%base, locStream%lstypep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttLinkRmLocStream 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_FieldBundleAttRead(fieldbundle, fileName, schemaFileName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len=*), intent(in), optional :: fileName 
 character (len=*), intent(in), optional :: schemaFileName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt fieldbundle}. 
! The Attribute package defines the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [{[fileName]}] 
! The file name to read from. 
! \item [{[schemaFileName]}] 
! The name of the XSD file to validate fileName. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, schemaFileNameLen, localrc 
 
 fileNameLen = 0 
 schemaFileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 ! get length of given fileNames for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 if (present(schemaFileName)) then 
 schemaFileNameLen = len_trim(schemaFileName) 
 end if 
 
 ! invoke C to C++ entry point 
 call c_ESMC_AttributeRead(fieldbundle%this%base, fileNameLen, fileName, & 
 schemaFileNameLen, schemaFileName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttRead 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package using an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_FieldBundleAttRemoveAP(fieldbundle, keywordEnforcer, name, & 
 attpack, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(fieldbundle%this%base, name, attpack, & 
 lattnestflag, localrc) 
 else 
 call c_ESMC_AttPackRemove(fieldbundle%this%base, attpack, localrc) 
 ESMF_INIT_SET_DELETED(attpack) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttRemoveAP 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_FieldBundleAttRemove(fieldbundle, name, convention, purpose, & 
 attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpackobj 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemove(fieldbundle%this%base, attpackobj, lattnestflag, localrc) 
 ESMF_INIT_SET_DELETED(attpackobj) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemoveAttribute(fieldbundle%this%base, name, attpackobj, & 
 lattnestflag, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(fieldbundle%this%base, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetAPI1(fieldbundle, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetAPI1 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetI1(fieldbundle, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DAPI1(fieldbundle, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DI1(fieldbundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetAPI2(fieldbundle, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetAPI2 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetI2(fieldbundle, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DAPI2(fieldbundle, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DI2(fieldbundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetAPI4(fieldbundle, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetAPI4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetI4(fieldbundle, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DAPI4(fieldbundle, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DI4(fieldbundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetAPI8(fieldbundle, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetAPI8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetI8(fieldbundle, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DAPI8(fieldbundle, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DI8(fieldbundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetAPR4(fieldbundle, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetAPR4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetR4(fieldbundle, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DAPR4(fieldbundle, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DR4(fieldbundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetAPR8(fieldbundle, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetAPR8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetR8(fieldbundle, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DAPR8(fieldbundle, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DR8(fieldbundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetLgclAP(fieldbundle, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 localvalue = value 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetLgcl(fieldbundle, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented, 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetLgclListAP(fieldbundle, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetLgclList(fieldbundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetCharAP(fieldbundle, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 lens(1) = len_trim(value) 
 count = 1 
 
 call c_ESMC_AttPackSetCharList(fieldbundle%this%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetChar(fieldbundle, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(fieldbundle%this%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(fieldbundle%this%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetCharListAP(fieldbundle, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackSetCharList(fieldbundle%this%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetCharList(fieldbundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldBundleAttGetAttPack(fieldbundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(fieldbundle%this%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(fieldbundle%this%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_FieldBundleAttUpdate(fieldbundle, vm, rootList, reconcile, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 logical, intent(in), optional :: reconcile 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [vm] 
! The virtual machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of PETs that are to be used to as the source of the update. 
! \item [{[reconcile]}] 
! A logical flag used to indicate whether to use reconcile behavior or 
! normal update behavior. If {\tt reconcile} is set to {\tt ESMF\_TRUE} 
! then the values of the root PETs will be sent to the nonroot PETs without 
! exception. Otherwise, an algorithm that is optimized to use minimal 
! memory will be used to update only the modified parts of the Attribute 
! hierarchy on the nonroot PETs. The default value is {\tt ESMF\_FALSE}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 type(ESMF_Logical) :: local_reconcile 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 ! reconcile 
 if ( present(reconcile)) then 
 local_reconcile = reconcile 
 else 
 local_reconcile = ESMF_FALSE 
 endif 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(fieldbundle%this%base, vm, rootList, count, & 
 local_reconcile, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_FieldBundleAttWrite(fieldbundle, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(in) :: fieldbundle 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! This call is collective across the current VM. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, petCount, localPet 
 character(len=*), parameter :: object="fieldbundle" 
 character(len=*), parameter :: ftarobj="field" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 type(ESMF_VM) :: vm 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 call ESMF_VMGetCurrent(vm, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localPet == 0) then 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttributeWrite(fieldbundle%this%base, convention, & 
 purpose, object, ftarobj, writeflag, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 call ESMF_VMBarrier(vm, rc=rc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttWrite 

!-------------------------------------------------------------------------
! FIELD
!-------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, keywordEnforcer, attPackInstanceName, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object.
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, count 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="field" 
 type(ESMF_AttPack) :: lattpack 
 character(len=max(len(convention), len(purpose))), dimension(3) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 count = 3 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! guard against a situation which cannot be prevented with the use of optional arguments 
 if (present(attpackInstanceName)) then 
 if (len(attpackInstanceName) > max(len(convention), len(purpose))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="TODO: initialize the specList with length dependent on attpackInstanceName", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 if (present(attpackInstanceName)) then 
 specList(3) = trim(attpackInstanceName) 
 count = 4 
 else 
 specList(3) = "" 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackGet(field%ftypep%base, lattpack, & 
 count, specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetAttPack 
!------------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPackSL" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_FieldAttGetAttPackSL(field, & 
 specList, keywordEnforcer, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="field" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if (size(specList) > 4) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackGet(field%ftypep%base, lattpack, & 
 size(lens), specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetAttPackSL 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStd" 
 
!BOPI 
! !IROUTINE: AttAddPackStd - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldAttAddPackStd(field, convention, purpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j ! Error status 
 character (len=*), parameter :: object="field" 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (.not.((convention.eq."ESG" .and.purpose.eq."General").or. & 
 (convention.eq."ESMF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."Extended").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."grids").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."grids").or. & 
 (convention.eq."CIM 1.5".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.5".and.purpose.eq."Inputs").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."Inputs").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."Inputs"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute package convention and purpose values", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackCreateStandard(field%ftypep%base, & 
 size(lens), specString, lens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_FieldAttGetAttPackSL(field, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldAttAddPackCst(field, convention, purpose, attrList, & 
 count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt convention} and {\tt purpose} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 type(ESMF_AttPack) :: lattpack 
 logical :: lispresent, lredundant 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 call ESMF_FieldAttAddPackCstSL(field, specList, attrList, & 
 count=localcount, redundant=lredundant, & 
 attpack=lattpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldAttAddPackCstN(field, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="field" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(field%ftypep%base, size(lens), specString, lens, & 
 localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(field%ftypep%base, attrList(i), & 
 size(lens), specString, lens, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_FieldAttGetAttPackSL(field, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldAttAddPackCstN1(field, convention, purpose, attrList, & 
 count, nestConvention, nestPurpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribvute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_FieldAttAddPackCstN(field, & 
 convention, purpose, & 
 attrList, count, & 
 nestConvString, nestPurpString, & 
 nestCount=1, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttAddPackCstN1
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStdSL" 
 
!BOPI 
! !IROUTINE: AttAddPackStdSL - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldAttAddPackStdSL(field, specList, keywordEnforcer, & 
 attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j ! Error status 
 character (len=*), parameter :: object="field" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (.not.((specList(1).eq."ESG" .and.specList(2).eq."General").or. & 
 (specList(1).eq."ESMF" .and.specList(2).eq."General").or. & 
 (specList(1).eq."CF" .and.specList(2).eq."General").or. & 
 (specList(1).eq."CF" .and.specList(2).eq."Extended").or. & 
 (specList(1).eq."CIM 1.5.1".and.specList(2).eq."grids").or. & 
 (specList(1).eq."CIM 1.7.1".and.specList(2).eq."grids").or. & 
 (specList(1).eq."CIM 1.5" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.5.1" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.7.1" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.5" .and.specList(2).eq."Inputs").or. & 
 (specList(1).eq."CIM 1.5.1" .and.specList(2).eq."Inputs").or. & 
 (specList(1).eq."CIM 1.7.1" .and.specList(2).eq."Inputs"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute packages", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 ! create the attribute package 
 call c_ESMC_AttPackCreateStandard(field%ftypep%base, & 
 size(lens), specString, lens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! retrieve the optional attribute package handle 
 if (present(attpack)) then 
 
 call ESMF_FieldAttGetAttPackSL(field, specList, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttAddPackStdSL
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstSL" 
!BOPI 
! !IROUTINE: AttAddPackCstSL - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldAttAddPackCstSL(field, specList, attrList, & 
 keywordEnforcer, count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), dimension(:), intent(in) :: specList 
 character (len = *), dimension(:), intent(in) :: attrList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! convention, purpose, and instancename. 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt specList} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack}]] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=*), parameter :: object="field" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 logical :: attpackpresent, lredundant 
 logical :: lispresent, createnewattpack, addtoattpack 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 lispresent = .false. 
 createnewattpack = .false. 
 addtoattpack = .false. 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 ! verify that the count and number of attribute names are reasonable 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if ( lredundant .eqv. .true. ) then 
 createnewattpack = .true. 
 else 
 call ESMF_FieldAttGetAttPackSL(field, specList, attpack=lattpack, & 
 isPresent=lispresent, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lispresent .eqv. .false.) then 
 createnewattpack = .true. 
 else 
 addtoattpack = .true. 
 endif 
 endif 
 
 if ( createnewattpack .eqv. .true. ) then 
 call c_ESMC_AttPackCreateCustom(field%ftypep%base, & 
 size(lens), specString, lens, & 
 lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 else if ( addtoattpack .eqv. .true. ) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 endif 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttAddPackCstSL
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttributeCopy" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy between objects 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeCopy() 
 subroutine ESMF_FieldAttCopy(field1, field2, attcopy, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(in) :: field1 
 type(ESMF_Field), intent(inout) :: field2 
 type(ESMF_AttCopy_Flag), intent(in), optional :: attcopy 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Copy all Attributes in one hierarchy to another. 
! 
! The arguments are: 
! \begin{description} 
! \item [field1] 
! An {\tt ESMF_Field} object. 
! \item [field2] 
! An {\tt ESMF_Field} object. 
! \item [attcopyflag] 
! A flag to determine if the copy is to be by reference, value, or hybrid 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 
 character(ESMF_MAXSTR) :: value 
 integer, dimension(1) :: lens 
 type(ESMF_AttCopy_Flag) :: localattcopy 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field1,rc) 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field2,rc) 
 
 ! set copy flag default 
 localattcopy = ESMF_ATTCOPY_VALUE 
 if (present(attcopy)) then 
 localattcopy = attcopy 
 endif 
 
 call c_ESMC_AttributeCopy(field1%ftypep%base, field2%ftypep%base, & 
 localattcopy, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttCopy 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetAPI1(field, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetI1(field, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetI1 
!------------------------------------------------------------------------------ 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetAPI2(field, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetI2(field, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetI2 
!------------------------------------------------------------------------------ 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetAPI4(field, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetI4(field, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetI4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetAPI8(field, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetI8(field, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetI8 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetAPR4(field, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetR4(field, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetR4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetAPR8(field, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetR8(field, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetR8 
!------------------------------------------------------------------------------ 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DAPI1(field, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_I1, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DAPI1 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DI1(field, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_I1, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DAPI2(field, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_I2, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DAPI2 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DI2(field, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_I2, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DAPI4(field, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_I4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DAPI4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DI4(field, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_I4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DAPI8(field, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_I8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DAPI8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DI8(field, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_I8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DAPR4(field, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_R4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DAPR4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DR4(field, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_R4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DAPR8(field, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_R8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DAPR8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DR8(field, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Field), intent(in) :: field 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_R8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetLgclAP(field, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, localvalue 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetLgcl(field, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetLgclListAP(field, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(in) :: field 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetLgclList(field, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(in) :: field 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetCharAP(field, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len = *), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_FieldAttGetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetChar(field, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, & 
 lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(field%ftypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_FieldAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetCharListAP(field, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len=*), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetCharList(field, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(field%ftypep%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(field%ftypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetCount(field, count, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(in) :: field 
 integer, intent(out) :: count 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given Attribute 
! package in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_Logical) :: isAttpack 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, & 
 attPackInstanceName=attPackInstanceName, & 
 attpack=attpack, attnestflag=lattnestflag, & 
 rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, & 
 lattcountflag, lattnestflag, & 
 localrc) 
 else 
 call c_ESMC_AttributeGetCount(field%ftypep%base, count, lattcountflag, & 
 localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetCount 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCountAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetCountAttPack(field, attpack, count, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(in) :: field 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, lattcountflag, & 
 lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetCountAttPack 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetInfoByNamAP(field, name, attpack, & 
 keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(in) :: field 
 character(len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(field%ftypep%base, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetInfoByNamAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetInfoByNam(field, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(in) :: field 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}.
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(field%ftypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(field%ftypep%base, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNumAP" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetInfoByNumAP(field, attributeIndex, attpack, & 
 name, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(in) :: field 
 integer, intent(in) :: attributeIndex 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character(len=*), intent(out) :: name 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentIndex(field%ftypep%base, attributeIndex, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(field%ftypep%base, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetInfoByNumAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetInfoByNum(field, attributeIndex, name, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(in) :: field 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentIndex(field%ftypep%base, attributeIndex, & 
 attpack, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(field%ftypep%base, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresentIndex(field%ftypep%base, attributeIndex, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoNum(field%ftypep%base, attributeIndex, & 
 localName, localTk, & 
 litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetInfoByNum 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_FieldAttLinkGrid(field, grid, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 type(ESMF_Grid), intent(in) :: grid 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(& 
 field%ftypep%base, grid, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttLinkGrid 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_FieldAttLinkLocStream(field, locStream, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 type(ESMF_LocStream), intent(in) :: locStream 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item [locStream] 
! An {\tt ESMF_LocStream} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locStream,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(& 
 field%ftypep%base, locStream%lstypep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttLinkLocStream 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_FieldAttLinkRmGrid(field, grid, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 type(ESMF_Grid), intent(in) :: grid 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 field%ftypep%base, grid, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttLinkRmGrid 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_FieldAttLinkRmLocStream(field, locStream, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 type(ESMF_LocStream), intent(in) :: locStream 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item [locStream] 
! An {\tt ESMF_LocStream} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locStream,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 field%ftypep%base, locStream%lstypep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttLinkRmLocStream 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_FieldAttRead(field, fileName, schemaFileName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len=*), intent(in), optional :: fileName 
 character (len=*), intent(in), optional :: schemaFileName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt field}. 
! The Attribute package defines the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item [{[fileName]}] 
! The file name to read from. 
! \item [{[schemaFileName]}] 
! The name of the XSD file to validate fileName. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, schemaFileNameLen, localrc 
 
 fileNameLen = 0 
 schemaFileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 ! get length of given fileNames for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 if (present(schemaFileName)) then 
 schemaFileNameLen = len_trim(schemaFileName) 
 end if 
 
 ! invoke C to C++ entry point 
 call c_ESMC_AttributeRead(field%ftypep%base, fileNameLen, fileName, & 
 schemaFileNameLen, schemaFileName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttRead 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package using an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_FieldAttRemoveAP(field, keywordEnforcer, name, & 
 attpack, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(field%ftypep%base, name, attpack, & 
 lattnestflag, localrc) 
 else 
 call c_ESMC_AttPackRemove(field%ftypep%base, attpack, localrc) 
 ESMF_INIT_SET_DELETED(attpack) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttRemoveAP 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_FieldAttRemove(field, name, convention, purpose, & 
 attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpackobj 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemove(field%ftypep%base, attpackobj, lattnestflag, localrc) 
 ESMF_INIT_SET_DELETED(attpackobj) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemoveAttribute(field%ftypep%base, name, attpackobj, & 
 lattnestflag, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(field%ftypep%base, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetAPI1(field, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetAPI1 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetI1(field, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DAPI1(field, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DI1(field, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetAPI2(field, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetAPI2 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetI2(field, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DAPI2(field, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DI2(field, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetAPI4(field, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetAPI4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetI4(field, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DAPI4(field, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DI4(field, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetAPI8(field, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetAPI8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetI8(field, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DAPI8(field, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DI8(field, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetAPR4(field, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetAPR4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetR4(field, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DAPR4(field, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DR4(field, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetAPR8(field, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetAPR8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetR8(field, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DAPR8(field, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DR8(field, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetLgclAP(field, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 localvalue = value 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetLgcl(field, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented, 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetLgclListAP(field, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetLgclList(field, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetCharAP(field, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 lens(1) = len_trim(value) 
 count = 1 
 
 call c_ESMC_AttPackSetCharList(field%ftypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetChar(field, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(field%ftypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(field%ftypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetCharListAP(field, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackSetCharList(field%ftypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetCharList(field, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_FieldAttGetAttPack(field, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(field%ftypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(field%ftypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_FieldAttUpdate(field, vm, rootList, reconcile, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 logical, intent(in), optional :: reconcile 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item [vm] 
! The virtual machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of PETs that are to be used to as the source of the update. 
! \item [{[reconcile]}] 
! A logical flag used to indicate whether to use reconcile behavior or 
! normal update behavior. If {\tt reconcile} is set to {\tt ESMF\_TRUE} 
! then the values of the root PETs will be sent to the nonroot PETs without 
! exception. Otherwise, an algorithm that is optimized to use minimal 
! memory will be used to update only the modified parts of the Attribute 
! hierarchy on the nonroot PETs. The default value is {\tt ESMF\_FALSE}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 type(ESMF_Logical) :: local_reconcile 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 ! reconcile 
 if ( present(reconcile)) then 
 local_reconcile = reconcile 
 else 
 local_reconcile = ESMF_FALSE 
 endif 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(field%ftypep%base, vm, rootList, count, & 
 local_reconcile, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_FieldAttWrite(field, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_Field), intent(in) :: field 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! This call is collective across the current VM. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, petCount, localPet 
 character(len=*), parameter :: object="field" 
 character(len=*), parameter :: ftarobj="field" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 type(ESMF_VM) :: vm 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 call ESMF_VMGetCurrent(vm, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localPet == 0) then 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttributeWrite(field%ftypep%base, convention, & 
 purpose, object, ftarobj, writeflag, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 call ESMF_VMBarrier(vm, rc=rc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttWrite 

!-------------------------------------------------------------------------
! ARRAYBUNDLE
!-------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, keywordEnforcer, attPackInstanceName, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object.
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, count 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="arraybundle" 
 type(ESMF_AttPack) :: lattpack 
 character(len=max(len(convention), len(purpose))), dimension(3) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 count = 3 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! guard against a situation which cannot be prevented with the use of optional arguments 
 if (present(attpackInstanceName)) then 
 if (len(attpackInstanceName) > max(len(convention), len(purpose))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="TODO: initialize the specList with length dependent on attpackInstanceName", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 if (present(attpackInstanceName)) then 
 specList(3) = trim(attpackInstanceName) 
 count = 4 
 else 
 specList(3) = "" 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackGet(arraybundle, lattpack, & 
 count, specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetAttPack 
!------------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPackSL" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_ArrayBundleAttGetAttPackSL(arraybundle, & 
 specList, keywordEnforcer, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="arraybundle" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if (size(specList) > 4) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackGet(arraybundle, lattpack, & 
 size(lens), specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetAttPackSL 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayBundleAttAddPackCst(arraybundle, convention, purpose, attrList, & 
 count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt convention} and {\tt purpose} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 type(ESMF_AttPack) :: lattpack 
 logical :: lispresent, lredundant 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 call ESMF_ArrayBundleAttAddPackCstSL(arraybundle, specList, attrList, & 
 count=localcount, redundant=lredundant, & 
 attpack=lattpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayBundleAttAddPackCstN(arraybundle, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="arraybundle" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(arraybundle, size(lens), specString, lens, & 
 localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(arraybundle, attrList(i), & 
 size(lens), specString, lens, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_ArrayBundleAttGetAttPackSL(arraybundle, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayBundleAttAddPackCstN1(arraybundle, convention, purpose, attrList, & 
 count, nestConvention, nestPurpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribvute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_ArrayBundleAttAddPackCstN(arraybundle, & 
 convention, purpose, & 
 attrList, count, & 
 nestConvString, nestPurpString, & 
 nestCount=1, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttAddPackCstN1
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstSL" 
!BOPI 
! !IROUTINE: AttAddPackCstSL - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayBundleAttAddPackCstSL(arraybundle, specList, attrList, & 
 keywordEnforcer, count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), dimension(:), intent(in) :: specList 
 character (len = *), dimension(:), intent(in) :: attrList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! convention, purpose, and instancename. 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt specList} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack}]] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=*), parameter :: object="arraybundle" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 logical :: attpackpresent, lredundant 
 logical :: lispresent, createnewattpack, addtoattpack 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 lispresent = .false. 
 createnewattpack = .false. 
 addtoattpack = .false. 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 ! verify that the count and number of attribute names are reasonable 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if ( lredundant .eqv. .true. ) then 
 createnewattpack = .true. 
 else 
 call ESMF_ArrayBundleAttGetAttPackSL(arraybundle, specList, attpack=lattpack, & 
 isPresent=lispresent, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lispresent .eqv. .false.) then 
 createnewattpack = .true. 
 else 
 addtoattpack = .true. 
 endif 
 endif 
 
 if ( createnewattpack .eqv. .true. ) then 
 call c_ESMC_AttPackCreateCustom(arraybundle, & 
 size(lens), specString, lens, & 
 lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 else if ( addtoattpack .eqv. .true. ) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 endif 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttAddPackCstSL
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package using an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_ArrayBundleAttRemoveAP(arraybundle, keywordEnforcer, name, & 
 attpack, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(arraybundle, name, attpack, & 
 lattnestflag, localrc) 
 else 
 call c_ESMC_AttPackRemove(arraybundle, attpack, localrc) 
 ESMF_INIT_SET_DELETED(attpack) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttRemoveAP 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_ArrayBundleAttRemove(arraybundle, name, convention, purpose, & 
 attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpackobj 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemove(arraybundle, attpackobj, lattnestflag, localrc) 
 ESMF_INIT_SET_DELETED(attpackobj) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemoveAttribute(arraybundle, name, attpackobj, & 
 lattnestflag, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(arraybundle, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetAPI1(arraybundle, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetI1(arraybundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetI1 
!------------------------------------------------------------------------------ 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetAPI2(arraybundle, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetI2(arraybundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetI2 
!------------------------------------------------------------------------------ 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetAPI4(arraybundle, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetI4(arraybundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetI4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetAPI8(arraybundle, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetI8(arraybundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetI8 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetAPR4(arraybundle, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetR4(arraybundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetR4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetAPR8(arraybundle, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetR8(arraybundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetR8 
!------------------------------------------------------------------------------ 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DAPI1(arraybundle, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_I1, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DAPI1 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DI1(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_I1, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DAPI2(arraybundle, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_I2, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DAPI2 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DI2(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_I2, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DAPI4(arraybundle, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_I4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DAPI4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DI4(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_I4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DAPI8(arraybundle, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_I8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DAPI8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DI8(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_I8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DAPR4(arraybundle, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_R4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DAPR4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DR4(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_R4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DAPR8(arraybundle, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_R8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DAPR8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DR8(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_R8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetLgclAP(arraybundle, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, localvalue 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetLgcl(arraybundle, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetLgclListAP(arraybundle, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetLgclList(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetCharAP(arraybundle, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len = *), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_ArrayBundleAttGetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetChar(arraybundle, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, & 
 lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(arraybundle, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_ArrayBundleAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetCharListAP(arraybundle, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len=*), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetCharList(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(arraybundle, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(arraybundle, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetCount(arraybundle, count, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 integer, intent(out) :: count 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given Attribute 
! package in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_Logical) :: isAttpack 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, & 
 attPackInstanceName=attPackInstanceName, & 
 attpack=attpack, attnestflag=lattnestflag, & 
 rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, & 
 lattcountflag, lattnestflag, & 
 localrc) 
 else 
 call c_ESMC_AttributeGetCount(arraybundle, count, lattcountflag, & 
 localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetCount 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCountAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetCountAttPack(arraybundle, attpack, count, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, lattcountflag, & 
 lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetCountAttPack 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetInfoByNamAP(arraybundle, name, attpack, & 
 keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character(len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(arraybundle, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetInfoByNamAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetInfoByNam(arraybundle, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}.
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(arraybundle, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(arraybundle, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNumAP" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetInfoByNumAP(arraybundle, attributeIndex, attpack, & 
 name, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 integer, intent(in) :: attributeIndex 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character(len=*), intent(out) :: name 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentIndex(arraybundle, attributeIndex, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(arraybundle, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetInfoByNumAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetInfoByNum(arraybundle, attributeIndex, name, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentIndex(arraybundle, attributeIndex, & 
 attpack, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(arraybundle, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresentIndex(arraybundle, attributeIndex, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoNum(arraybundle, attributeIndex, & 
 localName, localTk, & 
 litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetInfoByNum 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_ArrayBundleAttLinkArray(arraybundle, array, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 type(ESMF_Array), intent(in) :: array 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An {\tt ESMF_ArrayBundle} object. 
! \item [array] 
! An {\tt ESMF_Array} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(& 
 arraybundle, array, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttLinkArray 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_ArrayBundleAttLinkRmArray(arraybundle, array, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 type(ESMF_Array), intent(in) :: array 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An {\tt ESMF_ArrayBundle} object. 
! \item [array] 
! An {\tt ESMF_Array} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 arraybundle, array, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttLinkRmArray 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetAPI1(arraybundle, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetAPI1 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetI1(arraybundle, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DAPI1(arraybundle, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DI1(arraybundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetAPI2(arraybundle, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetAPI2 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetI2(arraybundle, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DAPI2(arraybundle, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DI2(arraybundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetAPI4(arraybundle, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetAPI4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetI4(arraybundle, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DAPI4(arraybundle, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DI4(arraybundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetAPI8(arraybundle, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetAPI8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetI8(arraybundle, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DAPI8(arraybundle, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DI8(arraybundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetAPR4(arraybundle, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetAPR4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetR4(arraybundle, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DAPR4(arraybundle, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DR4(arraybundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetAPR8(arraybundle, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetAPR8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetR8(arraybundle, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DAPR8(arraybundle, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DR8(arraybundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetLgclAP(arraybundle, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 localvalue = value 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetLgcl(arraybundle, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented, 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetLgclListAP(arraybundle, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetLgclList(arraybundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetCharAP(arraybundle, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 lens(1) = len_trim(value) 
 count = 1 
 
 call c_ESMC_AttPackSetCharList(arraybundle, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetChar(arraybundle, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(arraybundle, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(arraybundle, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetCharListAP(arraybundle, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackSetCharList(arraybundle, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetCharList(arraybundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayBundleAttGetAttPack(arraybundle, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(arraybundle, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(arraybundle, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_ArrayBundleAttUpdate(arraybundle, vm, rootList, reconcile, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 logical, intent(in), optional :: reconcile 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An {\tt ESMF_ArrayBundle} object. 
! \item [vm] 
! The virtual machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of PETs that are to be used to as the source of the update. 
! \item [{[reconcile]}] 
! A logical flag used to indicate whether to use reconcile behavior or 
! normal update behavior. If {\tt reconcile} is set to {\tt ESMF\_TRUE} 
! then the values of the root PETs will be sent to the nonroot PETs without 
! exception. Otherwise, an algorithm that is optimized to use minimal 
! memory will be used to update only the modified parts of the Attribute 
! hierarchy on the nonroot PETs. The default value is {\tt ESMF\_FALSE}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 type(ESMF_Logical) :: local_reconcile 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 ! reconcile 
 if ( present(reconcile)) then 
 local_reconcile = reconcile 
 else 
 local_reconcile = ESMF_FALSE 
 endif 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(arraybundle, vm, rootList, count, & 
 local_reconcile, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_ArrayBundleAttWrite(arraybundle, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(in) :: arraybundle 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! This call is collective across the current VM. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An {\tt ESMF_ArrayBundle} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, petCount, localPet 
 character(len=*), parameter :: object="arraybundle" 
 character(len=*), parameter :: ftarobj="array" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 type(ESMF_VM) :: vm 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 call ESMF_VMGetCurrent(vm, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localPet == 0) then 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttributeWrite(arraybundle, convention, & 
 purpose, object, ftarobj, writeflag, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 call ESMF_VMBarrier(vm, rc=rc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttWrite 

!-------------------------------------------------------------------------
! ARRAY
!-------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, keywordEnforcer, attPackInstanceName, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object.
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, count 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="array" 
 type(ESMF_AttPack) :: lattpack 
 character(len=max(len(convention), len(purpose))), dimension(3) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 count = 3 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! guard against a situation which cannot be prevented with the use of optional arguments 
 if (present(attpackInstanceName)) then 
 if (len(attpackInstanceName) > max(len(convention), len(purpose))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="TODO: initialize the specList with length dependent on attpackInstanceName", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 if (present(attpackInstanceName)) then 
 specList(3) = trim(attpackInstanceName) 
 count = 4 
 else 
 specList(3) = "" 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackGet(array, lattpack, & 
 count, specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetAttPack 
!------------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPackSL" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_ArrayAttGetAttPackSL(array, & 
 specList, keywordEnforcer, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="array" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if (size(specList) > 4) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackGet(array, lattpack, & 
 size(lens), specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetAttPackSL 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayAttAddPackCst(array, convention, purpose, attrList, & 
 count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt convention} and {\tt purpose} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 type(ESMF_AttPack) :: lattpack 
 logical :: lispresent, lredundant 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 call ESMF_ArrayAttAddPackCstSL(array, specList, attrList, & 
 count=localcount, redundant=lredundant, & 
 attpack=lattpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayAttAddPackCstN(array, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="array" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(array, size(lens), specString, lens, & 
 localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(array, attrList(i), & 
 size(lens), specString, lens, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_ArrayAttGetAttPackSL(array, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayAttAddPackCstN1(array, convention, purpose, attrList, & 
 count, nestConvention, nestPurpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribvute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_ArrayAttAddPackCstN(array, & 
 convention, purpose, & 
 attrList, count, & 
 nestConvString, nestPurpString, & 
 nestCount=1, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttAddPackCstN1
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStd" 
 
!BOPI 
! !IROUTINE: AttAddPackStd - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayAttAddPackStd(array, convention, purpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An {\tt ESMF_Array} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j ! Error status 
 character (len=*), parameter :: object="array" 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (.not.((convention.eq."ESG" .and.purpose.eq."General").or. & 
 (convention.eq."ESMF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."Extended").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."grids").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."grids").or. & 
 (convention.eq."CIM 1.5".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.5".and.purpose.eq."Inputs").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."Inputs").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."Inputs"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute package convention and purpose values", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackCreateStandard(array, & 
 size(lens), specString, lens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_ArrayAttGetAttPackSL(array, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstSL" 
!BOPI 
! !IROUTINE: AttAddPackCstSL - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayAttAddPackCstSL(array, specList, attrList, & 
 keywordEnforcer, count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), dimension(:), intent(in) :: specList 
 character (len = *), dimension(:), intent(in) :: attrList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! convention, purpose, and instancename. 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt specList} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack}]] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=*), parameter :: object="array" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 logical :: attpackpresent, lredundant 
 logical :: lispresent, createnewattpack, addtoattpack 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 lispresent = .false. 
 createnewattpack = .false. 
 addtoattpack = .false. 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 ! verify that the count and number of attribute names are reasonable 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if ( lredundant .eqv. .true. ) then 
 createnewattpack = .true. 
 else 
 call ESMF_ArrayAttGetAttPackSL(array, specList, attpack=lattpack, & 
 isPresent=lispresent, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lispresent .eqv. .false.) then 
 createnewattpack = .true. 
 else 
 addtoattpack = .true. 
 endif 
 endif 
 
 if ( createnewattpack .eqv. .true. ) then 
 call c_ESMC_AttPackCreateCustom(array, & 
 size(lens), specString, lens, & 
 lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 else if ( addtoattpack .eqv. .true. ) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 endif 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttAddPackCstSL
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStdSL" 
 
!BOPI 
! !IROUTINE: AttAddPackStdSL - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayAttAddPackStdSL(array, specList, keywordEnforcer, & 
 attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An {\tt ESMF_Array} object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j ! Error status 
 character (len=*), parameter :: object="array" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (.not.((specList(1).eq."ESG" .and.specList(2).eq."General").or. & 
 (specList(1).eq."ESMF" .and.specList(2).eq."General").or. & 
 (specList(1).eq."CF" .and.specList(2).eq."General").or. & 
 (specList(1).eq."CF" .and.specList(2).eq."Extended").or. & 
 (specList(1).eq."CIM 1.5.1".and.specList(2).eq."grids").or. & 
 (specList(1).eq."CIM 1.7.1".and.specList(2).eq."grids").or. & 
 (specList(1).eq."CIM 1.5" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.5.1" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.7.1" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.5" .and.specList(2).eq."Inputs").or. & 
 (specList(1).eq."CIM 1.5.1" .and.specList(2).eq."Inputs").or. & 
 (specList(1).eq."CIM 1.7.1" .and.specList(2).eq."Inputs"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute packages", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 ! create the attribute package 
 call c_ESMC_AttPackCreateStandard(array, & 
 size(lens), specString, lens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! retrieve the optional attribute package handle 
 if (present(attpack)) then 
 
 call ESMF_ArrayAttGetAttPackSL(array, specList, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttAddPackStdSL
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package using an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_ArrayAttRemoveAP(array, keywordEnforcer, name, & 
 attpack, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(array, name, attpack, & 
 lattnestflag, localrc) 
 else 
 call c_ESMC_AttPackRemove(array, attpack, localrc) 
 ESMF_INIT_SET_DELETED(attpack) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttRemoveAP 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_ArrayAttRemove(array, name, convention, purpose, & 
 attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpackobj 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemove(array, attpackobj, lattnestflag, localrc) 
 ESMF_INIT_SET_DELETED(attpackobj) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemoveAttribute(array, name, attpackobj, & 
 lattnestflag, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(array, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetAPI1(array, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetI1(array, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetI1 
!------------------------------------------------------------------------------ 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetAPI2(array, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetI2(array, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetI2 
!------------------------------------------------------------------------------ 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetAPI4(array, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetI4(array, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetI4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetAPI8(array, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetI8(array, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetI8 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetAPR4(array, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetR4(array, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetR4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetAPR8(array, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetR8(array, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetR8 
!------------------------------------------------------------------------------ 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DAPI1(array, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_I1, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DAPI1 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DI1(array, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_I1, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DAPI2(array, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_I2, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DAPI2 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DI2(array, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_I2, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DAPI4(array, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_I4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DAPI4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DI4(array, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_I4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DAPI8(array, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_I8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DAPI8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DI8(array, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_I8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DAPR4(array, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_R4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DAPR4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DR4(array, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_R4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DAPR8(array, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_R8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DAPR8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DR8(array, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Array), intent(in) :: array 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_R8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetLgclAP(array, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, localvalue 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetLgcl(array, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetLgclListAP(array, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(in) :: array 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetLgclList(array, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(in) :: array 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetCharAP(array, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len = *), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(array, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_ArrayAttGetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetChar(array, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(array, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, & 
 lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(array, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_ArrayAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetCharListAP(array, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len=*), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(array, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetCharList(array, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(array, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(array, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetCount(array, count, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(in) :: array 
 integer, intent(out) :: count 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given Attribute 
! package in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_Logical) :: isAttpack 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, & 
 attPackInstanceName=attPackInstanceName, & 
 attpack=attpack, attnestflag=lattnestflag, & 
 rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, & 
 lattcountflag, lattnestflag, & 
 localrc) 
 else 
 call c_ESMC_AttributeGetCount(array, count, lattcountflag, & 
 localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetCount 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCountAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetCountAttPack(array, attpack, count, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(in) :: array 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, lattcountflag, & 
 lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetCountAttPack 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetInfoByNamAP(array, name, attpack, & 
 keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(in) :: array 
 character(len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(array, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetInfoByNamAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetInfoByNam(array, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(in) :: array 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}.
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(array, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(array, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(array, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNumAP" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetInfoByNumAP(array, attributeIndex, attpack, & 
 name, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(in) :: array 
 integer, intent(in) :: attributeIndex 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character(len=*), intent(out) :: name 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentIndex(array, attributeIndex, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(array, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetInfoByNumAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetInfoByNum(array, attributeIndex, name, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(in) :: array 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentIndex(array, attributeIndex, & 
 attpack, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(array, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresentIndex(array, attributeIndex, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoNum(array, attributeIndex, & 
 localName, localTk, & 
 litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetInfoByNum 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetAPI1(array, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetAPI1 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetI1(array, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DAPI1(array, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DI1(array, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetAPI2(array, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetAPI2 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetI2(array, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DAPI2(array, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DI2(array, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetAPI4(array, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetAPI4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetI4(array, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DAPI4(array, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DI4(array, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetAPI8(array, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetAPI8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetI8(array, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DAPI8(array, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DI8(array, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetAPR4(array, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetAPR4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetR4(array, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DAPR4(array, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DR4(array, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetAPR8(array, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetAPR8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetR8(array, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DAPR8(array, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DR8(array, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetLgclAP(array, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 localvalue = value 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetLgcl(array, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented, 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetLgclListAP(array, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetLgclList(array, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetCharAP(array, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 lens(1) = len_trim(value) 
 count = 1 
 
 call c_ESMC_AttPackSetCharList(array, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetChar(array, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(array, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(array, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetCharListAP(array, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackSetCharList(array, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetCharList(array, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_ArrayAttGetAttPack(array, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(array, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(array, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_ArrayAttUpdate(array, vm, rootList, reconcile, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 logical, intent(in), optional :: reconcile 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An {\tt ESMF_Array} object. 
! \item [vm] 
! The virtual machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of PETs that are to be used to as the source of the update. 
! \item [{[reconcile]}] 
! A logical flag used to indicate whether to use reconcile behavior or 
! normal update behavior. If {\tt reconcile} is set to {\tt ESMF\_TRUE} 
! then the values of the root PETs will be sent to the nonroot PETs without 
! exception. Otherwise, an algorithm that is optimized to use minimal 
! memory will be used to update only the modified parts of the Attribute 
! hierarchy on the nonroot PETs. The default value is {\tt ESMF\_FALSE}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 type(ESMF_Logical) :: local_reconcile 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 ! reconcile 
 if ( present(reconcile)) then 
 local_reconcile = reconcile 
 else 
 local_reconcile = ESMF_FALSE 
 endif 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(array, vm, rootList, count, & 
 local_reconcile, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_ArrayAttWrite(array, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_Array), intent(in) :: array 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! This call is collective across the current VM. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An {\tt ESMF_Array} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, petCount, localPet 
 character(len=*), parameter :: object="array" 
 character(len=*), parameter :: ftarobj="array" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 type(ESMF_VM) :: vm 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 call ESMF_VMGetCurrent(vm, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localPet == 0) then 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttributeWrite(array, convention, & 
 purpose, object, ftarobj, writeflag, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 call ESMF_VMBarrier(vm, rc=rc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttWrite 

!-------------------------------------------------------------------------
! GRID
!-------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, keywordEnforcer, attPackInstanceName, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_Grid), intent(in) :: grid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object.
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, count 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="grid" 
 type(ESMF_AttPack) :: lattpack 
 character(len=max(len(convention), len(purpose))), dimension(3) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 count = 3 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! guard against a situation which cannot be prevented with the use of optional arguments 
 if (present(attpackInstanceName)) then 
 if (len(attpackInstanceName) > max(len(convention), len(purpose))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="TODO: initialize the specList with length dependent on attpackInstanceName", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 if (present(attpackInstanceName)) then 
 specList(3) = trim(attpackInstanceName) 
 count = 4 
 else 
 specList(3) = "" 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackGet(grid, lattpack, & 
 count, specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetAttPack 
!------------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPackSL" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_GridAttGetAttPackSL(grid, & 
 specList, keywordEnforcer, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_Grid), intent(in) :: grid 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="grid" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if (size(specList) > 4) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackGet(grid, lattpack, & 
 size(lens), specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetAttPackSL 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStd" 
 
!BOPI 
! !IROUTINE: AttAddPackStd - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridAttAddPackStd(grid, convention, purpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j ! Error status 
 character (len=*), parameter :: object="grid" 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (.not.((convention.eq."ESG" .and.purpose.eq."General").or. & 
 (convention.eq."ESMF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."Extended").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."grids").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."grids").or. & 
 (convention.eq."CIM 1.5".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.5".and.purpose.eq."Inputs").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."Inputs").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."Inputs"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute package convention and purpose values", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackCreateStandard(grid, & 
 size(lens), specString, lens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_GridAttGetAttPackSL(grid, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridAttAddPackCst(grid, convention, purpose, attrList, & 
 count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt convention} and {\tt purpose} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 type(ESMF_AttPack) :: lattpack 
 logical :: lispresent, lredundant 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 call ESMF_GridAttAddPackCstSL(grid, specList, attrList, & 
 count=localcount, redundant=lredundant, & 
 attpack=lattpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridAttAddPackCstN(grid, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="grid" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(grid, size(lens), specString, lens, & 
 localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(grid, attrList(i), & 
 size(lens), specString, lens, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_GridAttGetAttPackSL(grid, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridAttAddPackCstN1(grid, convention, purpose, attrList, & 
 count, nestConvention, nestPurpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribvute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_GridAttAddPackCstN(grid, & 
 convention, purpose, & 
 attrList, count, & 
 nestConvString, nestPurpString, & 
 nestCount=1, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttAddPackCstN1
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStdSL" 
 
!BOPI 
! !IROUTINE: AttAddPackStdSL - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridAttAddPackStdSL(grid, specList, keywordEnforcer, & 
 attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j ! Error status 
 character (len=*), parameter :: object="grid" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (.not.((specList(1).eq."ESG" .and.specList(2).eq."General").or. & 
 (specList(1).eq."ESMF" .and.specList(2).eq."General").or. & 
 (specList(1).eq."CF" .and.specList(2).eq."General").or. & 
 (specList(1).eq."CF" .and.specList(2).eq."Extended").or. & 
 (specList(1).eq."CIM 1.5.1".and.specList(2).eq."grids").or. & 
 (specList(1).eq."CIM 1.7.1".and.specList(2).eq."grids").or. & 
 (specList(1).eq."CIM 1.5" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.5.1" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.7.1" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.5" .and.specList(2).eq."Inputs").or. & 
 (specList(1).eq."CIM 1.5.1" .and.specList(2).eq."Inputs").or. & 
 (specList(1).eq."CIM 1.7.1" .and.specList(2).eq."Inputs"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute packages", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 ! create the attribute package 
 call c_ESMC_AttPackCreateStandard(grid, & 
 size(lens), specString, lens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! retrieve the optional attribute package handle 
 if (present(attpack)) then 
 
 call ESMF_GridAttGetAttPackSL(grid, specList, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttAddPackStdSL
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstSL" 
!BOPI 
! !IROUTINE: AttAddPackCstSL - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridAttAddPackCstSL(grid, specList, attrList, & 
 keywordEnforcer, count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), dimension(:), intent(in) :: specList 
 character (len = *), dimension(:), intent(in) :: attrList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! convention, purpose, and instancename. 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt specList} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack}]] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=*), parameter :: object="grid" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 logical :: attpackpresent, lredundant 
 logical :: lispresent, createnewattpack, addtoattpack 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 lispresent = .false. 
 createnewattpack = .false. 
 addtoattpack = .false. 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 ! verify that the count and number of attribute names are reasonable 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if ( lredundant .eqv. .true. ) then 
 createnewattpack = .true. 
 else 
 call ESMF_GridAttGetAttPackSL(grid, specList, attpack=lattpack, & 
 isPresent=lispresent, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lispresent .eqv. .false.) then 
 createnewattpack = .true. 
 else 
 addtoattpack = .true. 
 endif 
 endif 
 
 if ( createnewattpack .eqv. .true. ) then 
 call c_ESMC_AttPackCreateCustom(grid, & 
 size(lens), specString, lens, & 
 lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 else if ( addtoattpack .eqv. .true. ) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 endif 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttAddPackCstSL
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttributeCopy" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy between objects 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeCopy() 
 subroutine ESMF_GridAttCopy(grid1, grid2, attcopy, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(in) :: grid1 
 type(ESMF_Grid), intent(inout) :: grid2 
 type(ESMF_AttCopy_Flag), intent(in), optional :: attcopy 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Copy all Attributes in one hierarchy to another. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid1] 
! An {\tt ESMF_Grid} object. 
! \item [grid2] 
! An {\tt ESMF_Grid} object. 
! \item [attcopyflag] 
! A flag to determine if the copy is to be by reference, value, or hybrid 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 
 character(ESMF_MAXSTR) :: value 
 integer, dimension(1) :: lens 
 type(ESMF_AttCopy_Flag) :: localattcopy 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid1,rc) 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid2,rc) 
 
 ! set copy flag default 
 localattcopy = ESMF_ATTCOPY_VALUE 
 if (present(attcopy)) then 
 localattcopy = attcopy 
 endif 
 
 call c_ESMC_AttributeCopy(grid1, grid2, & 
 localattcopy, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttCopy 

#ifndef ESMF_NO_INTEGER_1_BYTE
funcname##Macro(integer, I1, ESMF_Grid, grid, grid)
#endif
#ifndef ESMF_NO_INTEGER_2_BYTE
funcname##Macro(integer, I2, ESMF_Grid, grid, grid)
#endif

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetAPI4(grid, name, attpack, value, & 
 keywordEnforcer, defaultvalue, inputList, attnestflag, isPresent, rc) 
 
 type(ESMF_Grid), intent(in) :: grid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 character (len=*), intent(in), optional :: inputList(:) 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[inputList]}] 
! A list of the input parameters required to retrieve internal info. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, i 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 !! TODO: this needs to be dynamically sized !!! 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! Call into routine to retrieve internal class info 
 ! return directly from here if info is found 
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_AttributeGetInfo(grid, name=modName, & 
 value=value, inputList=inputList, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 return 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, & 
 value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetAPI4 
!------------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetI4(grid, name, value, & 
 defaultvalue, inputList, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_Grid), intent(in) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 character (len=*), intent(in), optional :: inputList(:) 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[inputList]}] 
! A list of the input parameters required to retrieve internal info. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 !! TODO: this needs to be dynamically sized !!! 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! Call into routine to retrieve internal class info 
 ! return directly from here if info is found 
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_AttributeGetInfo(grid, name=modName, & 
 value=value, inputList=inputList, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 return 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 if (present(rc)) rc = ESMF_SUCCESS 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetI4 


#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DAPI4(grid, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, inputList, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Grid), intent(in) :: grid 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: inputList(:) 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[inputList]}] 
! A list of the input parameters required to retrieve internal info. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 !! TODO: this needs to be dynamically sized !!! 
 character (len=ESMF_MAXSTR) :: modName 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! Call into routine to retrieve internal class info 
 ! return directly from here if info is found 
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_AttributeGetInfo(grid, name=modName, & 
 valueList=valueList, inputList=inputList, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 return 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_I4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DAPI4 

!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DI4(grid, name, valueList, & 
 defaultvalueList, inputList, convention, purpose, & 
 attPackInstanceName, attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Grid), intent(in) :: grid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: inputList(:) 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attpack]}] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 !! TODO: this needs to be dynamically sized !!! 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! Call into routine to retrieve internal class info 
 ! return directly from here if info is found 
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_AttributeGetInfo(grid, name=modName, & 
 valueList=valueList, inputList=inputList, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 return 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_I4, litemcount, lattnestflag, valueList, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DI4 


#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetAPI8(grid, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_Grid), intent(in) :: grid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetI8(grid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_Grid), intent(in) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetI8 
!------------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DAPI8(grid, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Grid), intent(in) :: grid 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_I8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DAPI8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DI8(grid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Grid), intent(in) :: grid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_I8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DI8 


#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetAPR4(grid, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_Grid), intent(in) :: grid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetR4(grid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_Grid), intent(in) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetR4 
!------------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DAPR4(grid, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, inputList, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Grid), intent(in) :: grid 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: inputList(:) 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[inputList]}] 
! A list of the input parameters required to retrieve internal info. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 !! TODO: this needs to be dynamically sized !!! 
 character (len=ESMF_MAXSTR) :: modName 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! Call into routine to retrieve internal class info 
 ! return directly from here if info is found 
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_AttributeGetInfo(grid, name=modName, & 
 valueList=valueList, inputList=inputList, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 return 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_R4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DAPR4 

!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DR4(grid, name, valueList, & 
 defaultvalueList, inputList, convention, purpose, & 
 attPackInstanceName, attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Grid), intent(in) :: grid 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: inputList(:) 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attpack]}] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 !! TODO: this needs to be dynamically sized !!! 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! Call into routine to retrieve internal class info 
 ! return directly from here if info is found 
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_AttributeGetInfo(grid, name=modName, & 
 valueList=valueList, inputList=inputList, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 return 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_R4, litemcount, lattnestflag, valueList, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DR4 


#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetAPR8(grid, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_Grid), intent(in) :: grid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetR8(grid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_Grid), intent(in) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetR8 
!------------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DAPR8(grid, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, inputList, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Grid), intent(in) :: grid 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: inputList(:) 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[inputList]}] 
! A list of the input parameters required to retrieve internal info. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 !! TODO: this needs to be dynamically sized !!! 
 character (len=ESMF_MAXSTR) :: modName 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! Call into routine to retrieve internal class info 
 ! return directly from here if info is found 
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_AttributeGetInfo(grid, name=modName, & 
 valueList=valueList, inputList=inputList, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 return 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_R8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DAPR8 

!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DR8(grid, name, valueList, & 
 defaultvalueList, inputList, convention, purpose, & 
 attPackInstanceName, attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_Grid), intent(in) :: grid 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: inputList(:) 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attpack]}] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 !! TODO: this needs to be dynamically sized !!! 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! Call into routine to retrieve internal class info 
 ! return directly from here if info is found 
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_AttributeGetInfo(grid, name=modName, & 
 valueList=valueList, inputList=inputList, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 return 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_R8, litemcount, lattnestflag, valueList, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DR8 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetLgclAP(grid, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(in) :: grid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, localvalue 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, & 
 localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetLgcl(grid, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(in) :: grid 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetLgclListAP(grid, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, inputList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(in) :: grid 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: inputList(:) 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[inputList]}] 
! A list of the input parameters required to retrieve internal info. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 !! TODO: this needs to be dynamically sized !!! 
 character (len=ESMF_MAXSTR) :: modName 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! Call into routine to retrieve internal class info 
 ! return directly from here if info is found 
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_AttributeGetInfo(grid, name=modName, & 
 valueList=valueList, inputList=inputList, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 return 
 endif 
 
 litemCount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetLgclList(grid, name, valueList, & 
 defaultvalueList, inputList, convention, purpose, & 
 attPackInstanceName, attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(in) :: grid 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: inputList(:) 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[inputList]}] 
! A list of the input parameters required to retrieve internal info. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 !! TODO: this needs to be dynamically sized !!! 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! Call into routine to retrieve internal class info 
 ! return directly from here if info is found 
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_AttributeGetInfo(grid, name=modName, & 
 valueList=valueList, inputList=inputList, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 return 
 endif 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetCharAP(grid, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(in) :: grid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len = *), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer, dimension(1) :: lens 
 integer :: count 
 !! TODO: this needs to be dynamically sized !!! 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! Call into routine to retrieve internal class info 
 ! return directly from here if info is found 
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_AttributeGetInfo(grid, name=modName, & 
 value=value, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 return 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(grid, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, & 
 lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_GridAttGetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetChar(grid, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(in) :: grid 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 !! TODO: this needs to be dynamically sized !!! 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! Call into routine to retrieve internal class info 
 ! return directly from here if info is found 
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_AttributeGetInfo(grid, name=modName, & 
 value=value, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 return 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(grid, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, lens, value, & 
 localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(grid, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_GridAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character list Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetCharListAP(grid, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(in) :: grid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len=*), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(grid, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetCharList(grid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(in) :: grid 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(grid, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(grid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetCount(grid, count, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(in) :: grid 
 integer, intent(out) :: count 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given Attribute 
! package in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_Logical) :: isAttpack 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, & 
 attPackInstanceName=attPackInstanceName, & 
 attpack=attpack, attnestflag=lattnestflag, & 
 rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, & 
 lattcountflag, lattnestflag, & 
 localrc) 
 else 
 call c_ESMC_AttributeGetCount(grid, count, lattcountflag, & 
 localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetCount 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCountAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetCountAttPack(grid, attpack, count, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(in) :: grid 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, lattcountflag, & 
 lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetCountAttPack 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetInfoByNamAP(grid, name, attpack, & 
 keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(in) :: grid 
 character(len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(grid, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetInfoByNamAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetInfoByNam(grid, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(in) :: grid 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}.
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(grid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(grid, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(grid, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNumAP" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetInfoByNumAP(grid, attributeIndex, attpack, & 
 name, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(in) :: grid 
 integer, intent(in) :: attributeIndex 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character(len=*), intent(out) :: name 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentIndex(grid, attributeIndex, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(grid, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetInfoByNumAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetInfoByNum(grid, attributeIndex, name, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(in) :: grid 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentIndex(grid, attributeIndex, & 
 attpack, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(grid, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresentIndex(grid, attributeIndex, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoNum(grid, attributeIndex, & 
 localName, localTk, & 
 litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetInfoByNum 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_GridAttRead(grid, fileName, schemaFileName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len=*), intent(in), optional :: fileName 
 character (len=*), intent(in), optional :: schemaFileName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt grid}. 
! The Attribute package defines the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! \item [{[fileName]}] 
! The file name to read from. 
! \item [{[schemaFileName]}] 
! The name of the XSD file to validate fileName. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, schemaFileNameLen, localrc 
 
 fileNameLen = 0 
 schemaFileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 ! get length of given fileNames for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 if (present(schemaFileName)) then 
 schemaFileNameLen = len_trim(schemaFileName) 
 end if 
 
 ! invoke C to C++ entry point 
 call c_ESMC_AttributeRead(grid, fileNameLen, fileName, & 
 schemaFileNameLen, schemaFileName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttRead 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package using an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_GridAttRemoveAP(grid, keywordEnforcer, name, & 
 attpack, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(grid, name, attpack, & 
 lattnestflag, localrc) 
 else 
 call c_ESMC_AttPackRemove(grid, attpack, localrc) 
 ESMF_INIT_SET_DELETED(attpack) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttRemoveAP 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_GridAttRemove(grid, name, convention, purpose, & 
 attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpackobj 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemove(grid, attpackobj, lattnestflag, localrc) 
 ESMF_INIT_SET_DELETED(attpackobj) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemoveAttribute(grid, name, attpackobj, & 
 lattnestflag, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(grid, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetAPI1(grid, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetAPI1 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetI1(grid, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DAPI1(grid, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DI1(grid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetAPI2(grid, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetAPI2 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetI2(grid, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DAPI2(grid, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DI2(grid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetAPI4(grid, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetAPI4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetI4(grid, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DAPI4(grid, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DI4(grid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetAPI8(grid, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetAPI8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetI8(grid, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DAPI8(grid, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DI8(grid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetAPR4(grid, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetAPR4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetR4(grid, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DAPR4(grid, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DR4(grid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetAPR8(grid, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetAPR8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetR8(grid, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DAPR8(grid, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DR8(grid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetLgclAP(grid, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 localvalue = value 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetLgcl(grid, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented, 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetLgclListAP(grid, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetLgclList(grid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetCharAP(grid, name, value, attpack, & 
 keywordEnforcer, inputList, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: inputList(:) 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[inputList]}] 
! A list of the input parameters required to set internal info. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, memstat 
 integer, allocatable :: lens(:) 
 integer :: litemCount, i, j 
 character (len=ESMF_MAXSTR) :: modName 
 character, allocatable :: valueString(:) 
 integer :: lens_size, valuestring_size, tag_size 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 tag_size = 6 ! ':Input:' is 7 characters long 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! allocate arrays 
 if (present (inputList)) then 
 valuestring_size = len(value) 
 lens_size = 1 
 do i=1,size(inputList) 
 if (len_trim(inputList(i)) > 0) then 
 valuestring_size = valuestring_size + len_trim(inputList(i)) + tag_size 
 lens_size = lens_size + 1 
 endif 
 enddo 
 ! set the size of the new valueList 
 litemCount = lens_size 
 else 
 valuestring_size = len(value) 
 ! this is required for bluefire, it does not function well with 0 size allocations 
 if (len(value) == 0) then 
 valuestring_size = 1 
 endif 
 lens_size = 1 
 ! set the size of the new valueList 
 litemCount = 1 
 end if 
 
 allocate (lens (lens_size), stat = memstat) 
 lens = 0 
 if (ESMF_LogFoundAllocError(memstat, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 allocate (valueString (valuestring_size), stat = memstat) 
 valueString = "" 
 if (ESMF_LogFoundAllocError(memstat, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) then 
 deallocate(lens) 
 return 
 endif 
 
 ! this is required for bluefire, this block of code will not work with empty 
 ! attribute values, but that case should not happen with inputLists.. 
 if (len_trim(value) > 0) then 
 ! also for internal Attributes, must append inputList to the Attribute value 
 lens(1) = len_trim(value) 
 valueString(1:lens(1)) = ESMF_UtilString2Array(trim(value)) 
 endif 
 if (present(inputList)) then 
 j = lens(1) + 1 
 do i=2,litemCount 
 if (len_trim(inputList(i-1)) > 0) then 
 ! put inputList values into valueString 
 lens(i) = len_trim(inputList(i-1))+tag_size 
 valueString(j:(j+tag_size-1)) = ESMF_UtilString2Array("Input:") 
 j = j + tag_size 
 valueString(j:(j+lens(i)-tag_size-1)) = & 
 ESMF_UtilString2Array(trim(inputList(i-1))) 
 j = j + lens(i) 
 endif 
 enddo 
 endif 
 
 call c_ESMC_AttPackSetCharList(grid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundAllocError(memstat, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! deallocate 
 deallocate(lens) 
 deallocate(valueString) 
 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetChar(grid, name, value, inputList, & 
 convention, purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: inputList(:) 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[inputList]}] 
! A list of the input parameters required to set internal info. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, memstat 
 integer, allocatable :: lens(:) 
 type(ESMF_Logical) :: attpack 
 integer :: litemCount, i, j 
 character (len=ESMF_MAXSTR) :: modName 
 character, allocatable :: valueString(:) 
 integer :: lens_size, valuestring_size, tag_size 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 tag_size = 6 ! ':Input:' is 7 characters long 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! allocate arrays 
 if (present (inputList)) then 
 valuestring_size = len(value) 
 lens_size = 1 
 do i=1,size(inputList) 
 if (len_trim(inputList(i)) > 0) then 
 valuestring_size = valuestring_size + len_trim(inputList(i)) + tag_size 
 lens_size = lens_size + 1 
 endif 
 enddo 
 ! set the size of the new valueList 
 litemCount = lens_size 
 else 
 valuestring_size = len(value) 
 ! this is required for bluefire, it does not function well with 0 size allocations 
 if (len(value) == 0) then 
 valuestring_size = 1 
 endif 
 lens_size = 1 
 ! set the size of the new valueList 
 litemCount = 1 
 end if 
 
 allocate (lens (lens_size), stat = memstat) 
 lens = 0 
 if (ESMF_LogFoundAllocError(memstat, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 allocate (valueString (valuestring_size), stat = memstat) 
 valueString = "" 
 if (ESMF_LogFoundAllocError(memstat, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) then 
 deallocate(lens) 
 return 
 endif 
 
 ! this is required for bluefire, this block of code will not work with empty 
 ! attribute values, but that case should not happen with inputLists.. 
 if (len_trim(value) > 0) then 
 ! also for internal Attributes, must append inputList to the Attribute value 
 lens(1) = len_trim(value) 
 valueString(1:lens(1)) = ESMF_UtilString2Array(trim(value)) 
 endif 
 if (present(inputList)) then 
 j = lens(1) + 1 
 do i=2,litemCount 
 if (len_trim(inputList(i-1)) > 0) then 
 ! put inputList values into valueString 
 lens(i) = len_trim(inputList(i-1))+tag_size 
 valueString(j:(j+tag_size-1)) = ESMF_UtilString2Array("Input:") 
 j = j + tag_size 
 valueString(j:(j+lens(i)-tag_size-1)) = & 
 ESMF_UtilString2Array(trim(inputList(i-1))) 
 j = j + lens(i) 
 endif 
 enddo 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 deallocate(lens) 
 deallocate(valueString) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(grid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(grid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 
 ! deallocate 
 deallocate(lens) 
 deallocate(valueString) 
 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetCharListAP(grid, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackSetCharList(grid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetCharList(grid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_GridAttGetAttPack(grid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(grid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(grid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_GridAttWrite(grid, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(in) :: grid 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! This call is collective across the current VM. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, petCount, localPet 
 character(len=*), parameter :: object="grid" 
 character(len=*), parameter :: ftarobj="grid" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 type(ESMF_VM) :: vm 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 call ESMF_VMGetCurrent(vm, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localPet == 0) then 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttributeWrite(grid, convention, & 
 purpose, object, ftarobj, writeflag, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 call ESMF_VMBarrier(vm, rc=rc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttWrite 

!-------------------------------------------------------------------------
! LocStream
!-------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, keywordEnforcer, attPackInstanceName, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object.
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, count 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="locstream" 
 type(ESMF_AttPack) :: lattpack 
 character(len=max(len(convention), len(purpose))), dimension(3) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 count = 3 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! guard against a situation which cannot be prevented with the use of optional arguments 
 if (present(attpackInstanceName)) then 
 if (len(attpackInstanceName) > max(len(convention), len(purpose))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="TODO: initialize the specList with length dependent on attpackInstanceName", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 if (present(attpackInstanceName)) then 
 specList(3) = trim(attpackInstanceName) 
 count = 4 
 else 
 specList(3) = "" 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackGet(locstream%lstypep%base, lattpack, & 
 count, specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetAttPack 
!------------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPackSL" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_LocStreamAttGetAttPackSL(locstream, & 
 specList, keywordEnforcer, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="locstream" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if (size(specList) > 4) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackGet(locstream%lstypep%base, lattpack, & 
 size(lens), specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetAttPackSL 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStd" 
 
!BOPI 
! !IROUTINE: AttAddPackStd - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_LocStreamAttAddPackStd(locstream, convention, purpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An {\tt ESMF_LocStream} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j ! Error status 
 character (len=*), parameter :: object="locstream" 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (.not.((convention.eq."ESG" .and.purpose.eq."General").or. & 
 (convention.eq."ESMF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."Extended").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."grids").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."grids").or. & 
 (convention.eq."CIM 1.5".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."ModelComp").or. & 
 (convention.eq."CIM 1.5".and.purpose.eq."Inputs").or. & 
 (convention.eq."CIM 1.5.1".and.purpose.eq."Inputs").or. & 
 (convention.eq."CIM 1.7.1".and.purpose.eq."Inputs"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute package convention and purpose values", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackCreateStandard(locstream%lstypep%base, & 
 size(lens), specString, lens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_LocStreamAttGetAttPackSL(locstream, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_LocStreamAttAddPackCst(locstream, convention, purpose, attrList, & 
 count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt convention} and {\tt purpose} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 type(ESMF_AttPack) :: lattpack 
 logical :: lispresent, lredundant 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 call ESMF_LocStreamAttAddPackCstSL(locstream, specList, attrList, & 
 count=localcount, redundant=lredundant, & 
 attpack=lattpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_LocStreamAttAddPackCstN(locstream, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="locstream" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(locstream%lstypep%base, size(lens), specString, lens, & 
 localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(locstream%lstypep%base, attrList(i), & 
 size(lens), specString, lens, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_LocStreamAttGetAttPackSL(locstream, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_LocStreamAttAddPackCstN1(locstream, convention, purpose, attrList, & 
 count, nestConvention, nestPurpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribvute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_LocStreamAttAddPackCstN(locstream, & 
 convention, purpose, & 
 attrList, count, & 
 nestConvString, nestPurpString, & 
 nestCount=1, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttAddPackCstN1
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStdSL" 
 
!BOPI 
! !IROUTINE: AttAddPackStdSL - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_LocStreamAttAddPackStdSL(locstream, specList, keywordEnforcer, & 
 attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An {\tt ESMF_LocStream} object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j ! Error status 
 character (len=*), parameter :: object="locstream" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (.not.((specList(1).eq."ESG" .and.specList(2).eq."General").or. & 
 (specList(1).eq."ESMF" .and.specList(2).eq."General").or. & 
 (specList(1).eq."CF" .and.specList(2).eq."General").or. & 
 (specList(1).eq."CF" .and.specList(2).eq."Extended").or. & 
 (specList(1).eq."CIM 1.5.1".and.specList(2).eq."grids").or. & 
 (specList(1).eq."CIM 1.7.1".and.specList(2).eq."grids").or. & 
 (specList(1).eq."CIM 1.5" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.5.1" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.7.1" .and.specList(2).eq."ModelComp").or. & 
 (specList(1).eq."CIM 1.5" .and.specList(2).eq."Inputs").or. & 
 (specList(1).eq."CIM 1.5.1" .and.specList(2).eq."Inputs").or. & 
 (specList(1).eq."CIM 1.7.1" .and.specList(2).eq."Inputs"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute packages", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 ! create the attribute package 
 call c_ESMC_AttPackCreateStandard(locstream%lstypep%base, & 
 size(lens), specString, lens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! retrieve the optional attribute package handle 
 if (present(attpack)) then 
 
 call ESMF_LocStreamAttGetAttPackSL(locstream, specList, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttAddPackStdSL
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstSL" 
!BOPI 
! !IROUTINE: AttAddPackCstSL - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_LocStreamAttAddPackCstSL(locstream, specList, attrList, & 
 keywordEnforcer, count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), dimension(:), intent(in) :: specList 
 character (len = *), dimension(:), intent(in) :: attrList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! convention, purpose, and instancename. 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt specList} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack}]] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=*), parameter :: object="locstream" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 logical :: attpackpresent, lredundant 
 logical :: lispresent, createnewattpack, addtoattpack 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 lispresent = .false. 
 createnewattpack = .false. 
 addtoattpack = .false. 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 ! verify that the count and number of attribute names are reasonable 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if ( lredundant .eqv. .true. ) then 
 createnewattpack = .true. 
 else 
 call ESMF_LocStreamAttGetAttPackSL(locstream, specList, attpack=lattpack, & 
 isPresent=lispresent, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lispresent .eqv. .false.) then 
 createnewattpack = .true. 
 else 
 addtoattpack = .true. 
 endif 
 endif 
 
 if ( createnewattpack .eqv. .true. ) then 
 call c_ESMC_AttPackCreateCustom(locstream%lstypep%base, & 
 size(lens), specString, lens, & 
 lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 else if ( addtoattpack .eqv. .true. ) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 endif 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttAddPackCstSL
!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetAPI1(locstream, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetI1(locstream, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(locstream%lstypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetI1 
!------------------------------------------------------------------------------ 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetAPI2(locstream, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetI2(locstream, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(locstream%lstypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetI2 
!------------------------------------------------------------------------------ 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetAPI4(locstream, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetI4(locstream, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(locstream%lstypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetI4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetAPI8(locstream, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetI8(locstream, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(locstream%lstypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetI8 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetAPR4(locstream, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetR4(locstream, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(locstream%lstypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetR4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetAPR8(locstream, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetR8(locstream, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(locstream%lstypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetR8 
!------------------------------------------------------------------------------ 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGet1DAPI1(locstream, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_I1, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(locstream%lstypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGet1DAPI1 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGet1DI1(locstream, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_I1, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(locstream%lstypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(locstream%lstypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGet1DAPI2(locstream, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_I2, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(locstream%lstypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGet1DAPI2 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGet1DI2(locstream, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_I2, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(locstream%lstypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(locstream%lstypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGet1DAPI4(locstream, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_I4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(locstream%lstypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGet1DAPI4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGet1DI4(locstream, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_I4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(locstream%lstypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(locstream%lstypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGet1DAPI8(locstream, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_I8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(locstream%lstypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGet1DAPI8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGet1DI8(locstream, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_I8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(locstream%lstypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(locstream%lstypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGet1DAPR4(locstream, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_R4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(locstream%lstypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGet1DAPR4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGet1DR4(locstream, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_R4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(locstream%lstypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(locstream%lstypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGet1DAPR8(locstream, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_R8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(locstream%lstypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGet1DAPR8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGet1DR8(locstream, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_R8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(locstream%lstypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(locstream%lstypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetLgclAP(locstream, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, localvalue 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetLgcl(locstream, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(locstream%lstypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetLgclListAP(locstream, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(locstream%lstypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetLgclList(locstream, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(locstream%lstypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(locstream%lstypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetCharAP(locstream, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len = *), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_LocStreamAttGetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetChar(locstream, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, & 
 lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(locstream%lstypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(locstream%lstypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_LocStreamAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetCharListAP(locstream, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len=*), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(locstream%lstypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetCharList(locstream, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(locstream%lstypep%base, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(locstream%lstypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(locstream%lstypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(locstream%lstypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetCount(locstream, count, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(in) :: locstream 
 integer, intent(out) :: count 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given Attribute 
! package in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_Logical) :: isAttpack 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, & 
 attPackInstanceName=attPackInstanceName, & 
 attpack=attpack, attnestflag=lattnestflag, & 
 rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, & 
 lattcountflag, lattnestflag, & 
 localrc) 
 else 
 call c_ESMC_AttributeGetCount(locstream%lstypep%base, count, lattcountflag, & 
 localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetCount 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCountAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetCountAttPack(locstream, attpack, count, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(in) :: locstream 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, lattcountflag, & 
 lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetCountAttPack 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetInfoByNamAP(locstream, name, attpack, & 
 keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(in) :: locstream 
 character(len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(locstream%lstypep%base, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetInfoByNamAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetInfoByNam(locstream, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(in) :: locstream 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}.
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(locstream%lstypep%base, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(locstream%lstypep%base, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(locstream%lstypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(locstream%lstypep%base, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNumAP" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetInfoByNumAP(locstream, attributeIndex, attpack, & 
 name, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(in) :: locstream 
 integer, intent(in) :: attributeIndex 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character(len=*), intent(out) :: name 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentIndex(locstream%lstypep%base, attributeIndex, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(locstream%lstypep%base, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetInfoByNumAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_LocStreamAttGetInfoByNum(locstream, attributeIndex, name, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(in) :: locstream 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentIndex(locstream%lstypep%base, attributeIndex, & 
 attpack, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(locstream%lstypep%base, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresentIndex(locstream%lstypep%base, attributeIndex, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoNum(locstream%lstypep%base, attributeIndex, & 
 localName, localTk, & 
 litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttGetInfoByNum 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_LocStreamAttRead(locstream, fileName, schemaFileName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len=*), intent(in), optional :: fileName 
 character (len=*), intent(in), optional :: schemaFileName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt locstream}. 
! The Attribute package defines the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An {\tt ESMF_LocStream} object. 
! \item [{[fileName]}] 
! The file name to read from. 
! \item [{[schemaFileName]}] 
! The name of the XSD file to validate fileName. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, schemaFileNameLen, localrc 
 
 fileNameLen = 0 
 schemaFileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 ! get length of given fileNames for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 if (present(schemaFileName)) then 
 schemaFileNameLen = len_trim(schemaFileName) 
 end if 
 
 ! invoke C to C++ entry point 
 call c_ESMC_AttributeRead(locstream%lstypep%base, fileNameLen, fileName, & 
 schemaFileNameLen, schemaFileName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttRead 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package using an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_LocStreamAttRemoveAP(locstream, keywordEnforcer, name, & 
 attpack, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(locstream%lstypep%base, name, attpack, & 
 lattnestflag, localrc) 
 else 
 call c_ESMC_AttPackRemove(locstream%lstypep%base, attpack, localrc) 
 ESMF_INIT_SET_DELETED(attpack) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttRemoveAP 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_LocStreamAttRemove(locstream, name, convention, purpose, & 
 attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpackobj 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemove(locstream%lstypep%base, attpackobj, lattnestflag, localrc) 
 ESMF_INIT_SET_DELETED(attpackobj) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemoveAttribute(locstream%lstypep%base, name, attpackobj, & 
 lattnestflag, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(locstream%lstypep%base, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetAPI1(locstream, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetAPI1 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetI1(locstream, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSet1DAPI1(locstream, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSet1DAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSet1DI1(locstream, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetAPI2(locstream, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetAPI2 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetI2(locstream, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSet1DAPI2(locstream, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSet1DAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSet1DI2(locstream, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetAPI4(locstream, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetAPI4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetI4(locstream, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSet1DAPI4(locstream, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSet1DAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSet1DI4(locstream, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetAPI8(locstream, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetAPI8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetI8(locstream, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSet1DAPI8(locstream, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSet1DAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSet1DI8(locstream, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetAPR4(locstream, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetAPR4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetR4(locstream, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSet1DAPR4(locstream, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSet1DAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSet1DR4(locstream, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetAPR8(locstream, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetAPR8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetR8(locstream, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSet1DAPR8(locstream, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSet1DAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSet1DR8(locstream, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetLgclAP(locstream, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 localvalue = value 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetLgcl(locstream, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented, 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetLgclListAP(locstream, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetLgclList(locstream, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(locstream%lstypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetCharAP(locstream, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 lens(1) = len_trim(value) 
 count = 1 
 
 call c_ESMC_AttPackSetCharList(locstream%lstypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetChar(locstream, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(locstream%lstypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(locstream%lstypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetCharListAP(locstream, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackSetCharList(locstream%lstypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_LocStreamAttSetCharList(locstream, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_LocStreamAttGetAttPack(locstream, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(locstream%lstypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(locstream%lstypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_LocStreamAttUpdate(locstream, vm, rootList, reconcile, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(inout) :: locstream 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 logical, intent(in), optional :: reconcile 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An {\tt ESMF_LocStream} object. 
! \item [vm] 
! The virtual machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of PETs that are to be used to as the source of the update. 
! \item [{[reconcile]}] 
! A logical flag used to indicate whether to use reconcile behavior or 
! normal update behavior. If {\tt reconcile} is set to {\tt ESMF\_TRUE} 
! then the values of the root PETs will be sent to the nonroot PETs without 
! exception. Otherwise, an algorithm that is optimized to use minimal 
! memory will be used to update only the modified parts of the Attribute 
! hierarchy on the nonroot PETs. The default value is {\tt ESMF\_FALSE}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 type(ESMF_Logical) :: local_reconcile 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 ! reconcile 
 if ( present(reconcile)) then 
 local_reconcile = reconcile 
 else 
 local_reconcile = ESMF_FALSE 
 endif 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(locstream%lstypep%base, vm, rootList, count, & 
 local_reconcile, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_LocStreamAttWrite(locstream, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_LocStream), intent(in) :: locstream 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! This call is collective across the current VM. 
! 
! The arguments are: 
! \begin{description} 
! \item [locstream] 
! An {\tt ESMF_LocStream} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, petCount, localPet 
 character(len=*), parameter :: object="locstream" 
 character(len=*), parameter :: ftarobj="locstream" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 type(ESMF_VM) :: vm 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 
 
 call ESMF_VMGetCurrent(vm, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localPet == 0) then 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttributeWrite(locstream%lstypep%base, convention, & 
 purpose, object, ftarobj, writeflag, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 call ESMF_VMBarrier(vm, rc=rc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_LocStreamAttWrite 

!-------------------------------------------------------------------------
! DISTGRID
!-------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, keywordEnforcer, attPackInstanceName, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object.
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, count 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="distgrid" 
 type(ESMF_AttPack) :: lattpack 
 character(len=max(len(convention), len(purpose))), dimension(3) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 count = 3 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! guard against a situation which cannot be prevented with the use of optional arguments 
 if (present(attpackInstanceName)) then 
 if (len(attpackInstanceName) > max(len(convention), len(purpose))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="TODO: initialize the specList with length dependent on attpackInstanceName", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 if (present(attpackInstanceName)) then 
 specList(3) = trim(attpackInstanceName) 
 count = 4 
 else 
 specList(3) = "" 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackGet(distgrid, lattpack, & 
 count, specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetAttPack 
!------------------------------------------------------------------------------

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAttPackSL" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGetAttPack - Retrieve a handle to an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGetAttPack() 
 subroutine ESMF_DistGridAttGetAttPackSL(distgrid, & 
 specList, keywordEnforcer, & 
 attpack, attnestflag, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), dimension(:), intent(in) :: specList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [{[attpack]}] 
! The Attribute package to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute package, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute package is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j 
 type(ESMF_Logical) :: lisPresent 
 character(len=*), parameter :: object="distgrid" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if (size(specList) > 4) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackGet(distgrid, lattpack, & 
 size(lens), specString, lens, & 
 lattnestflag, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if (present(attpack)) then 
 if (lisPresent == ESMF_TRUE) then 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 else 
 if (.not. present (isPresent)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_FOUND, & 
 msg="attpack cannot be found and ispresent not supplied", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetAttPackSL 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_DistGridAttAddPackCst(distgrid, convention, purpose, attrList, & 
 count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt convention} and {\tt purpose} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 type(ESMF_AttPack) :: lattpack 
 logical :: lispresent, lredundant 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 call ESMF_DistGridAttAddPackCstSL(distgrid, specList, attrList, & 
 count=localcount, redundant=lredundant, & 
 attpack=lattpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_DistGridAttAddPackCstN(distgrid, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="distgrid" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 
 character(len=max(len(convention), len(purpose))), dimension(2) :: specList 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! make specList out of convention and purpose 
 specList(1) = trim(convention) 
 specList(2) = trim(purpose) 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(distgrid, size(lens), specString, lens, & 
 localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(distgrid, attrList(i), & 
 size(lens), specString, lens, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 call ESMF_DistGridAttGetAttPackSL(distgrid, & 
 specList, & 
 attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_DistGridAttAddPackCstN1(distgrid, convention, purpose, attrList, & 
 count, nestConvention, nestPurpose, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribvute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[attpack]}] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_DistGridAttAddPackCstN(distgrid, & 
 convention, purpose, & 
 attrList, count, & 
 nestConvString, nestPurpString, & 
 nestCount=1, attpack=attpack, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttAddPackCstN1
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstSL" 
!BOPI 
! !IROUTINE: AttAddPackCstSL - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_DistGridAttAddPackCstSL(distgrid, specList, attrList, & 
 keywordEnforcer, count, redundant, attpack, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), dimension(:), intent(in) :: specList 
 character (len = *), dimension(:), intent(in) :: attrList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: count 
 logical, intent(in), optional :: redundant 
 type(ESMF_AttPack), intent(inout), optional :: attpack 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [specList] 
! A character list of values which identify the Attribute package, such as 
! convention, purpose, and instancename. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! convention, purpose, and instancename. 
! \item [{[redundant]}] 
! A flag to determine whether or not to create redundant Attribute 
! packages. If an Attribute package already exists with the specified 
! {\tt specList} and {\tt redundant} is set to 
! {\tt .true.} then a redundant Attribute package will be created. 
! The default value is {\tt .false.}. 
! \item [{[attpack}]] 
! An optional handle to the Attribute package that is to be created. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, localCount 
 character(len=*), parameter :: object="distgrid" 
 integer, dimension(size(specList)+1) :: lens 
 character(len=(max(len(specList),len(object))*(size(specList)+1))) :: specString 
 type(ESMF_AttPack) :: lattpack 
 logical :: attpackpresent, lredundant 
 logical :: lispresent, createnewattpack, addtoattpack 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 lispresent = .false. 
 createnewattpack = .false. 
 addtoattpack = .false. 
 
 ! handle redundant 
 if ( present (redundant) ) then 
 lredundant = redundant 
 else 
 lredundant = .false. 
 endif 
 
 ! verify that the count and number of attribute names are reasonable 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 ! verify that the specList has some minimum requirements 
 if (size(specList) < 2) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList must contain at least two specifying pieces of information", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 elseif (size(specList) > 3) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="specList can only contain convention, purpose, and attpackinstance name for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! collapse the specList into a string to pass down to the C glue layer 
 i = 1 
 j = 1 
 lens(i) = len(object) 
 specString(j:(j+lens(i)-1)) = object 
 j = j+lens(i) 
 do i=2,(size(specList)+1) 
 lens(i) = len_trim(specList(i-1)) 
 specString(j:(j+lens(i)-1)) = trim(specList(i-1)) 
 j = j + lens(i) 
 enddo 
 
 if ( lredundant .eqv. .true. ) then 
 createnewattpack = .true. 
 else 
 call ESMF_DistGridAttGetAttPackSL(distgrid, specList, attpack=lattpack, & 
 isPresent=lispresent, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lispresent .eqv. .false.) then 
 createnewattpack = .true. 
 else 
 addtoattpack = .true. 
 endif 
 endif 
 
 if ( createnewattpack .eqv. .true. ) then 
 call c_ESMC_AttPackCreateCustom(distgrid, & 
 size(lens), specString, lens, & 
 lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 else if ( addtoattpack .eqv. .true. ) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAtt(attrList(i), lattpack, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end do 
 endif 
 
 if ( present(attpack) ) then 
 ! retrieve the optional attribute package handle 
 attpack = lattpack 
 ! set the created macro 
 ESMF_INIT_SET_CREATED(attpack) 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttAddPackCstSL
!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetAPI1(distgrid, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetI1(distgrid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_I1, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetI1 
!------------------------------------------------------------------------------ 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetAPI2(distgrid, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetI2(distgrid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_I2, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetI2 
!------------------------------------------------------------------------------ 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetAPI4(distgrid, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetI4(distgrid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_I4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetI4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetAPI8(distgrid, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetI8(distgrid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_I8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetI8 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetAPR4(distgrid, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetR4(distgrid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_R4, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetR4 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetAPR8(distgrid, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetR8(distgrid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, & 
 attnestflag, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_R8, count, lattnestflag, value, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetR8 
!------------------------------------------------------------------------------ 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DAPI1(distgrid, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_I1, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DAPI1 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DI1(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_I1, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DAPI2(distgrid, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_I2, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DAPI2 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DI2(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_I2, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DAPI4(distgrid, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_I4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DAPI4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DI4(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_I4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DAPI8(distgrid, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_I8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DAPI8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DI8(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_I8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DAPR4(distgrid, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_R4, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DAPR4 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DR4(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_R4, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DAPR8(distgrid, name, attpack, & 
 valueList, keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_R8, litemCount, lattnestflag, & 
 valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DAPR8 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DR8(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The list of real values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The list of real default values of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the Attribute value to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_R8, litemcount, lattnestflag, & 
 valueList, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetLgclAP(distgrid, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, localvalue 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetLgcl(distgrid, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, count, lattnestflag, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetLgclListAP(distgrid, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 logical, dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetLgclList(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, attpack, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, lattnestflag, valueList, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetCharAP(distgrid, name, attpack, value, & 
 keywordEnforcer, defaultvalue, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len = *), intent(out) :: value 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: defaultvalue 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(distgrid, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_DistGridAttGetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetChar(distgrid, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, attnestflag, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(in), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 type(ESMF_AttPack) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 lens(1) = len(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(distgrid, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, count, lattnestflag, & 
 lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(distgrid, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_DistGridAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetCharListAP(distgrid, name, attpack, valueList, & 
 keywordEnforcer, defaultvalueList, attnestflag, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character (len=*), dimension(:), intent(out) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(distgrid, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetCharList(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 attnestflag, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(distgrid, name, attpack, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lattnestflag, & 
 lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(distgrid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetCount(distgrid, count, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 integer, intent(out) :: count 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given Attribute 
! package in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_Logical) :: isAttpack 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, & 
 attPackInstanceName=attPackInstanceName, & 
 attpack=attpack, attnestflag=lattnestflag, & 
 rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, & 
 lattcountflag, lattnestflag, & 
 localrc) 
 else 
 call c_ESMC_AttributeGetCount(distgrid, count, lattcountflag, & 
 localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetCount 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCountAttPack" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetCountAttPack(distgrid, attpack, count, & 
 attcountflag, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [{[attcountflag]}] 
! Flag to determine which Attribute count to return. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when counting Attributes, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttributeGetCountAttPack(attpack, count, lattcountflag, & 
 lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetCountAttPack 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name from an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetInfoByNamAP(distgrid, name, attpack, & 
 keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character(len=*), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(distgrid, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetInfoByNamAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetInfoByNam(distgrid, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! The typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}.
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentAtt(distgrid, name, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(distgrid, name, attpack, & 
 lattnestflag, localTk, litemCount, & 
 localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNumAP" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetInfoByNumAP(distgrid, attributeIndex, attpack, & 
 name, attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 integer, intent(in) :: attributeIndex 
 type(ESMF_AttPack), intent(inout) :: attpack 
 character(len=*), intent(out) :: name 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 call c_ESMC_AttPackIsPresentIndex(distgrid, attributeIndex, attpack, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(distgrid, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 end if 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetInfoByNumAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetInfoByNum(distgrid, attributeIndex, name, & 
 convention, purpose, attPackInstanceName, & 
 attnestflag, typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. This flag is documented in section 
! \ref{const:typekind}. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 integer :: litemCount 
 type(ESMF_AttPack) :: attpack 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpack, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackIsPresentIndex(distgrid, attributeIndex, & 
 attpack, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoNum(distgrid, attributeIndex, attpack, & 
 localName, lattnestflag, localTk, & 
 litemCount, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresentIndex(distgrid, attributeIndex, & 
 lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoNum(distgrid, attributeIndex, & 
 localName, localTk, & 
 litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 name = localName 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 name = "" 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetInfoByNum 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package using an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_DistGridAttRemoveAP(distgrid, keywordEnforcer, name, & 
 attpack, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len = *), intent(in), optional :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(distgrid, name, attpack, & 
 lattnestflag, localrc) 
 else 
 call c_ESMC_AttPackRemove(distgrid, attpack, localrc) 
 ESMF_INIT_SET_DELETED(attpack) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttRemoveAP 
!------------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_DistGridAttRemove(distgrid, name, convention, purpose, & 
 attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [{[name]}] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when searching for this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 type(ESMF_AttPack) :: attpackobj 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemove(distgrid, attpackobj, lattnestflag, localrc) 
 ESMF_INIT_SET_DELETED(attpackobj) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackRemoveAttribute(distgrid, name, attpackobj, & 
 lattnestflag, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(distgrid, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetAPI1(distgrid, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetAPI1 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetI1(distgrid, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DAPI1(distgrid, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DAPI1 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DI1(distgrid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetAPI2(distgrid, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetAPI2 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetI2(distgrid, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DAPI2(distgrid, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DAPI2 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DI2(distgrid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetAPI4(distgrid, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetAPI4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetI4(distgrid, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DAPI4(distgrid, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DAPI4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DI4(distgrid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetAPI8(distgrid, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetAPI8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetI8(distgrid, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DAPI8(distgrid, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DAPI8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DI8(distgrid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetAPR4(distgrid, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetAPR4 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetR4(distgrid, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DAPR4(distgrid, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DAPR4 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DR4(distgrid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetAPR8(distgrid, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetAPR8 
 
!------------------------------------------------------------------------------ 
 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetR8(distgrid, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DAPR8(distgrid, name, & 
 valueList, attpack, keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 type(ESMF_AttPack), intent(inout) :: attpack 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DAPR8 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DR8(distgrid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetLgclAP(distgrid, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 localvalue = value 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetLgclAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetLgcl(distgrid, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented, 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetLgclListAP(distgrid, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetLgclListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetLgclList(distgrid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetCharAP(distgrid, name, value, attpack, & 
 keywordEnforcer, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 

 lens(1) = len_trim(value) 
 count = 1 
 
 call c_ESMC_AttPackSetCharList(distgrid, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetCharAP 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetChar(distgrid, name, value, convention, & 
 purpose, attPackInstanceName, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(distgrid, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(distgrid, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute in an ESMF_AttPack 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetCharListAP(distgrid, name, valueList, attpack, & 
 keywordEnforcer, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 type(ESMF_AttPack), intent(inout) :: attpack 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [attpack] 
! An Attribute package handle containing identifying information. 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_AttributeGetInit, attpack, rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 call c_ESMC_AttPackSetCharList(distgrid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpack, lattnestflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetCharListAP 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetCharList(distgrid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, attnestflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[attnestflag]}] 
! A flag to determine whether to descend the 
! Attribute hierarchy when setting this Attribute, 
! the default is {\tt ESMF\_ATTNEST\_ON}. This flag is documented 
! in section \ref{const:attnest}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 
 character (len=ESMF_MAXSTR) :: modName 
 type(ESMF_AttPack) :: attpackobj 
 type(ESMF_AttNest_Flag) :: lattnestflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attnestflag)) then 
 lattnestflag = attnestflag 
 else 
 lattnestflag = ESMF_ATTNEST_ON 
 endif 
 
 !!!! TODO: this can go away once modName is dynamically sized !!! 
 if (len(name) > ESMF_MAXSTR) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="len(name) cannot be larger than ESMF_MAXSTR for now", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'
 if (AttributeInternalInfo(name, modName)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & 
 msg="Attribute names starting with 'ESMF:' are not allowed!", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call ESMF_DistGridAttGetAttPack(distgrid, & 
 convention, purpose, attpack=attpackobj, & 
 attPackInstanceName=attPackInstanceName, & 
 attnestflag=lattnestflag, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttPackSetCharList(distgrid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, attpackobj, lattnestflag, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(distgrid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_DistGridAttWrite(distgrid, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(in) :: distgrid 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! This call is collective across the current VM. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An {\tt ESMF_DistGrid} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, petCount, localPet 
 character(len=*), parameter :: object="distgrid" 
 character(len=*), parameter :: ftarobj="distgrid" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 type(ESMF_VM) :: vm 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 call ESMF_VMGetCurrent(vm, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localPet == 0) then 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttributeWrite(distgrid, convention, & 
 purpose, object, ftarobj, writeflag, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 endif 
 
 call ESMF_VMBarrier(vm, rc=rc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttWrite 

!------------------------------------------------------------------------------
end module ESMF_AttributeMod
